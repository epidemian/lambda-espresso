(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,(function(r){var n=e[i][1][r];return o(n||r)}),p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:true});const dom_1=require("./dom");const examples_1=__importDefault(require("./examples"));const lambda_1=require("./lambda");const utils_1=require("./utils");(0,utils_1.enableLogTimings)();const input=(0,dom_1.$)(".input");const output=(0,dom_1.$)(".output");document.addEventListener("keyup",(e=>{if(e.keyCode===13&&e.ctrlKey){run()}}));input.addEventListener("beforeinput",(event=>{if(event.data?.includes("\\")){event.preventDefault();const replaced=event.data.replace(/\\/g,"Î»");const start=input.selectionStart||0;const end=input.selectionEnd||0;const value=input.value;input.value=value.slice(0,start)+replaced+value.slice(end);input.selectionStart=input.selectionEnd=start+1}}));(0,dom_1.$)(".run").addEventListener("click",(_=>run()));const renderTerm=(term,className="")=>`<span class="term ${className}">${term}</span>`;const renderArrow=(symbol,label)=>`<span class=arrow>${symbol}<small>${label}</small></span>`;const arrowSymbols={def:["â‰¡",""],alpha:["â‰¡","Î±"],beta:["â†’","Î²"],eta:["â†’","Î·"]};const renderSynonyms=synonyms=>synonyms.length?`<span class=synonyms>(${synonyms.join(", ")})</span>`:"";const getOptions=()=>{const maxReductionSteps=parseInt((0,dom_1.$)("input[name=max-steps]").value||"0",10);const strategy=(0,dom_1.$)("input[name=strategy]:checked").value;const etaEnabled=(0,dom_1.$)("[name=eta-reductions]").checked;return{maxReductionSteps:maxReductionSteps,strategy:strategy,etaEnabled:etaEnabled}};let reductions=[];const run=()=>{const code=input.value;try{reductions=(0,lambda_1.reduceProgram)(code,getOptions());renderReductions()}catch(err){output.textContent=err instanceof Error?err.message:String(err);output.classList.add("error")}};const renderReductions=(0,utils_1.timed)("render html",(()=>{output.innerHTML=reductions.map(renderCollapsedReduction).join("");output.classList.remove("error")}));(0,dom_1.delegate)("click",output,".reduction",(element=>{const reduction=reductions[(0,dom_1.nodeIndex)(element)];if(reduction.totalSteps===0){return}const expanded=element.querySelector(".expanded");const collapsed=element.querySelector(".collapsed");if(expanded){expanded.classList.toggle("hidden");collapsed?.classList.toggle("hidden")}else{collapsed?.classList.add("hidden");element.innerHTML+=renderExpandedReductionForm(reduction)}}));(0,dom_1.delegate)("mouseover",output,".expanded .step",(element=>{element.classList.add("highlight");const prev=element.previousElementSibling;if(prev){prev.querySelector(".after")?.classList.add("hidden")}}));(0,dom_1.delegate)("mouseout",output,".expanded .step",(element=>{element.classList.remove("highlight");const prev=element.previousElementSibling;if(prev){prev.querySelector(".after")?.classList.remove("hidden")}}));const renderCollapsedReduction=reduction=>`<div class=reduction>${renderCollapsedReductionForm(reduction)}</div>`;const renderCollapsedReductionForm=reduction=>{const initial=renderTerm(reduction.initial);let arrow="";let final="";if(reduction.reductionSteps>0){arrow=renderArrow("â†’",`(${reduction.reductionSteps})`);final=renderTerm(reduction.final)}const synonyms=renderSynonyms(reduction.finalSynonyms);return`<div class=collapsed>${initial} ${arrow} ${final} ${synonyms}</div>`};const renderExpandedReductionForm=reduction=>{const steps=[];for(let i=0;i<reduction.totalSteps;i++){const step=reduction.renderStep(i,renderStepOptions);const before=renderTerm(step.before,"before");const after=renderTerm(step.after,"after");const[arrowSymbol,arrowLabel]=arrowSymbols[step.type];const arrow=renderArrow(arrowSymbol,arrowLabel);const lastStep=i===reduction.totalSteps-1;const synonyms=lastStep?renderSynonyms(reduction.finalSynonyms):"";steps.push(`<span class=step>${before}<br>${arrow} ${after} ${synonyms}</span>`)}return`<div class=expanded>${steps.join("")}</div>`};const renderStepOptions={highlightStep:s=>`<span class=match>${s}</span>`,highlightFormerTerm:s=>`<span class=former-term>${s}</span>`,highlightSubstitutionTerm:s=>`<span class=subst-term>${s}</span>`};input.value=(0,utils_1.dedent)(`\n  ; Write some Î»-expressions here and hit Run. Use "\\" to enter "Î»" ;)\n  (Î»x.Î»y.Î»z.z y x) a b c\n`);input.focus();const examplesMenu=(0,dom_1.$)(".examples-menu");const examplesHtml=examples_1.default.map(((example,i)=>{const href=encodeURI(`#>${example.code}`);return`<li><a href="${href}">${i} - ${example.name}</a></li>`}));examplesMenu.innerHTML=examplesHtml.join("");(0,dom_1.delegate)("click",examplesMenu,"li",((element,event)=>{event.preventDefault();input.value=examples_1.default[(0,dom_1.nodeIndex)(element)].code;input.scrollTop=0}));const examplesDropdown=(0,dom_1.$)(".examples-dropdown");examplesDropdown.addEventListener("click",(e=>{if(examplesDropdown.classList.contains("active")){return}e.stopPropagation();examplesDropdown.classList.add("active");document.addEventListener("click",(()=>{examplesDropdown.classList.remove("active")}),{once:true})}));(0,dom_1.$)("button.link").addEventListener("click",(()=>{const code=encodeURIComponent(input.value);location.hash=`>${code}`}));const updateInputFromHash=()=>{const hash=decodeURIComponent(location.hash);const codeStart=hash.indexOf(">");if(codeStart>=0){input.value=hash.slice(codeStart+1)}};window.addEventListener("hashchange",updateInputFromHash);updateInputFromHash()},{"./dom":2,"./examples":3,"./lambda":9,"./utils":15}],2:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.nodeIndex=exports.delegate=exports.$=void 0;const $=s=>document.querySelector(s);exports.$=$;const delegate=(eventType,element,selector,handler)=>{element.addEventListener(eventType,(event=>{if(event.target instanceof Element){const closest=event.target.closest(selector);if(closest&&element.contains(closest)){handler(closest,event)}}}))};exports.delegate=delegate;const nodeIndex=element=>Array.prototype.indexOf.call(element.parentNode?.childNodes,element);exports.nodeIndex=nodeIndex},{}],3:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});const utils_1=require("./utils");const examples=[{name:"Basics",code:(0,utils_1.dedent)(`\n    ; This example is not intend to be a tutorial nor an introduction to Î» Calculus.\n    ; You should check http://en.wikipedia.org/wiki/Lambda_calculus for that :)\n    ; As you can see, these are comments. You can run this example clicking the Run\n    ; button below or pressing Ctrl+Enter.\n    ; So, the three basic types of Î» expressions are:\n    ; Variables:\n    x\n    ; Applications:\n    x y\n    ; And lambda abstractions (also known as functions):\n    Î»x.x\n    ; If the left-side of an application is an abstraction, then a reduction takes place:\n    (Î»x.x) y\n    ; That little abstraction at the left is the identity, a very simple function that\n    ; just reduces to whatever you apply to it. We can give it a name like so:\n    id = Î»x.x\n    ; And then just refer it by that name:\n    id a\n    ; You can apply any kind of Î» expression to an abstraction, like another function:\n    id Î»b.c\n    ; Or an application:\n    id (x y)\n    ; Or even the identity function itself:\n    id id\n    ; That means you can apply identity to itself as many times as you want and it'll still\n    ; be identity:\n    id id id id id\n    ; Notice that applications are left-associative, so the line above is equivalent to:\n    ((((id id) id) id) id)\n\n    ; TODO: explain applicative and normal order...\n  `)},{name:"Booleans",code:(0,utils_1.dedent)(`\n    ; Church booleans\n\n    ; The booleans and their operations can be encoded as the following Î»-terms:\n    true = Î»t.Î»f.t\n    false = Î»t.Î»f.f\n    not = Î»p.p false true\n    and = Î»p.Î»q.p q p\n    or = Î»p.Î»q.p p q\n    if = Î»p.p\n\n    ; Print truth tables for not, and and or:\n    not true\n    not false\n    and false false\n    and false true\n    and true false\n    and true true\n    or false false\n    or false true\n    or true false\n    or true true\n\n    ; Terms can be nested as much as we want:\n    if (not (not true)) (or false (if true true false)) false\n\n    ; There's nothing special about "operators", we can treat them as any other value:\n    (if false or and) true false\n  `)},{name:"Numbers",code:(0,utils_1.dedent)(`\n    ; Church numerals\n\n    ; The first few numbers are:\n    zero = Î»s.Î»z.z\n    one = Î»s.Î»z.s z\n    two = Î»s.Î»z.s (s z)\n    three = Î»s.Î»z.s (s (s z))\n    ; In general, any natural number n can be encoded as:\n    ; N = Î»s.Î»z.s (s (s ... (s (s z)) ... ))\n    ; with s applied n times.\n\n    ; When we get tired of writing numbers like that, we can define a successor function:\n    succ = Î»n.Î»s.Î»z.s (n s z)\n    succ three\n\n    ; We can think of Church numerals as functions that apply a given function s to a\n    ; given value z a number of times. Zero will apply it 0 times (i.e. it'll give\n    ; us z back untouched) and three will call it 3 times.\n    ; So, we can represent the addition of numbers m and n as first applying n times s to z,\n    ; and then applying m times s to that:\n    add = Î»m.Î»n.Î»s.Î»z.m s (n s z)\n    add two three\n    ; ...or, more succinctly, as applying n times the successor function on m (or vice versa):\n    add' = Î»m.Î»n.n succ m\n    add' two three\n    ; Conversely, we could define the successor function as adding one:\n    succ' = add one\n    succ' three\n\n    ; Multiplication of m by n is applying m times a function that applies s n times:\n    mult = Î»m.Î»n.Î»s.m (n s)\n    mult three three\n    ; ...or applying m times the addition of n to zero:\n    mult' = Î»m.Î»n.m (add n) zero\n    mult' three three\n\n    ; Exponentiation n^m has a simple encoding: applying the base m to the exponent n,\n    ; which can be understood as applying m successively n times:\n    exp = Î»m.Î»n.n m\n    exp two three\n    ; ...or, alternatively, applying m times the multiplication by n to one:\n    exp' = Î»m.Î»n.m (mult n) one\n    exp' two three\n\n    ; The encoding for the predecessor function is quite complex.\n    ; The Wikipedia article on Church encoding has a good explanation for this term ;-)\n    pred = Î»n.Î»s.Î»z.n (Î»f.Î»g.g (f s)) (Î»x.z) (Î»x.x)\n    pred three\n\n    ; But given the predecessor function is then easy to define the subtraction:\n    sub = Î»m.Î»n.n pred m\n    sub three two\n\n    ; To build some predicate functions, we'll use some known boolean terms (see\n    ; Booleans example for more info):\n    true = Î»t.Î»f.t\n    false = Î»t.Î»f.f\n    and = Î»p.Î»q.p q p\n\n    ; To know if a number n is zero we can pass true as the base value and a function\n    ; that always returns false (note that the "?" is no special syntax; it's just\n    ; part of the name of the predicate):\n    zero? = Î»n.n (Î»x.false) true\n    zero? zero\n    zero? two\n\n    ; To know if a number is less or equal to another number, we can subtract them and\n    ; see if the result is zero:\n    leq = Î»m.Î»n.zero? (sub m n)\n\n    ; And given that predicate, numeric equality between m and n can be defined as:\n    eq = Î»m.Î»n.and (leq m n) (leq n m)\n\n    ; Throwing everything into the mix, we can prove that 2Â³ = 3Â² - 1:\n    eq (exp two three) (pred (exp three two))\n  `)},{name:"Factorial",code:(0,utils_1.dedent)(`\n    ; Factorial function and recursion\n\n    ; Note: for this example we'll use boolean and numeric terms from previous\n    ; examples (see below).\n    ; Also not that these factorial definitions won't work with applicative order ;)\n\n    ; We'd like to be able to define a factorial function as:\n    ; fact = Î»n.if (zero? n) one (mult n (fact (pred n)))\n    ; But we can't use a term in its own definition.\n    ; To achieve recursion, we can instead define a function that will receive itself\n    ; as a parameter r, and then recur by calling r with itself and n - 1:\n    fact-rec = Î»r.Î»n.if (zero? n) one (mult n (r r (pred n)))\n    ; The real factorial function would then be:\n    fact = fact-rec fact-rec\n    fact four\n\n    ; Another way to recur is to use a general purpose fixed-point combinator.\n    ; Behold, the almighty Y Combinator:\n    Y = Î»f.(Î»x.f (x x)) (Î»x.f (x x))\n    ; And then there's no need to define a separate function:\n    fact2 = Y Î»r.Î»n.if (zero? n) one (mult n (r (pred n)))\n    fact2 four\n\n    ; A different way of computing the factorial of n is to use the number n itself\n    ; as a function that will call a given function n times, starting with a given value.\n    ; The function given will take a pair [a, b] and return a new pair [a-1, a*b], and start with [n, 1].\n    ; After applying this given function n times, the resulting pair will be [0, factorial(n)],\n    ; of which we take the 2nd component.\n    ; This way of defining factorial requires much fewer reduction steps.\n    fact3 = Î»n.2nd (n (Î»p.pair (pred (1st p)) (mult (1st p) (2nd p))) (pair n one))\n    fact3 four\n\n    ; Yet another way of defining factorial is as the successive multiplication of the numbers n...1,\n    ; which results in this very elegant solution:\n    fact4 = Î»n.reduce mult (iota n) one\n    fact4 four\n\n    ; Pair-handling functions:\n    pair = Î»x.Î»y.Î»f.f x y\n    1st = Î»p.p (Î»x.Î»y.x)\n    2nd = Î»p.p (Î»x.Î»y.y)\n\n    ; List-handling functions. Lists can be considered functions handling a nil (empty) case\n    ; and a cons (head+tail) case:\n    nil = Î»n.Î»c.n\n    cons = Î»h.Î»t.Î»n.Î»c.c h t\n    reduce = Y Î»r.Î»f.Î»list.Î»initial.list initial (Î»h.Î»t.f h (r f t initial))\n    ; For a given number n, iota produces the list of numbers 1, 2, ..., n\n    iota = Î»n.n (Î»list.list (cons n nil) (Î»h.Î»t.cons (pred h) list)) nil\n\n    ; Borrow some terms from previous examples:\n    true = Î»t.Î»f.t\n    false = Î»t.Î»f.f\n    if = Î»p.p\n    zero = Î»s.Î»z.z\n    one = Î»s.Î»z.s z\n    two = Î»s.Î»z.s (s z)\n    three = Î»s.Î»z.s (s (s z))\n    four = Î»s.Î»z.s (s (s (s z)))\n    succ = Î»n.Î»s.Î»z.s (n s z)\n    pred = Î»n.Î»s.Î»z.n (Î»f.Î»g.g (f s)) (Î»x.z) (Î»x.x)\n    mult = Î»m.Î»n.Î»s.m (n s)\n    zero? = Î»n.n (Î»x.false) true\n  `)},{name:"Extras",code:(0,utils_1.dedent)(`\n    ; Syntactic Trivia and Miscellaneous\n\n    ; Identifiers can contain basically any character (except the few ones reserved for\n    ; syntax: "Î»", ".", "=", "(" and ")").\n    ; This means you can write some pretty code-looking lambda terms!\n    0 = Î»s.Î»z.z\n    1 = Î»s.Î»z.s z\n    2 = Î»s.Î»z.s (s z)\n    + = Î»m.Î»n.Î»s.Î»z.m s (n s z)\n    * = Î»m.Î»n.Î»s.m (n s)\n    (+ (* 2 1) 0)\n    ; Reinventing (a part of) Lisp is always fun...\n\n    ; You can even use emojis as identifiers! But make sure to use this power responsibly.\n    (Î»ðŸ´.â“) ðŸŽ\n\n    ; Although line breaks usually act as separators between terms/definitions,\n    ; you can use parentheses to split a complex term into multiple lines:\n    fib = Y Î»f.Î»n.(\n      if (â‰¤ n 1)\n         n\n         (+ (f (- n 1))\n            (f (- n 2))))\n    fib 0\n    fib 1\n    fib 2\n    fib 7\n\n    ; The rest of the definitions to make the above code work. Not much to see here...\n    Y = Î»f.(Î»x.f (x x)) (Î»x.f (x x))\n    - = Î»m.Î»n.n pred m\n    â‰¤ = Î»m.Î»n.zero? (- m n)\n    pred = Î»n.Î»s.Î»z.n (Î»f.Î»g.g (f s)) (Î»x.z) (Î»x.x)\n    zero? = Î»n.n (Î»x.false) true\n    true = Î»t.Î»f.t\n    false = Î»t.Î»f.f\n    if = Î»p.p\n    7 = Î»s.Î»z.s (s (s (s (s (s (s z))))))\n    13 = Î»s.Î»z.s (s (s (s (s (s (s (s (s (s (s (s (s z))))))))))))\n    â“ = Î»ðŸ’©.ðŸ’© ðŸ’© ðŸ’©\n  `)}];exports.default=examples},{"./utils":15}],4:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});const substitute_1=require("./substitute");const terms_1=require("./terms");const alphaEq=(t1,t2)=>{if(t1.type==="def"){return alphaEq(t1.term,t2)}if(t2.type==="def"){return alphaEq(t1,t2.term)}if(t1.type==="var"&&t2.type==="var"){return t1.name===t2.name}if(t1.type==="app"&&t2.type==="app"){return alphaEq(t1.left,t2.left)&&alphaEq(t1.right,t2.right)}if(t1.type==="fun"&&t2.type==="fun"){if(t1.param===t2.param){return alphaEq(t1.body,t2.body)}else{return alphaEq(t1.body,(0,substitute_1.substitute)(t2.body,t2.param,(0,terms_1.Var)(t1.param)))}}return false};exports.default=alphaEq},{"./substitute":13,"./terms":14}],5:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});const utils_1=require("../utils");const format=(t,appParens=false,funParens=false)=>{const{highlight:h=utils_1.identity,highlightVar:highlightVar}=t;switch(t.type){case"var":case"def":return h(t.name);case"fun":let lambda=`Î»${t.param}`;if(highlightVar){lambda=highlightVar(lambda)}const funStr=`${lambda}.${format(t.body)}`;return h(funParens?`(${funStr})`:funStr);case"app":const lStr=format(t.left,false,true);const rStr=format(t.right,true,funParens);const appStr=`${lStr} ${rStr}`;return h(appParens?`(${appStr})`:appStr)}};exports.default=format},{"../utils":15}],6:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});const freeIn=(x,t)=>{switch(t.type){case"var":return t.name===x;case"fun":return t.param!==x&&freeIn(x,t.body);case"app":return freeIn(x,t.left)||freeIn(x,t.right);case"def":return false}};exports.default=freeIn},{}],7:[function(require,module,exports){var grammar=function(){var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[5,7],$V1=[1,6],$V2=[1,7],$V3=[1,8],$V4=[2,10],$V5=[5,7,11,13,14,15];var parser={trace:function trace(){},yy:{},symbols_:{error:2,root:3,program:4,EOF:5,line:6,SEPARATOR:7,term:8,ident:9,"=":10,LAMBDA:11,".":12,"(":13,")":14,IDENT:15,$accept:0,$end:1},terminals_:{2:"error",5:"EOF",7:"SEPARATOR",10:"=",11:"LAMBDA",12:".",13:"(",14:")",15:"IDENT"},productions_:[0,[3,2],[4,0],[4,1],[4,2],[4,3],[6,1],[6,3],[8,4],[8,2],[8,1],[8,3],[9,1]],performAction:function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$){var $0=$$.length-1;switch(yystate){case 1:break;case 6:this.$=yy.parseTopLevelTerm($$[$0]);break;case 7:this.$=yy.parseDefinition($$[$0-2],$$[$0]);break;case 8:this.$=yy.parseFunction($$[$0-2],$$[$0]);break;case 9:this.$=yy.parseApplication($$[$0-1],$$[$0]);break;case 10:this.$=yy.parseIdentifier($$[$0]);break;case 11:this.$=$$[$0-1];break;case 12:this.$=yytext;break}},table:[o($V0,[2,2],{3:1,4:2,6:3,8:4,9:5,11:$V1,13:$V2,15:$V3}),{1:[3]},{5:[1,9],7:[1,10]},o($V0,[2,3]),o($V0,[2,6],{8:11,9:12,11:$V1,13:$V2,15:$V3}),o([5,7,11,13,15],$V4,{10:[1,13]}),{9:14,15:$V3},{8:15,9:12,11:$V1,13:$V2,15:$V3},o([5,7,10,11,12,13,14,15],[2,12]),{1:[2,1]},o($V0,[2,4],{8:4,9:5,6:16,11:$V1,13:$V2,15:$V3}),o($V5,[2,9],{8:11,9:12}),o($V5,$V4),{8:17,9:12,11:$V1,13:$V2,15:$V3},{12:[1,18]},{8:11,9:12,11:$V1,13:$V2,14:[1,19],15:$V3},o($V0,[2,5]),o($V0,[2,7],{8:11,9:12,11:$V1,13:$V2,15:$V3}),{8:20,9:12,11:$V1,13:$V2,15:$V3},o($V5,[2,11]),o([5,7,14],[2,8],{8:11,9:12,11:$V1,13:$V2,15:$V3})],defaultActions:{9:[2,1]},parseError:function parseError(str,hash){if(hash.recoverable){this.trace(str)}else{var error=new Error(str);error.hash=hash;throw error}},parse:function parse(input){var self=this,stack=[0],tstack=[],vstack=[null],lstack=[],table=this.table,yytext="",yylineno=0,yyleng=0,recovering=0,TERROR=2,EOF=1;var args=lstack.slice.call(arguments,1);var lexer=Object.create(this.lexer);var sharedState={yy:{}};for(var k in this.yy){if(Object.prototype.hasOwnProperty.call(this.yy,k)){sharedState.yy[k]=this.yy[k]}}lexer.setInput(input,sharedState.yy);sharedState.yy.lexer=lexer;sharedState.yy.parser=this;if(typeof lexer.yylloc=="undefined"){lexer.yylloc={}}var yyloc=lexer.yylloc;lstack.push(yyloc);var ranges=lexer.options&&lexer.options.ranges;if(typeof sharedState.yy.parseError==="function"){this.parseError=sharedState.yy.parseError}else{this.parseError=Object.getPrototypeOf(this).parseError}function popStack(n){stack.length=stack.length-2*n;vstack.length=vstack.length-n;lstack.length=lstack.length-n}_token_stack:var lex=function(){var token;token=lexer.lex()||EOF;if(typeof token!=="number"){token=self.symbols_[token]||token}return token};var symbol,preErrorSymbol,state,action,a,r,yyval={},p,len,newState,expected;while(true){state=stack[stack.length-1];if(this.defaultActions[state]){action=this.defaultActions[state]}else{if(symbol===null||typeof symbol=="undefined"){symbol=lex()}action=table[state]&&table[state][symbol]}if(typeof action==="undefined"||!action.length||!action[0]){var errStr="";expected=[];for(p in table[state]){if(this.terminals_[p]&&p>TERROR){expected.push("'"+this.terminals_[p]+"'")}}if(lexer.showPosition){errStr="Parse error on line "+(yylineno+1)+":\n"+lexer.showPosition()+"\nExpecting "+expected.join(", ")+", got '"+(this.terminals_[symbol]||symbol)+"'"}else{errStr="Parse error on line "+(yylineno+1)+": Unexpected "+(symbol==EOF?"end of input":"'"+(this.terminals_[symbol]||symbol)+"'")}this.parseError(errStr,{text:lexer.match,token:this.terminals_[symbol]||symbol,line:lexer.yylineno,loc:yyloc,expected:expected})}if(action[0]instanceof Array&&action.length>1){throw new Error("Parse Error: multiple actions possible at state: "+state+", token: "+symbol)}switch(action[0]){case 1:stack.push(symbol);vstack.push(lexer.yytext);lstack.push(lexer.yylloc);stack.push(action[1]);symbol=null;if(!preErrorSymbol){yyleng=lexer.yyleng;yytext=lexer.yytext;yylineno=lexer.yylineno;yyloc=lexer.yylloc;if(recovering>0){recovering--}}else{symbol=preErrorSymbol;preErrorSymbol=null}break;case 2:len=this.productions_[action[1]][1];yyval.$=vstack[vstack.length-len];yyval._$={first_line:lstack[lstack.length-(len||1)].first_line,last_line:lstack[lstack.length-1].last_line,first_column:lstack[lstack.length-(len||1)].first_column,last_column:lstack[lstack.length-1].last_column};if(ranges){yyval._$.range=[lstack[lstack.length-(len||1)].range[0],lstack[lstack.length-1].range[1]]}r=this.performAction.apply(yyval,[yytext,yyleng,yylineno,sharedState.yy,action[1],vstack,lstack].concat(args));if(typeof r!=="undefined"){return r}if(len){stack=stack.slice(0,-1*len*2);vstack=vstack.slice(0,-1*len);lstack=lstack.slice(0,-1*len)}stack.push(this.productions_[action[1]][0]);vstack.push(yyval.$);lstack.push(yyval._$);newState=table[stack[stack.length-2]][stack[stack.length-1]];stack.push(newState);break;case 3:return true}}return true}};var lexer=function(){var lexer={EOF:1,parseError:function parseError(str,hash){if(this.yy.parser){this.yy.parser.parseError(str,hash)}else{throw new Error(str)}},setInput:function(input,yy){this.yy=yy||this.yy||{};this._input=input;this._more=this._backtrack=this.done=false;this.yylineno=this.yyleng=0;this.yytext=this.matched=this.match="";this.conditionStack=["INITIAL"];this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0};if(this.options.ranges){this.yylloc.range=[0,0]}this.offset=0;return this},input:function(){var ch=this._input[0];this.yytext+=ch;this.yyleng++;this.offset++;this.match+=ch;this.matched+=ch;var lines=ch.match(/(?:\r\n?|\n).*/g);if(lines){this.yylineno++;this.yylloc.last_line++}else{this.yylloc.last_column++}if(this.options.ranges){this.yylloc.range[1]++}this._input=this._input.slice(1);return ch},unput:function(ch){var len=ch.length;var lines=ch.split(/(?:\r\n?|\n)/g);this._input=ch+this._input;this.yytext=this.yytext.substr(0,this.yytext.length-len);this.offset-=len;var oldLines=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1);this.matched=this.matched.substr(0,this.matched.length-1);if(lines.length-1){this.yylineno-=lines.length-1}var r=this.yylloc.range;this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:lines?(lines.length===oldLines.length?this.yylloc.first_column:0)+oldLines[oldLines.length-lines.length].length-lines[0].length:this.yylloc.first_column-len};if(this.options.ranges){this.yylloc.range=[r[0],r[0]+this.yyleng-len]}this.yyleng=this.yytext.length;return this},more:function(){this._more=true;return this},reject:function(){if(this.options.backtrack_lexer){this._backtrack=true}else{return this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})}return this},less:function(n){this.unput(this.match.slice(n))},pastInput:function(){var past=this.matched.substr(0,this.matched.length-this.match.length);return(past.length>20?"...":"")+past.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var next=this.match;if(next.length<20){next+=this._input.substr(0,20-next.length)}return(next.substr(0,20)+(next.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var pre=this.pastInput();var c=new Array(pre.length+1).join("-");return pre+this.upcomingInput()+"\n"+c+"^"},test_match:function(match,indexed_rule){var token,lines,backup;if(this.options.backtrack_lexer){backup={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done};if(this.options.ranges){backup.yylloc.range=this.yylloc.range.slice(0)}}lines=match[0].match(/(?:\r\n?|\n).*/g);if(lines){this.yylineno+=lines.length}this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:lines?lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+match[0].length};this.yytext+=match[0];this.match+=match[0];this.matches=match;this.yyleng=this.yytext.length;if(this.options.ranges){this.yylloc.range=[this.offset,this.offset+=this.yyleng]}this._more=false;this._backtrack=false;this._input=this._input.slice(match[0].length);this.matched+=match[0];token=this.performAction.call(this,this.yy,this,indexed_rule,this.conditionStack[this.conditionStack.length-1]);if(this.done&&this._input){this.done=false}if(token){return token}else if(this._backtrack){for(var k in backup){this[k]=backup[k]}return false}return false},next:function(){if(this.done){return this.EOF}if(!this._input){this.done=true}var token,match,tempMatch,index;if(!this._more){this.yytext="";this.match=""}var rules=this._currentRules();for(var i=0;i<rules.length;i++){tempMatch=this._input.match(this.rules[rules[i]]);if(tempMatch&&(!match||tempMatch[0].length>match[0].length)){match=tempMatch;index=i;if(this.options.backtrack_lexer){token=this.test_match(tempMatch,rules[i]);if(token!==false){return token}else if(this._backtrack){match=false;continue}else{return false}}else if(!this.options.flex){break}}}if(match){token=this.test_match(match,rules[index]);if(token!==false){return token}return false}if(this._input===""){return this.EOF}else{return this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})}},lex:function lex(){var r=this.next();if(r){return r}else{return this.lex()}},begin:function begin(condition){this.conditionStack.push(condition)},popState:function popState(){var n=this.conditionStack.length-1;if(n>0){return this.conditionStack.pop()}else{return this.conditionStack[0]}},_currentRules:function _currentRules(){if(this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]){return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules}else{return this.conditions["INITIAL"].rules}},topState:function topState(n){n=this.conditionStack.length-1-Math.abs(n||0);if(n>=0){return this.conditionStack[n]}else{return"INITIAL"}},pushState:function pushState(condition){this.begin(condition)},stateStackSize:function stateStackSize(){return this.conditionStack.length},options:{},performAction:function anonymous(yy,yy_,$avoiding_name_collisions,YY_START){var YYSTATE=YY_START;switch($avoiding_name_collisions){case 0:yy.openParens++;return 13;break;case 1:yy.openParens--;return 14;break;case 2:return 11;break;case 3:return 12;break;case 4:return 10;break;case 5:if(yy.openParens<=0)return 7;break;case 6:break;case 7:break;case 8:return 15;break;case 9:return 5;break}},rules:[/^(?:\()/,/^(?:\))/,/^(?:\\|Î»)/,/^(?:\.)/,/^(?:=)/,/^(?:\n)/,/^(?:[^\S\n]+)/,/^(?:;.*)/,/^(?:[^\s\(\)\\Î»\.=]+)/,/^(?:$)/],conditions:{INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9],inclusive:true}}};return lexer}();parser.lexer=lexer;function Parser(){this.yy={}}Parser.prototype=parser;parser.Parser=Parser;return new Parser}();if(typeof require!=="undefined"&&typeof exports!=="undefined"){exports.parser=grammar;exports.Parser=grammar.Parser;exports.parse=function(){return grammar.parse.apply(grammar,arguments)};exports.main=function commonjsMain(args){if(!args[1]){console.log("Usage: "+args[0]+" FILE");process.exit(1)}var source=require("fs").readFileSync(require("path").normalize(args[1]),"utf8");return exports.parser.parse(source)};if(typeof module!=="undefined"&&require.main===module){exports.main(process.argv.slice(1))}}},{fs:undefined,path:undefined}],8:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.markStep=exports.composeAppR=exports.composeAppL=exports.composeFun=void 0;const terms_1=require("./terms");const composeFun=(fn,x)=>b=>fn((0,terms_1.Fun)(x,b));exports.composeFun=composeFun;const composeAppL=(fn,l)=>r=>fn((0,terms_1.App)(l,r));exports.composeAppL=composeAppL;const composeAppR=(fn,r)=>l=>fn((0,terms_1.App)(l,r));exports.composeAppR=composeAppR;const markStep=step=>({...step.after,step:step});exports.markStep=markStep},{"./terms":14}],9:[function(require,module,exports){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function(){return m[k]}}}Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k]});var __exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)if(p!=="default"&&!Object.prototype.hasOwnProperty.call(exports,p))__createBinding(exports,m,p)};var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:true});exports.reduceProgram=exports.format=exports.parse=void 0;__exportStar(require("./terms"),exports);var parse_1=require("./parse");Object.defineProperty(exports,"parse",{enumerable:true,get:function(){return __importDefault(parse_1).default}});var format_1=require("./format");Object.defineProperty(exports,"format",{enumerable:true,get:function(){return __importDefault(format_1).default}});var reduce_program_1=require("./reduce-program");Object.defineProperty(exports,"reduceProgram",{enumerable:true,get:function(){return reduce_program_1.reduceProgram}})},{"./format":5,"./parse":10,"./reduce-program":11,"./terms":14}],10:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});const utils_1=require("../utils");const grammar_1=require("./grammar");const terms_1=require("./terms");const parse=(0,utils_1.timed)("parse",(str=>{const parser=new grammar_1.Parser;const defs={};const terms=[];parser.yy={openParens:0,parseFunction:terms_1.Fun,parseApplication:terms_1.App,parseDefinition:(name,term)=>{if(defs[name]){throw Error(`${name} already defined`)}defs[name]=term},parseTopLevelTerm:term=>{terms.push(term)},parseIdentifier:name=>({type:"ref",name:name})};parser.parse(str);terms.forEach((t=>resolveTermRefs(t,defs)));const refNames={};Object.keys(defs).forEach((name=>{resolveDefRefs(name,defs[name],defs,refNames)}));return{defs:defs,terms:terms}}));exports.default=parse;const resolveTermRefs=(t,defs,boundNames=[])=>{switch(t.type){case"ref":const free=boundNames.indexOf(t.name)<0;if(t.name in defs&&free){Object.assign(t,{type:"def",term:defs[t.name]})}else{Object.assign(t,{type:"var"})}break;case"app":resolveTermRefs(t.left,defs,boundNames);resolveTermRefs(t.right,defs,boundNames);break;case"fun":resolveTermRefs(t.body,defs,boundNames.concat(t.param));break}};const resolveDefRefs=(defName,t,defs,refNames,boundNames=[])=>{switch(t.type){case"ref":const bound=boundNames.indexOf(t.name)>=0;if(bound){Object.assign(t,{type:"var"})}else if(t.name in defs){refNames[defName]=[...refNames[defName]||[],t.name];checkForCircularRefs(defName,t.name,refNames);Object.assign(t,{type:"def",term:defs[t.name]})}else{throw Error(`Illegal free variable "${t.name}" in "${defName}". Definitions cannot have free variables.`)}break;case"app":resolveDefRefs(defName,t.left,defs,refNames,boundNames);resolveDefRefs(defName,t.right,defs,refNames,boundNames);break;case"fun":const boundOnBody=boundNames.concat(t.param);resolveDefRefs(defName,t.body,defs,refNames,boundOnBody);break}};const checkForCircularRefs=(name,refName,refNames,path=[])=>{if(name===refName){let message=`Illegal recursive reference in "${name}". Definitions cannot reference themselves, they are just simple find&replace mechanisms.\n`;const refCycle=path.length?[name,...path,name].join(" â†’ "):null;message+=refCycle?`In this case the definition does not reference itself directly, but through other definitions: ${refCycle}.`:'If you want to write a recursive function, search for "Y combinator" ;)';throw Error(message)}const nextRefs=refNames[refName]||[];nextRefs.forEach((nextRef=>checkForCircularRefs(name,nextRef,refNames,[...path,refName])))}},{"../utils":15,"./grammar":7,"./terms":14}],11:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:true});exports.reduceProgram=void 0;const utils_1=require("../utils");const alpha_eq_1=__importDefault(require("./alpha-eq"));const format_1=__importDefault(require("./format"));const parse_1=__importDefault(require("./parse"));const reduce_1=__importDefault(require("./reduce"));const substitute_1=require("./substitute");const terms_1=require("./terms");const reduceProgram=(program,options={})=>{const{terms:terms,defs:defs}=(0,parse_1.default)(program);return terms.map((term=>reduceTerm(term,defs,options)))};exports.reduceProgram=reduceProgram;let reduceTerm=(term,defs,{maxReductionSteps:maxReductionSteps=100,strategy:strategy="normal",etaEnabled:etaEnabled=false})=>{const enough={};const steps=[];let reductionSteps=0;let terminates=false;try{(0,reduce_1.default)(term,{strategy:strategy,etaEnabled:etaEnabled},(stepTerm=>{if(reductionSteps>=maxReductionSteps){throw enough}steps.push(stepTerm);const step=findStep(stepTerm);if(!step){throw new Error("Unexpected: term should always have a step")}if(step.type==="beta"||step.type==="eta"){reductionSteps+=1}}));terminates=true}catch(e){if(e!==enough){throw e}terminates=false}const last=steps[steps.length-1]||term;return{initial:(0,format_1.default)(term),final:(0,format_1.default)(last),finalSynonyms:findSynonyms(last,defs),terminates:terminates,reductionSteps:reductionSteps,totalSteps:steps.length,renderStep:(i,options)=>expandStep(steps[i],options)}};reduceTerm=(0,utils_1.timed)("reduce",reduceTerm);const expandStep=(t,options={})=>{const step=findStep(t);if(!step){throw new Error("Unexpected: term should always have a step")}let before=step.before;let after=step.after;const{highlightFormerTerm:highlightFormerTerm=utils_1.identity,highlightSubstitutionTerm:highlightSubstitutionTerm=utils_1.identity,highlightStep:highlightStep=utils_1.identity}=options;switch(step.type){case"alpha":before=highlightFunctionVar(step.before.body,step.before.param,highlightFormerTerm);after=highlightFunctionVar(step.after.body,step.after.param,highlightSubstitutionTerm);break;case"beta":const fun=step.before.left;const hs=highlight(step.before.right,highlightSubstitutionTerm);const ha=highlightFunctionVar(fun.body,fun.param,highlightFormerTerm);before=(0,terms_1.App)(ha,hs);after=(0,substitute_1.substitute)(fun.body,fun.param,hs);break;case"eta":case"def":before=highlight(step.before,highlightFormerTerm);after=highlight(step.after,highlightSubstitutionTerm);break}before=highlight(before,highlightStep);after=highlight(after,highlightStep);const beforeStr=(0,format_1.default)(replaceStep(t,before));const afterStr=(0,format_1.default)(replaceStep(t,after));return{type:step.type,before:beforeStr,after:afterStr}};const highlight=(t,fn)=>{const h=t.highlight;const highlight=h?s=>fn(h(s)):fn;return{...t,highlight:highlight}};const highlightFunctionVar=(t,x,fn)=>{const hx=highlight((0,terms_1.Var)(x),fn);const ht=(0,substitute_1.substitute)(t,x,hx);return{...(0,terms_1.Fun)(x,ht),highlightVar:fn}};const findStep=t=>{if("step"in t){return t.step}switch(t.type){case"fun":return findStep(t.body);case"app":return findStep(t.left)||findStep(t.right)}};const replaceStep=(t,replacement)=>{if("step"in t&&t.step){return replacement}switch(t.type){case"var":case"def":return t;case"fun":const body=replaceStep(t.body,replacement);return t.body===body?t:(0,terms_1.Fun)(t.param,body);case"app":const l=replaceStep(t.left,replacement);if(t.left!==l){return(0,terms_1.App)(l,t.right)}const r=replaceStep(t.right,replacement);return t.right===r?t:(0,terms_1.App)(l,r)}};const findSynonyms=(term,defs)=>{const synonyms=[];for(const name in defs){if((0,alpha_eq_1.default)(term,defs[name])){synonyms.push(name)}}return synonyms}},{"../utils":15,"./alpha-eq":4,"./format":5,"./parse":10,"./reduce":12,"./substitute":13,"./terms":14}],12:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:true});const free_in_1=__importDefault(require("./free-in"));const helpers_1=require("./helpers");const substitute_1=require("./substitute");const terms_1=require("./terms");const reduce=(t,{strategy:strategy,etaEnabled:etaEnabled},cb)=>{const reducer=reduceFunctions[strategy];let reduced=reducer(t,cb);if(etaEnabled){reduced=reduceEta(reduced,cb)}return reduced};exports.default=reduce;const reduceCallByName=(t,cb)=>{switch(t.type){case"var":case"fun":return t;case"app":const l=reduceCallByName(t.left,(0,helpers_1.composeAppR)(cb,t.right));return l.type==="fun"?reduceCallByName(apply(l,t.right,cb),cb):(0,terms_1.App)(l,t.right);case"def":return reduceCallByName(resolveDefinition(t,cb),cb)}};const reduceNormal=(t,cb)=>{switch(t.type){case"var":return t;case"fun":return(0,terms_1.Fun)(t.param,reduceNormal(t.body,(0,helpers_1.composeFun)(cb,t.param)));case"app":let l=reduceCallByName(t.left,(0,helpers_1.composeAppR)(cb,t.right));if(l.type==="fun"){return reduceNormal(apply(l,t.right,cb),cb)}else{l=reduceNormal(l,(0,helpers_1.composeAppR)(cb,t.right));const r=reduceNormal(t.right,(0,helpers_1.composeAppL)(cb,l));return(0,terms_1.App)(l,r)}case"def":return reduceNormal(resolveDefinition(t,cb),cb)}};const reduceCallByValue=(t,cb)=>{switch(t.type){case"var":case"fun":return t;case"app":const l=reduceCallByValue(t.left,(0,helpers_1.composeAppR)(cb,t.right));const r=reduceCallByValue(t.right,(0,helpers_1.composeAppL)(cb,l));return l.type==="fun"?reduceCallByValue(apply(l,r,cb),cb):(0,terms_1.App)(l,r);case"def":return reduceCallByValue(resolveDefinition(t,cb),cb)}};const reduceApplicative=(t,cb)=>{switch(t.type){case"var":return t;case"fun":return(0,terms_1.Fun)(t.param,reduceApplicative(t.body,(0,helpers_1.composeFun)(cb,t.param)));case"app":let l=reduceCallByValue(t.left,(0,helpers_1.composeAppR)(cb,t.right));if(l.type==="fun"){const r=reduceCallByValue(t.right,(0,helpers_1.composeAppL)(cb,l));return reduceApplicative(apply(l,r,cb),cb)}else{l=reduceApplicative(l,(0,helpers_1.composeAppR)(cb,t.right));const r=reduceApplicative(t.right,(0,helpers_1.composeAppL)(cb,l));return(0,terms_1.App)(l,r)}case"def":return reduceApplicative(resolveDefinition(t,cb),cb)}};const apply=(fun,subst,cb)=>{const renameCb=(0,helpers_1.composeFun)((0,helpers_1.composeAppR)(cb,subst),fun.param);const renamedBody=(0,substitute_1.renameForSubstitution)(fun.body,fun.param,subst,renameCb);const renamed=(0,terms_1.App)((0,terms_1.Fun)(fun.param,renamedBody),subst);const applied=(0,substitute_1.applySubstitution)(renamedBody,fun.param,subst);cb((0,helpers_1.markStep)({type:"beta",before:renamed,after:applied}));return applied};const reduceEta=(t,cb)=>{switch(t.type){case"var":return t;case"fun":const body=reduceEta(t.body,(0,helpers_1.composeFun)(cb,t.param));const before=body===t.body?t:(0,terms_1.Fun)(t.param,body);if(body.type==="app"&&body.right.type==="var"&&body.right.name===t.param&&!(0,free_in_1.default)(t.param,body.left)){cb((0,helpers_1.markStep)({type:"eta",before:before,after:body.left}));return body.left}else{return before}case"app":const l=reduceEta(t.left,(0,helpers_1.composeAppR)(cb,t.right));const r=reduceEta(t.right,(0,helpers_1.composeAppL)(cb,l));return(0,terms_1.App)(l,r);case"def":return t}};const reduceFunctions={normal:reduceNormal,applicative:reduceApplicative,cbn:reduceCallByName,cbv:reduceCallByValue};const resolveDefinition=(def,cb)=>{let after=def.term;while(after.type==="def"){after=after.term}cb((0,helpers_1.markStep)({type:"def",before:def,after:after}));return after}},{"./free-in":6,"./helpers":8,"./substitute":13,"./terms":14}],13:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:true});exports.applySubstitution=exports.renameForSubstitution=exports.substitute=void 0;const free_in_1=__importDefault(require("./free-in"));const helpers_1=require("./helpers");const terms_1=require("./terms");const substitute=(t,x,s)=>{switch(t.type){case"var":return t.name===x?s:t;case"fun":if(t.param===x){return t}if((0,free_in_1.default)(t.param,s)&&(0,free_in_1.default)(x,t.body)){const newVarName=renameVar(t.param,t.body,s);const renamedBody=(0,exports.applySubstitution)(t.body,t.param,(0,terms_1.Var)(newVarName));return(0,terms_1.Fun)(newVarName,(0,exports.substitute)(renamedBody,x,s))}else{return(0,terms_1.Fun)(t.param,(0,exports.substitute)(t.body,x,s))}case"app":return(0,terms_1.App)((0,exports.substitute)(t.left,x,s),(0,exports.substitute)(t.right,x,s));case"def":return t}};exports.substitute=substitute;const renameForSubstitution=(t,x,s,cb)=>{switch(t.type){case"var":case"def":return t;case"fun":if(t.param===x){return t}if((0,free_in_1.default)(t.param,s)&&(0,free_in_1.default)(x,t.body)){const newVarName=renameVar(t.param,t.body,s);const renamedBody=(0,exports.applySubstitution)(t.body,t.param,(0,terms_1.Var)(newVarName));const renamedFun=(0,terms_1.Fun)(newVarName,renamedBody);cb((0,helpers_1.markStep)({type:"alpha",before:t,after:renamedFun}));t=renamedFun}const body=(0,exports.renameForSubstitution)(t.body,x,s,(0,helpers_1.composeFun)(cb,t.param));return(0,terms_1.Fun)(t.param,body);case"app":const l=(0,exports.renameForSubstitution)(t.left,x,s,(0,helpers_1.composeAppR)(cb,t.right));const r=(0,exports.renameForSubstitution)(t.right,x,s,(0,helpers_1.composeAppL)(cb,l));return(0,terms_1.App)(l,r)}};exports.renameForSubstitution=renameForSubstitution;const applySubstitution=(t,x,s)=>{switch(t.type){case"var":return t.name===x?s:t;case"fun":return t.param===x?t:(0,terms_1.Fun)(t.param,(0,exports.applySubstitution)(t.body,x,s));case"app":const l=(0,exports.applySubstitution)(t.left,x,s);const r=(0,exports.applySubstitution)(t.right,x,s);return(0,terms_1.App)(l,r);case"def":return t}};exports.applySubstitution=applySubstitution;const renameVar=(oldName,t,s)=>{const base=oldName.replace(/\d+$/,"");const match=oldName.match(/\d+$/);let n=match?parseInt(match[0],10):0;while(true){n++;const newName=base+n;const isValid=!(0,free_in_1.default)(newName,s)&&!(0,free_in_1.default)(newName,t)&&!varRenameCollides(t,oldName,newName);if(isValid){return newName}}};const varRenameCollides=(t,oldName,newName)=>{switch(t.type){case"var":case"def":return false;case"fun":return t.param===newName&&(0,free_in_1.default)(oldName,t)||varRenameCollides(t.body,oldName,newName);case"app":return varRenameCollides(t.left,oldName,newName)||varRenameCollides(t.right,oldName,newName)}}},{"./free-in":6,"./helpers":8,"./terms":14}],14:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Def=exports.App=exports.Fun=exports.Var=void 0;const Var=name=>({type:"var",name:name});exports.Var=Var;const Fun=(param,body)=>({type:"fun",param:param,body:body});exports.Fun=Fun;const App=(left,right)=>({type:"app",left:left,right:right});exports.App=App;const Def=(name,term)=>({type:"def",name:name,term:term});exports.Def=Def},{}],15:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.dedent=exports.identity=exports.disableLogTimings=exports.enableLogTimings=exports.timed=void 0;let logTimings=false;const timed=(name,fn)=>(...args)=>{if(logTimings){console.time(name)}const res=fn(...args);if(logTimings){console.timeEnd(name)}return res};exports.timed=timed;const enableLogTimings=()=>{logTimings=true};exports.enableLogTimings=enableLogTimings;const disableLogTimings=()=>{logTimings=false};exports.disableLogTimings=disableLogTimings;const identity=x=>x;exports.identity=identity;const dedent=str=>{const match=str.match(/^[ \t]*(?=\S)/gm);if(!match){return str}const indent=Math.min(...match.map((x=>x.length)));const re=new RegExp(`^[ \\t]{${indent}}`,"gm");const unindented=indent>0?str.replace(re,""):str;return unindented.trim()};exports.dedent=dedent},{}]},{},[1]);
//# sourceMappingURL=index.js.map