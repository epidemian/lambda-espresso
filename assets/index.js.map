{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/app.js","src/examples.js","src/lambda/alpha-eq.js","src/lambda/format.js","src/lambda/free-in.js","src/lambda/grammar.js","src/lambda/helpers.js","src/lambda/index.js","src/lambda/parse.js","src/lambda/reduce-program.js","src/lambda/reduce.js","src/lambda/substitute.js","src/lambda/terms.js","src/utils.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","ref","reduceProgram","examples","ref$1","timed","enableLogTimings","dedent","$","document","querySelector","bind","Node","prototype","on","addEventListener","delegate","eventType","selector","handler","this","event","element","target","matches","parentNode","once","onceListener","removeEventListener","index","Array","indexOf","childNodes","input","output","keyCode","ctrlKey","run","value","replace","start","selectionStart","end","selectionEnd","_","renderTerm","term","className","renderArrow","symbol","label","renderArrowByType","type","arrowSymbols","alpha","beta","eta","renderSynonyms","synonyms","join","getOptions","maxSteps","parseInt","strategy","etaEnabled","checked","reductions","renderReductions","err","textContent","message","classList","add","html","map","renderCollapsedReduction","innerHTML","remove","reduction","totalSteps","expanded","collapsed","toggle","renderExpandedReductionForm","prev","previousElementSibling","renderCollapsedReductionForm","initial","arrow","final","finalSynonyms","steps","step","renderStep","renderStepOptions","before","after","lastStep","push","highlightStep","str","highlightFormerTerm","highlightSubstitutionTerm","focus","examplesMenu","examplesHtml","example","hash","preventDefault","scrollTop","examplesDropdown","contains","stopPropagation","location","updateInputFromHash","decodeURI","codeStart","slice","window","name","Var","Fun","App","Def","substitute","alphaEq","t1","t2","param","body","left","right","identity","format","appParens","funParens","h","highlight","lambda","highlightVar","funStr","lStr","rStr","appStr","freeIn","x","grammar","k","v","$V0","$V1","$V2","$V3","$V4","$V5","parser","trace","yy","symbols_","error","root","program","EOF","line","SEPARATOR","ident","=","LAMBDA",".","(",")","IDENT","$accept","$end","terminals_","2","5","7","10","11","12","13","14","15","productions_","performAction","anonymous","yytext","yyleng","yylineno","yystate","$$","_$","$0","parseTopLevelTerm","parseDefinition","parseFunction","parseApplication","parseIdentifier","table","3","4","6","8","9","defaultActions","parseError","recoverable","_parseError","msg","parse","self","stack","tstack","vstack","lstack","recovering","TERROR","args","arguments","lexer","Object","create","sharedState","hasOwnProperty","this$1","setInput","yylloc","yyloc","ranges","options","getPrototypeOf","popStack","_token_stack","lex","token","preErrorSymbol","state","action","yyval","p","len","newState","expected","errStr","showPosition","text","match","loc","first_line","last_line","first_column","last_column","range","apply","concat","openParens","_input","_more","_backtrack","done","matched","conditionStack","offset","ch","lines","unput","split","substr","oldLines","more","reject","backtrack_lexer","less","pastInput","past","upcomingInput","next","pre","c","test_match","indexed_rule","backup","tempMatch","rules","_currentRules","flex","begin","condition","popState","pop","conditions","topState","Math","abs","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","YYSTATE","INITIAL","inclusive","Parser","main","commonjsMain","console","log","process","exit","source","readFileSync","normalize","argv","extend","composeFun","fn","b","composeAppL","composeAppR","markStep","collapseWhitespace","ref$2","defs","terms","Ref","forEach","resolveTermRefs","refNames","resolveDefRefs","boundNames","free","defName","bound","checkForCircularRefs","boundOnBody","refName","path","circularNote","nextRefs","nextRef","compose","reduce","reduceTerm","enough","terminates","last","findSynonyms","expandStep","stepTerm","find","subT","highlightFormer","highlightSubst","highlightFunctionVar","fun","hs","ha","hx","ht","from","to","renameForSubstitution","applySubstitution","cb","reduceFunctions","reduced","reduceEta","reduceCallByName","reduceNormal","reduceCallByValue","reduceApplicative","r$1","subst","renameCb","renamedBody","renamed","applied","isEta","normal","applicative","cbn","cbv","newVarName","renameVar","oldName","base","newName","isValid","varRenameCollides","assign","obj","srcs","src","logTimings","time","res","timeEnd","disableLogTimings","g","indent","min","re","RegExp","unindented","trim"],"mappings":"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","sourceRoot":".","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// Script for index.html\nlet {reduceProgram} = require('./lambda')\nlet examples = require('./examples')\nlet {timed, enableLogTimings, dedent} = require('./utils')\n\nenableLogTimings()\n\n// Recreate some of jQuery's interface.\nlet $ = document.querySelector.bind(document)\n\nNode.prototype.on = Node.prototype.addEventListener\n\n// Like jQuery.fn.on(type, selector, handler)\nNode.prototype.delegate = function(eventType, selector, handler) {\n  this.on(eventType, function(event) {\n    let element = event.target\n    // Try to find matching element bubbling up from event target.\n    while (element !== this) {\n      if (element.matches(selector)) {\n        handler.call(element, event)\n        break\n      }\n      element = element.parentNode\n    }\n  })\n}\n\n// Like jQuery.fn.one\nNode.prototype.once = function(eventType, handler) {\n  let onceListener = function(event) {\n    handler.call(this, event)\n    this.removeEventListener(eventType, onceListener)\n  }\n  this.on(eventType, onceListener)\n}\n\nNode.prototype.index = function() {\n  return Array.prototype.indexOf.call(this.parentNode.childNodes, this)\n}\n\nlet input = $('.input')\nlet output = $('.output')\n\n// Run code on ctrl+enter.\ndocument.on('keyup', e => {\n  if (e.keyCode === 13 && e.ctrlKey)\n    run()\n})\n\ninput.on('keyup', () => {\n  // Replace every \"\\\" with \"λ\" while typing.\n  let code = input.value\n  code = code.replace(/\\\\/g, 'λ')\n  // Preserve selection\n  let start = input.selectionStart\n  let end = input.selectionEnd\n  input.value = code\n  input.selectionStart = start\n  input.selectionEnd = end\n})\n\n$('.run').on('click', _ => run())\n\nlet renderTerm = (term, className = '') =>\n  `<span class=\"term ${className}\">${term}</span>`\n\nlet renderArrow = (symbol, label) =>\n  `<span class=arrow>${symbol}<small>${label}</small></span>`\n\nlet renderArrowByType = type => {\n  let symbol = type === 'def' ? '≡' : '→'\n  let label = arrowSymbols[type] || ''\n  return renderArrow(symbol, label)\n}\n\nlet arrowSymbols = {\n  alpha: 'α',\n  beta: 'β',\n  eta: 'η',\n}\n\nlet renderSynonyms = synonyms =>\n  synonyms.length\n    ? `<span class=synonyms>(${synonyms.join(', ')})</span>`\n    : ''\n\nlet getOptions = () => {\n  let maxSteps = parseInt($('input[name=max-steps]').value || 0)\n  let strategy = $('input[name=strategy]:checked').value\n  let etaEnabled = $('[name=eta-reductions]').checked\n  return {maxSteps, strategy, etaEnabled}\n}\n\n\nlet reductions = null\nlet run = () => {\n  let code = input.value\n  try {\n    reductions = reduceProgram(code, getOptions())\n    renderReductions()\n\n  } catch (err) {\n    output.textContent = err.message\n    output.classList.add('error')\n  }\n}\n\nlet renderReductions = timed('render html',  () => {\n  let html = reductions.map(renderCollapsedReduction).join('')\n  output.innerHTML = html\n  output.classList.remove('error')\n})\n\noutput.delegate('click', '.reduction', function() {\n  let reduction = reductions[this.index()]\n  if (reduction.totalSteps === 0) return\n  let expanded = this.querySelector('.expanded')\n  let collapsed = this.querySelector('.collapsed')\n  if (expanded) {\n    expanded.classList.toggle('hidden')\n    collapsed.classList.toggle('hidden')\n  } else {\n    collapsed.classList.add('hidden')\n    this.innerHTML += renderExpandedReductionForm(reduction)\n  }\n})\n\noutput.delegate('mouseover', '.expanded .step', function() {\n  this.classList.add('highlight')\n  // Hide the previous step's after term.\n  let prev = this.previousElementSibling\n  prev && prev.querySelector('.after').classList.add('hidden')\n})\n\n\noutput.delegate('mouseout', '.expanded .step', function() {\n  this.classList.remove('highlight')\n  let prev = this.previousElementSibling\n  prev && prev.querySelector('.after').classList.remove('hidden')\n})\n\nlet renderCollapsedReduction = reduction =>\n  `<div class=reduction>${renderCollapsedReductionForm(reduction)}</div>`\n\nlet renderCollapsedReductionForm = reduction => {\n  let initial = renderTerm(reduction.initial)\n  let arrow = ''\n  let final = ''\n  if (reduction.totalSteps > 0) {\n    arrow = renderArrow('→', `(${reduction.totalSteps})`)\n    final = renderTerm(reduction.final)\n  }\n  let synonyms = renderSynonyms(reduction.finalSynonyms)\n  return `<div class=collapsed>${initial} ${arrow} ${final} ${synonyms}</div>`\n}\n\nlet renderExpandedReductionForm = reduction => {\n  let steps = []\n  for (let i = 0; i < reduction.totalSteps; i++) {\n    let step = reduction.renderStep(i, renderStepOptions)\n    let before = renderTerm(step.before, 'before')\n    let after = renderTerm(step.after, 'after')\n    let arrow = renderArrowByType(step.type)\n    let lastStep = i === reduction.totalSteps - 1\n    let synonyms = lastStep ? renderSynonyms(reduction.finalSynonyms) : ''\n    steps.push(\n      `<span class=step>${before}<br>${arrow} ${after} ${synonyms}</span>`\n    )\n  }\n\n  return `<div class=expanded>${steps.join('')}</div>`\n}\n\nlet renderStepOptions = {\n  highlightStep: str => `<span class=match>${str}</span>`,\n  highlightFormerTerm: str => `<span class=former-term>${str}</span>`,\n  highlightSubstitutionTerm: str => `<span class=subst-term>${str}</span>`,\n}\n\ninput.value = dedent(`\n  ; Write some λ-expressions here and hit Run. Use \"\\\\\" to enter \"λ\" ;)\n  (λx.λy.λz.z y x) a b c\n`)\ninput.focus()\n\nlet examplesMenu = $('.examples-menu')\nlet examplesHtml = examples.map((example, i) => {\n  let hash = `>${example.code}`.replace(/\\n/g, '%0A')\n  return `<li><a href='//${hash}'>${i} - ${example.name}</a></li>`\n})\n\nexamplesMenu.innerHTML = examplesHtml.join('')\nexamplesMenu.delegate('click', 'li', function(e) {\n  e.preventDefault() // Don't change the location.hash\n  input.value = examples[this.index()].code\n  input.scrollTop = 0\n})\n\nlet examplesDropdown = $('.examples-dropdown')\nexamplesDropdown.on('click', e => {\n  if (examplesDropdown.classList.contains('active')) return\n  e.stopPropagation()\n  examplesDropdown.classList.add('active')\n  document.once('click', () => examplesDropdown.classList.remove('active'))\n})\n\n$('button.link').on('click', () => {\n  let code = input.value\n  location.hash = `>${code}`\n})\n\nlet updateInputFromHash = () => {\n  let hash = decodeURI(location.hash)\n  let codeStart = hash.indexOf('>')\n  if (codeStart >= 0)\n    input.value = hash.slice(codeStart + 1)\n}\n\nwindow.addEventListener('hashchange', updateInputFromHash)\nupdateInputFromHash()\n","let {dedent} = require('./utils')\n\n/* eslint-disable max-len */\nmodule.exports = [{\n  name: 'Basics',\n  code: dedent(`\n    ; This example is not intend to be a tutorial nor an introduction to λ Calculus.\n    ; You should check http://en.wikipedia.org/wiki/Lambda_calculus for that :)\n    ; As you can see, these are comments. You can run this example clicking the Run\n    ; button below or pressing Ctrl+Enter.\n    ; So, the three basic types of λ expressions are:\n    ; Variables:\n    x\n    ; Applications:\n    x y\n    ; And lambda abstractions (also known as functions):\n    λx.x\n    ; If the left-side of an application is an abstraction, then a reduction takes place:\n    (λx.x) y\n    ; That little abstraction at the left is the identity, a very simple function that\n    ; just reduces to whatever you apply to it. We can give it a name like so:\n    id = λx.x\n    ; And then just refer it by that name:\n    id a\n    ; You can apply any kind of λ expression to an abstraction, like another function:\n    id λb.c\n    ; Or an application:\n    id (x y)\n    ; Or even the identity function itself:\n    id id\n    ; That means you can apply identity to itself as many times as you want and it'll still\n    ; be identity:\n    id id id id id\n    ; Notice that applications are left-associative, so the line above is equivalent to:\n    ((((id id) id) id) id)\n\n    ; TODO: explain applicative and normal order...\n  `),\n}, {\n  name: 'Booleans',\n  code: dedent(`\n    ; Church booleans\n\n    ; The booleans and their operations can be encoded as the following λ-terms:\n    true = λt.λf.t\n    false = λt.λf.f\n    not = λp.p false true\n    and = λp.λq.p q p\n    or = λp.λq.p p q\n    if = λp.p\n\n    ; Print truth tables for not, and and or:\n    not true\n    not false\n    and false false\n    and false true\n    and true false\n    and true true\n    or false false\n    or false true\n    or true false\n    or true true\n\n    ; Terms can be nested as much as we want:\n    if (not (not true)) (or false (if true true false)) false\n\n    ; There's nothing special about \"operators\", we can treat them as any other value:\n    (if false or and) true false\n  `),\n}, {\n  name: 'Numbers',\n  code: dedent(`\n    ; Church numerals\n\n    ; The first few numbers are:\n    zero = λs.λz.z\n    one = λs.λz.s z\n    two = λs.λz.s (s z)\n    three = λs.λz.s (s (s z))\n    ; In general, any natural number n can be encoded as:\n    ; N = λs.λz.s (s (s ... (s (s z)) ... ))\n    ; with s applied n times.\n\n    ; When we get tired of writing numbers like that, we can define a successor function:\n    succ = λn.λs.λz.s (n s z)\n    succ three\n\n    ; We can think of Church numerals as functions that apply a given function s to a\n    ; given value z a number of times. Zero will apply it 0 times (i.e. it'll give\n    ; us z back untouched) and three will call it 3 times.\n    ; So, we can represent the addition of numbers m and n as first applying n times s to z,\n    ; and then applying m times s to that:\n    add = λm.λn.λs.λz.m s (n s z)\n    add two three\n    ; ...or, more succinctly, as applying n times the successor function on m (or vice versa):\n    add' = λm.λn.n succ m\n    add' two three\n    ; Conversely, we could define the successor function as adding one:\n    succ' = add one\n    succ' three\n\n    ; Multiplication of m by n is applying m times a function that applies s n times:\n    mult = λm.λn.λs.m (n s)\n    mult three three\n    ; ...or applying m times the addition of n to zero:\n    mult' = λm.λn.m (add n) zero\n    mult' three three\n\n    ; Exponentiation n^m has a simple encoding: applying the base m to the exponent n,\n    ; which can be understood as applying m successively n times:\n    exp = λm.λn.n m\n    exp two three\n    ; ...or, alternatively, applying m times the multiplication by n to one:\n    exp' = λm.λn.m (mult n) one\n    exp' two three\n\n    ; The encoding for the predecessor function is quite complex.\n    ; The Wikipedia article on Church encoding has a good explanation for this term ;-)\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    pred three\n\n    ; But given the predecessor function is then easy to define the subtraction:\n    sub = λm.λn.n pred m\n    sub three two\n\n    ; To build some predicate functions, we'll use some known boolean terms (see \n    ; Booleans example for more info):\n    true = λt.λf.t\n    false = λt.λf.f\n    and = λp.λq.p q p\n\n    ; To know if a number n is zero we can pass true as the base value and a function\n    ; that always returns false (note that the \"?\" is no special syntax; it's just \n    ; part of the name of the predicate):\n    zero? = λn.n (λx.false) true\n    zero? zero\n    zero? two\n\n    ; To know if a number is less or equal to another number, we can subtract them and\n    ; see if the result is zero:\n    leq = λm.λn.zero? (sub m n)\n\n    ; And given that predicate, numeric equality between m and n can be defined as:\n    eq = λm.λn.and (leq m n) (leq n m)\n\n    ; Throwing everything into the mix, we can prove that 2³ = 3² - 1:\n    eq (exp two three) (pred (exp three two))\n  `),\n}, {\n  name: 'Factorial',\n  code: dedent(`\n    ; Factorial function and recursion\n\n    ; Note: for this example we'll use boolean and numeric terms from previous \n    ; examples (see below). \n    ; Also not that these factorial definitions won't work with applicative order ;)\n\n    ; We'd like to be able to define a factorial function as:\n    ; fact = λn.if (zero? n) one (mult n (fact (pred n)))\n    ; But we can't use a term in its own definition.\n    ; To achieve recursion, we can instead define a function that will receive itself\n    ; as a parameter r, and then recur by calling r with itself and n - 1:\n    fact-rec = λr.λn.if (zero? n) one (mult n (r r (pred n)))\n    ; The real factorial function would then be:\n    fact = fact-rec fact-rec\n    fact four\n\n    ; Another way to recur is to use a general purpose fixed-point combinator.\n    ; The almighty Y Combinator:\n    Y = λf.(λx.f (x x)) (λx.f (x x))\n    ; And then there's no need to define a separate function:\n    fact' = Y λr.λn.if (zero? n) one (mult n (r (pred n)))\n    fact' four\n\n    ; Borrow some terms from previous examples:\n    true = λt.λf.t\n    false = λt.λf.f\n    if = λp.p\n    zero = λs.λz.z\n    one = λs.λz.s z\n    two = λs.λz.s (s z)\n    three = λs.λz.s (s (s z))\n    four = λs.λz.s (s (s (s z)))\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    mult = λm.λn.λs.m (n s)\n    zero? = λn.n (λx.false) true\n  `),\n}, {\n  name: 'Extras',\n  code: dedent(`\n    ; Syntactic Trivia and Miscellaneous\n  \n    ; Identifiers can contain basically any character (except the few ones reserved for \n    ; syntax: \"λ\", \".\", \"=\", \"(\" and \")\").\n    ; This means you can write some pretty code-looking lambda terms!\n    0 = λs.λz.z\n    1 = λs.λz.s z\n    2 = λs.λz.s (s z)\n    + = λm.λn.λs.λz.m s (n s z)\n    * = λm.λn.λs.m (n s)\n    (+ (* 2 1) 0)\n    ; Reinventing (a part of) Lisp is always fun...\n\n    ; You can even use emojis as identifiers! But make sure to use this power responsibly.\n    (λ🐴.❓) 🍎\n\n    ; Although line breaks usually act as separators between terms/definitions, \n    ; you can use parentheses to split a complex term into multiple lines:\n    fib = Y λf.λn.(\n      if (≤ n 1)\n         n\n         (+ (f (- n 1))\n            (f (- n 2))))\n    fib 0\n    fib 1\n    fib 2\n    fib 7\n\n    ; The rest of the definitions to make the above code work. Not much to see here...\n    Y = λf.(λx.f (x x)) (λx.f (x x))\n    - = λm.λn.n pred m\n    ≤ = λm.λn.zero? (- m n)\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    zero? = λn.n (λx.false) true\n    true = λt.λf.t\n    false = λt.λf.f\n    if = λp.p\n    7 = λs.λz.s (s (s (s (s (s (s z))))))\n    13 = λs.λz.s (s (s (s (s (s (s (s (s (s (s (s (s z))))))))))))\n    ❓ = λ💩.💩 💩 💩\n  `),\n}]\n","let {Var, Fun, App, Def} = require('./terms')\nlet {substitute} = require('./substitute')\n\n// Whether two terms are alpha-equivalent.\nlet alphaEq = (t1, t2) => {\n  if (t1.type === Def) return alphaEq(t1.term, t2)\n  if (t2.type === Def) return alphaEq(t1, t2.term)\n  if (t1.type !== t2.type) return false\n  switch (t1.type) {\n  case Var:\n    return t1.name === t2.name\n  case Fun:\n    if (t1.param === t2.param)\n      return alphaEq(t1.body, t2.body)\n    else\n      return alphaEq(t1.body, substitute(t2.body, t2.param, Var(t1.param)))\n  case App:\n    return alphaEq(t1.left, t2.left) && alphaEq(t1.right, t2.right)\n  }\n}\n\nmodule.exports = alphaEq\n","let {Var, Fun, App, Def} = require('./terms')\nlet {identity} = require('../utils')\n\n// Returns the string representation for a given term t.\nlet format = (t, appParens = false, funParens = false) => {\n  let h = t.highlight || identity\n  switch (t.type) {\n  case Var:\n  case Def:\n    return h(t.name)\n  case Fun:\n    let lambda = `λ${t.param}`\n    if (t.highlightVar) lambda = t.highlightVar(lambda)\n    let funStr = `${lambda}.${format(t.body)}`\n    return h(funParens ? `(${funStr})` : funStr)\n  case App:\n    let lStr = format(t.left, false, true)\n    let rStr = format(t.right, true, funParens)\n    let appStr = `${lStr} ${rStr}`\n    return h(appParens ? `(${appStr})` : appStr)\n  }\n}\n\nmodule.exports = format\n","let {Var, Fun, App, Def} = require('./terms')\n\n// Whether the variable x appears free in the term t.\nlet freeIn = (x, t) => {\n  switch (t.type) {\n  case Var:\n    return t.name === x\n  case Fun:\n    return t.param !== x && freeIn(x, t.body)\n  case App:\n    return freeIn(x, t.left) || freeIn(x, t.right)\n  case Def:\n    // Definitions don't have free variables.\n    return false\n  }\n}\n\nmodule.exports = freeIn\n","/* parser generated by jison 0.4.17 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar grammar = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[5,7],$V1=[1,6],$V2=[1,7],$V3=[1,8],$V4=[2,10],$V5=[5,7,11,13,14,15];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"root\":3,\"program\":4,\"EOF\":5,\"line\":6,\"SEPARATOR\":7,\"term\":8,\"ident\":9,\"=\":10,\"LAMBDA\":11,\".\":12,\"(\":13,\")\":14,\"IDENT\":15,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",7:\"SEPARATOR\",10:\"=\",11:\"LAMBDA\",12:\".\",13:\"(\",14:\")\",15:\"IDENT\"},\nproductions_: [0,[3,2],[4,0],[4,1],[4,2],[4,3],[6,1],[6,3],[8,4],[8,2],[8,1],[8,3],[9,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\n /* do nothing; terms and definitions already collected */ \nbreak;\ncase 6:\n this.$ = yy.parseTopLevelTerm($$[$0]); \nbreak;\ncase 7:\n this.$ = yy.parseDefinition($$[$0-2], $$[$0]); \nbreak;\ncase 8:\n this.$ = yy.parseFunction($$[$0-2], $$[$0]); \nbreak;\ncase 9:\n this.$ = yy.parseApplication($$[$0-1], $$[$0]); \nbreak;\ncase 10:\n this.$ = yy.parseIdentifier($$[$0]); \nbreak;\ncase 11:\n this.$ = $$[$0-1]; \nbreak;\ncase 12:\n this.$ = yytext; \nbreak;\n}\n},\ntable: [o($V0,[2,2],{3:1,4:2,6:3,8:4,9:5,11:$V1,13:$V2,15:$V3}),{1:[3]},{5:[1,9],7:[1,10]},o($V0,[2,3]),o($V0,[2,6],{8:11,9:12,11:$V1,13:$V2,15:$V3}),o([5,7,11,13,15],$V4,{10:[1,13]}),{9:14,15:$V3},{8:15,9:12,11:$V1,13:$V2,15:$V3},o([5,7,10,11,12,13,14,15],[2,12]),{1:[2,1]},o($V0,[2,4],{8:4,9:5,6:16,11:$V1,13:$V2,15:$V3}),o($V5,[2,9],{8:11,9:12}),o($V5,$V4),{8:17,9:12,11:$V1,13:$V2,15:$V3},{12:[1,18]},{8:11,9:12,11:$V1,13:$V2,14:[1,19],15:$V3},o($V0,[2,5]),o($V0,[2,7],{8:11,9:12,11:$V1,13:$V2,15:$V3}),{8:20,9:12,11:$V1,13:$V2,15:$V3},o($V5,[2,11]),o([5,7,14],[2,8],{8:11,9:12,11:$V1,13:$V2,15:$V3})],\ndefaultActions: {9:[2,1]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        function _parseError (msg, hash) {\n            this.message = msg;\n            this.hash = hash;\n        }\n        _parseError.prototype = Error;\n\n        throw new _parseError(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n var openParens = 0; /* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0: openParens++; return 13; \nbreak;\ncase 1: openParens--; return 14; \nbreak;\ncase 2: return 11; \nbreak;\ncase 3: return 12; \nbreak;\ncase 4: return 10; \nbreak;\ncase 5: /* ignore separators inside parens */\n                   if (openParens <= 0) return 7\n                 \nbreak;\ncase 6: /* ignore whitespace */ \nbreak;\ncase 7: /* ignore line comments */ \nbreak;\ncase 8: return 15; \nbreak;\ncase 9: return 5; \nbreak;\n}\n},\nrules: [/^(?:\\()/,/^(?:\\))/,/^(?:\\\\|λ)/,/^(?:\\.)/,/^(?:=)/,/^(?:\\n)/,/^(?:[^\\S\\n]+)/,/^(?:;.*)/,/^(?:[^\\s\\(\\)\\\\λ\\.=]+)/,/^(?:$)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = grammar;\nexports.Parser = grammar.Parser;\nexports.parse = function () { return grammar.parse.apply(grammar, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}","let {Fun, App} = require('./terms')\nlet {extend} = require('../utils')\n\n// Compose a function with a term constructor.\nexports.composeFun = (fn, x) => (b) => fn(Fun(x, b))\nexports.composeAppL = (fn, l) => (r) => fn(App(l, r))\nexports.composeAppR = (fn, r) => (l) => fn(App(l, r))\n\n// Mark a reduction step on the `after` term.\nexports.markStep = (type, before, after) =>\n  extend({}, after, {step: {type, before}})\n","let {Var, Fun, App, Def} = require('./terms')\nlet parse = require('./parse')\nlet format = require('./format')\nlet reduceProgram = require('./reduce-program')\n\nmodule.exports = {\n  Var, Fun, App, Def,\n  parse, format, reduceProgram,\n}\n","let {Var, Fun, App, Def} = require('./terms')\nlet {timed, collapseWhitespace} = require('../utils')\nlet {Parser} = require('./grammar')\n\n// Parses an input program string and returns an object with the top-level terms\n// and definitions of the program.\nmodule.exports = timed('parse', str => {\n  // A custom Jison parser.\n  let parser = new Parser\n\n  // A definition table with the definition term by their names.\n  let defs = {}\n  // The terms of the program.\n  let terms = []\n\n  // Add some handy functions so the parser can build the AST.\n  parser.yy = {\n    parseFunction: Fun,\n    parseApplication: App,\n    parseDefinition: (name, term) => {\n      if (defs[name]) throw Error(`${name} already defined`)\n      defs[name] = term\n    },\n    parseTopLevelTerm: (term) => {\n      terms.push(term)\n    },\n    parseIdentifier: Ref,\n  }\n\n  parser.parse(str)\n\n  terms.forEach(t => resolveTermRefs(t, defs))\n\n  let refNames = {}\n  for (let name in defs)\n    resolveDefRefs(name, defs[name], defs, refNames)\n\n  return {defs, terms}\n})\n\n\n// Temporary term used only while parsing as a placeholder for wither a Var o a\n// Ref. On the first pass the parser cannot know if an identifier is a variable\n// or a definition (because definitions can be declared after their use), so it\n// stores a Ref instead and then on a second pass decides what it should be and\n// *mutates* the Ref in-place to become either a Var or a Ref.\nlet Ref = name => ({type: Ref, name})\n\n// Changes all Refs inside term t to either Vars or Defs.\nlet resolveTermRefs = (t, defs, boundNames = []) => {\n  switch (t.type) {\n  case Ref:\n    let free = boundNames.indexOf(t.name) < 0\n    if (t.name in defs && free) {\n      t.type = Def\n      t.term = defs[t.name]\n    } else {\n      t.type = Var\n    }\n    break\n  case App:\n    resolveTermRefs(t.left, defs, boundNames)\n    resolveTermRefs(t.right, defs, boundNames)\n    break\n  case Fun:\n    resolveTermRefs(t.body, defs, boundNames.concat(t.param))\n    break\n  }\n}\n\n// Changes all Refs inside term t to either Vars or Defs.\nlet resolveDefRefs = (defName, t, defs, refNames, boundNames = []) => {\n  switch (t.type) {\n  case Ref:\n    let bound = boundNames.indexOf(t.name) >= 0\n    if (bound) {\n      t.type = Var\n    } else if (t.name in defs) {\n      refNames[defName] = [...refNames[defName] || [], t.name]\n      checkForCircularRefs(defName, t.name, refNames)\n      t.type = Def\n      t.term = defs[t.name]\n    } else {\n      throw Error(collapseWhitespace(\n        `Illegal free variable \"${t.name}\" in \"${defName}\". \n        Definitions cannot have free variables.`\n      ))\n    }\n    break\n  case App:\n    resolveDefRefs(defName, t.left, defs, refNames, boundNames)\n    resolveDefRefs(defName, t.right, defs, refNames, boundNames)\n    break\n  case Fun:\n    let boundOnBody = boundNames.concat(t.param)\n    resolveDefRefs(defName, t.body, defs, refNames, boundOnBody)\n    break\n  }\n}\n\nlet checkForCircularRefs = (name, refName, refNames, path = []) => {\n  if (name === refName) {\n    let circularNote = path.length\n      ? `In this case the definition does not reference itself directly, but \n        through other definitions: ${[name, ...path, name].join(' → ')}.`\n      : ''\n    throw Error(collapseWhitespace(\n      `Illegal recursive reference in \"${name}\". Definitions cannot\n      reference themselves; they are just simple find&replace mechanisms.\n      ${circularNote}\n      If you want to write a recursive function, look for \"Y combinator\" ;)`\n    ))\n  }\n\n  let nextRefs = refNames[refName] || []\n  nextRefs.forEach(nextRef =>\n    checkForCircularRefs(name, nextRef, refNames, [...path, refName])\n  )\n}\n","let {extend, timed, compose, identity} = require('../utils')\nlet {Var, Fun, App, Def} = require('./terms')\nlet parse = require('./parse')\nlet reduce = require('./reduce')\nlet {substitute} = require('./substitute')\nlet format = require('./format')\nlet alphaEq = require('./alpha-eq')\n\n// Reduce a program and return with the reduction for each term in the program.\nmodule.exports = (program, options = {}) => {\n  let {terms, defs} = parse(program)\n  return terms.map(term => reduceTerm(term, defs, options))\n}\n\n// Reduces a term up to its normal form.\nlet reduceTerm = timed('reduce', (term, defs,\n  {maxSteps = 100, strategy = 'normal', etaEnabled = false} = {}) => {\n  let enough = {}\n  let steps = []\n  let terminates = false\n  try {\n    reduce(term, {strategy, etaEnabled}, step => {\n      if (steps.length >= maxSteps) throw enough\n      steps.push(step)\n    })\n    terminates = true\n  } catch (e) {\n    if (e !== enough) throw e\n    terminates = false\n  }\n\n  let last = steps[steps.length - 1] || term\n  let finalSynonyms = findSynonyms(last, defs)\n  let initial = format(term)\n  let final = format(last)\n  let totalSteps = steps.length\n  let renderStep = (i, options) =>\n    expandStep(steps[i], options)\n  return {initial, final, finalSynonyms, terminates, totalSteps, renderStep}\n})\n\nlet expandStep = (t, options = {}) => {\n  let stepTerm = find(t, subT => subT.step)\n  let type = stepTerm.step.type\n  let before = stepTerm.step.before\n  let after = stepTerm\n\n  let highlightFormer = options.highlightFormerTerm || identity\n  let highlightSubst = options.highlightSubstitutionTerm || identity\n  let highlightStep = options.highlightStep || identity\n\n  switch (type) {\n  case 'alpha':\n    before = highlightFunctionVar(before.body, before.param, highlightFormer)\n    after = highlightFunctionVar(after.body, after.param, highlightSubst)\n    break\n  case 'beta':\n    let fun = before.left\n    let hs = highlight(before.right, highlightSubst)\n    let ha = highlightFunctionVar(fun.body, fun.param, highlightFormer)\n    before = App(ha, hs)\n    after = substitute(fun.body, fun.param, hs)\n    break\n  case 'eta':\n  case 'def':\n    before = highlight(before, highlightFormer)\n    after = highlight(after, highlightSubst)\n  }\n\n  before = highlight(before, highlightStep)\n  after = highlight(after, highlightStep)\n\n  before = format(replace(t, stepTerm, before))\n  after = format(replace(t, stepTerm, after))\n\n  return {type, before, after}\n}\n\nlet highlight = (t, fn) => {\n  if (t.highlight)\n    fn = compose(fn, t.highlight)\n  return extend({}, t, {highlight: fn})\n}\n\nlet highlightFunctionVar = (t, x, fn) => {\n  let hx = highlight(Var(x), fn)\n  let ht = substitute(t, x, hx)\n  return extend(Fun(x, ht), {highlightVar: fn})\n}\n\nlet find = (t, fn) => {\n  if (fn(t))\n    return t\n  switch (t.type) {\n  case Var:\n  case Def:\n    return\n  case Fun:\n    return find(t.body, fn)\n  case App:\n    return find(t.left, fn) || find(t.right, fn)\n  }\n}\n\nlet replace = (t, from, to) => {\n  if (t === from)\n    return to\n  switch (t.type) {\n  case Var:\n  case Def:\n    return t\n  case Fun:\n    let body = replace(t.body, from, to)\n    return t.body === body ? t : Fun(t.param, body)\n  case App:\n    let l = replace(t.left, from, to)\n    if (t.left !== l) return App(l, t.right)\n    let r = replace(t.right, from, to)\n    return t.right === r ? t : App(l, r)\n  }\n}\n\nlet findSynonyms = (term, defs) => {\n  let synonyms = []\n  for (let name in defs)\n    if (alphaEq(term, defs[name]))\n      synonyms.push(name)\n  return synonyms\n}\n\n\n","let {Var, Fun, App, Def} = require('./terms')\nlet {renameForSubstitution, applySubstitution} = require('./substitute')\nlet {markStep, composeFun, composeAppL, composeAppR} = require('./helpers')\nlet freeIn = require('./free-in')\n\nmodule.exports = (t, {strategy, etaEnabled}, cb) => {\n  let reduce = reduceFunctions[strategy]\n  let reduced = reduce(t, cb)\n  if (etaEnabled)\n    reduced = reduceEta(reduced, cb)\n  return reduced\n}\n\nlet reduceCallByName = (t, cb) => {\n  switch (t.type) {\n  case Var:\n  case Fun:\n    return t\n  case App:\n    let l = reduceCallByName(t.left, composeAppR(cb, t.right))\n    if (l.type === Fun)\n      return reduceCallByName(apply(l, t.right, cb), cb)\n    else\n    // TODO This is suspicious. If some reductions were made in previous\n    // l = reduceCallByName ... call, then we are losing the result of those\n    // reductions, but we have recorded them with cb.\n      return App(l, t.right)\n  case Def:\n    cb(markStep('def', t, t.term))\n    return reduceCallByName(t.term, cb)\n  }\n}\n\nlet reduceNormal = (t, cb) => {\n  switch (t.type) {\n  case Var:\n    return t\n  case Fun:\n    return Fun(t.param, reduceNormal(t.body, composeFun(cb, t.param)))\n  case App:\n    let l = reduceCallByName(t.left, composeAppR(cb, t.right))\n    if (l.type === Fun) {\n      return reduceNormal(apply(l, t.right, cb), cb)\n    } else {\n      l = reduceNormal(l, composeAppR(cb, t.right)) // Finish reducing l.\n      let r = reduceNormal(t.right, composeAppL(cb, l))\n      return App(l, r)\n    }\n  case Def:\n    cb(markStep('def', t, t.term))\n    return reduceNormal(t.term, cb)\n  }\n}\n\nlet reduceCallByValue = (t, cb) => {\n  switch (t.type) {\n  case Var:\n  case Fun:\n    return t\n  case App:\n    let l = reduceCallByValue(t.left, composeAppR(cb, t.right))\n    let r = reduceCallByValue(t.right, composeAppL(cb, l))\n    if (l.type === Fun)\n      return reduceCallByValue(apply(l, r, cb), cb)\n    else\n      return App(l, r)\n  case Def:\n    cb(markStep('def', t, t.term))\n    return reduceCallByValue(t.term, cb)\n  }\n}\n\nlet reduceApplicative = (t, cb) => {\n  switch (t.type) {\n  case Var:\n    return t\n  case Fun:\n    return Fun(t.param, reduceApplicative(t.body, composeFun(cb, t.param)))\n  case App:\n    let l = reduceCallByValue(t.left, composeAppR(cb, t.right))\n    if (l.type === Fun) {\n      let r = reduceCallByValue(t.right, composeAppL(cb, l))\n      return reduceApplicative(apply(l, r, cb), cb)\n    } else {\n      l = reduceApplicative(l, composeAppR(cb, t.right))\n      let r = reduceApplicative(t.right, composeAppL(cb, l))\n      return App(l, r)\n    }\n  case Def:\n    cb(markStep('def', t, t.term))\n    return reduceApplicative(t.term, cb)\n  }\n}\n\nlet apply = (fun, subst, cb) => {\n  let renameCb = composeFun(composeAppR(cb, subst), fun.param)\n  let renamedBody = renameForSubstitution(fun.body, fun.param, subst, renameCb)\n  let renamed = App(Fun(fun.param, renamedBody), subst)\n  let applied = applySubstitution(renamedBody, fun.param, subst)\n  cb(markStep('beta', renamed, applied))\n  return applied\n}\n\n// Performs any available η-reductions on a term.\nlet reduceEta = (t, cb) => {\n  switch (t.type) {\n  case Var:\n    return t\n  case Fun:\n    // λx.(F x) = F if x is free in F\n    let isEta = t.body.type === App &&\n      t.body.right.type === Var &&\n      t.body.right.name === t.param &&\n      !freeIn(t.param, t.body.left)\n    if (isEta) {\n      cb(markStep('eta', t, t.body.left))\n      return t.body.left\n    } else {\n      return Fun(t.param, reduceEta(t.body, composeFun(cb, t.param)))\n    }\n  case App:\n    let l = reduceEta(t.left, composeAppR(cb, t.right))\n    let r = reduceEta(t.right, composeAppR(cb, l))\n    return App(l, r)\n  case Def:\n    return t\n  }\n}\n\nlet reduceFunctions = {\n  normal: reduceNormal,\n  applicative: reduceApplicative,\n  cbn: reduceCallByName,\n  cbv: reduceCallByValue,\n}\n","let {Var, Fun, App, Def} = require('./terms')\nlet {markStep, composeFun, composeAppL, composeAppR} = require('./helpers')\nlet freeIn = require('./free-in')\n\n// Applies the substitution T[x := S]\n// I.e., substitutes the variable x for the term S in the term T.\nlet substitute = (t, x, s) => {\n  switch (t.type) {\n  case Var:\n    // x[x := S] = S\n    // y[x := S] = y\n    return t.name === x ? s : t\n  case Fun:\n    // (λx.E)[x := S] = λx.E\n    // λx creates a new context for x so no further substitution is needed.\n    if (t.param === x) return t\n    // (λy.E)[x := S] with x != y\n    // If y is free in S and x is free in E, then must α-convert λy.E to avoid\n    // name conflicts.\n    if (freeIn(t.param, s) && freeIn(x, t.body)) {\n      // (λy.E)[x := S] = λy'.(E[y := y'][x := S])\n      let newVarName = renameVar(t.param, t.body, s)\n      let renamedBody = applySubstitution(t.body, t.param, Var(newVarName))\n      return Fun(newVarName, substitute(renamedBody, x, s))\n    } else {\n      // (λy.E)[x := S] = λy.(E[x := S])\n      return Fun(t.param, substitute(t.body, x, s))\n    }\n  case App:\n    // (U V)[x := S] = (U[x := S]) (V[x := S])\n    return App(substitute(t.left, x, s), substitute(t.right, x, s))\n  case Def:\n    return t\n  }\n}\n\n// Note: renameForSubstitution() and applySubstitution() are the same as\n// substitute(), only split up into two different steps. We need them that way\n// to be able to do all alpha-renaming steps before each beta-reduction, but it\n// would be nice to have these three functions DRY up a bit.\n\n// Performs the α-conversions necessary for the substitution T[x := S], but does\n// not perform the substitution itself.\n// Records the α-conversions by calling cb.\nlet renameForSubstitution = (t, x, s, cb) => {\n  switch (t.type) {\n  case Var:\n  case Def:\n    return t\n  case Fun:\n    if (t.param === x) return t\n    if (freeIn(t.param, s) && freeIn(x, t.body)) {\n      let newVarName = renameVar(t.param, t.body, s)\n      let renamedBody = applySubstitution(t.body, t.param, Var(newVarName))\n      cb(markStep('alpha', t, t = Fun(newVarName, renamedBody)))\n    }\n    let body = renameForSubstitution(t.body, x, s, composeFun(cb, t.param))\n    return Fun(t.param, body)\n  case App:\n    let l = renameForSubstitution(t.left, x, s, composeAppR(cb, t.right))\n    let r = renameForSubstitution(t.right, x, s, composeAppL(cb, l))\n    return App(l, r)\n  }\n}\n\n// Applies the substitution T[x := S] directly, without doing α-conversions.\nlet applySubstitution = (t, x, s) => {\n  switch (t.type) {\n  case Var:\n    return t.name === x ? s : t\n  case Fun:\n    return t.param === x\n      ? t\n      : Fun(t.param, applySubstitution(t.body, x, s))\n  case App:\n    let l = applySubstitution(t.left, x, s)\n    let r = applySubstitution(t.right, x, s)\n    return App(l, r)\n  case Def:\n    return t\n  }\n}\n\n// Renames a variable to avoid naming conflicts case doing: a substitution.\nlet renameVar = (oldName, t, s) => {\n  // Split the name into base and number part.\n  let base = oldName.replace(/\\d+$/, '')\n  let match = oldName.match(/\\d+$/)\n  let n = match ? parseInt(match[0]) : 0\n\n  while (true) {\n    n++\n    let newName = base + n\n    let isValid =\n      // Avoid name collisions with substitution term.\n      !freeIn(newName, s) &&\n      // Avoid name collisions with free variables in body.\n      !freeIn(newName, t) &&\n      // Avoid name collisions with inner functions.\n      !varRenameCollides(t, oldName, newName)\n    if (isValid)\n      return newName\n  }\n}\n\n// Whether a variable rename collides in a given term. That is, if changing the\n// occurrences of oldName with newName in t would make it change t's meaning\n// (i.e. not be α-equivalent).\nlet varRenameCollides = (t, oldName, newName) => {\n  switch (t.type) {\n  case Var:\n  case Def:\n    return false\n  case Fun:\n    // A variable rename collides with this function if the old variable\n    // was free in the function and the new name for the variable is the\n    // same as the param of the function, thus changing old free variable\n    // binding.\n    return t.param === newName && freeIn(oldName, t) ||\n      // Or if the renaming collides in the body of the function.\n      varRenameCollides(t.body, oldName, newName)\n  case App:\n    return varRenameCollides(t.left, oldName, newName) ||\n      varRenameCollides(t.right, oldName, newName)\n  }\n}\n\nmodule.exports = {substitute, renameForSubstitution, applySubstitution}\n","// Term types/constructors.\nlet Var = name => ({type: Var, name})\nlet Fun = (param, body) => ({type: Fun, param, body})\nlet App = (left, right) => ({type: App, left, right})\nlet Def = (name, term) => ({type: Def, name, term})\n\nmodule.exports = {Var, Fun, App, Def}\n","exports.extend = Object.assign || ((obj, ...srcs) => {\n  srcs.forEach(src => {\n    for (let k in src)\n      obj[k] = src[k]\n  })\n  return obj\n})\n\nlet logTimings = false\nexports.timed = (name, fn) => (...args) => {\n  logTimings && console.time(name) // eslint-disable-line no-console\n  let res = fn(...args)\n  logTimings && console.timeEnd(name) // eslint-disable-line no-console\n  return res\n}\n\nexports.enableLogTimings = () => { logTimings = true }\nexports.disableLogTimings = () => { logTimings = false }\n\nexports.compose = (f, g) => (x) => f(g(x))\n\nexports.identity = x => x\n\nexports.dedent = str => {\n  let match = str.match(/^[ \\t]*(?=\\S)/gm)\n\n  if (!match)\n    return str\n\n  let indent = Math.min(...match.map(x => x.length))\n  let re = new RegExp(`^[ \\\\t]{${indent}}`, 'gm')\n  let unindented = indent > 0 ? str.replace(re, '') : str\n\n  return unindented.trim()\n}\n\nexports.collapseWhitespace = str => str.replace(/\\s+/gm, ' ')\n"]}