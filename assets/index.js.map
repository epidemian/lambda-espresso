{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/app.ts","src/dom.ts","src/examples.ts","src/lambda/alpha-eq.ts","src/lambda/format.ts","src/lambda/free-in.ts","src/lambda/grammar.js","src/lambda/helpers.ts","src/lambda/index.ts","src/lambda/parse.ts","src/lambda/reduce-program.ts","src/lambda/reduce.ts","src/lambda/substitute.ts","src/lambda/terms.ts","src/utils.ts"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","dom_1","examples_1","__importDefault","lambda_1","utils_1","enableLogTimings","input","$","output","document","addEventListener","keyCode","ctrlKey","run","event","key","preventDefault","start","selectionStart","end","selectionEnd","oldValue","value","slice","_","renderTerm","term","className","renderArrow","symbol","label","arrowSymbols","alpha","beta","eta","def","renderSynonyms","synonyms","join","getOptions","maxReductionSteps","parseInt","strategy","etaEnabled","checked","reductions","reduceProgram","renderReductions","err","textContent","message","String","classList","add","timed","innerHTML","map","renderCollapsedReduction","remove","delegate","element","reduction","nodeIndex","totalSteps","expanded","querySelector","collapsed","toggle","renderExpandedReductionForm","prev","previousElementSibling","renderCollapsedReductionForm","initial","arrow","final","reductionSteps","finalSynonyms","steps","step","renderStep","renderStepOptions","before","after","arrowSymbol","type","arrowLabel","lastStep","push","highlightStep","s","highlightFormerTerm","highlightSubstitutionTerm","dedent","focus","examplesMenu","examplesHtml","default","example","href","encodeURI","name","scrollTop","examplesDropdown","contains","stopPropagation","once","location","hash","updateInputFromHash","decodeURI","codeStart","indexOf","window","eventType","selector","handler","target","Element","closest","Array","prototype","parentNode","childNodes","examples","substitute_1","terms_1","alphaEq","t1","t2","left","right","param","body","substitute","Var","format","appParens","funParens","highlight","h","identity","highlightVar","lambda","funStr","lStr","rStr","appStr","freeIn","x","grammar","k","v","l","$V0","$V1","$V2","$V3","$V4","$V5","parser","trace","yy","symbols_","error","root","program","EOF","line","SEPARATOR","ident","=","LAMBDA",".","(",")","IDENT","$accept","$end","terminals_","2","5","7","10","11","12","13","14","15","productions_","performAction","anonymous","yytext","yyleng","yylineno","yystate","$$","_$","$0","this","parseTopLevelTerm","parseDefinition","parseFunction","parseApplication","parseIdentifier","table","3","4","6","8","9","defaultActions","parseError","str","recoverable","parse","self","stack","tstack","vstack","lstack","recovering","TERROR","args","arguments","lexer","Object","create","sharedState","hasOwnProperty","setInput","yylloc","yyloc","ranges","options","getPrototypeOf","popStack","_token_stack","lex","token","preErrorSymbol","state","action","yyval","len","newState","expected","errStr","showPosition","text","match","loc","first_line","last_line","first_column","last_column","range","apply","concat","openParens","_input","_more","_backtrack","done","matched","conditionStack","offset","ch","lines","unput","split","substr","oldLines","more","reject","backtrack_lexer","less","pastInput","past","replace","upcomingInput","next","pre","test_match","indexed_rule","backup","matches","tempMatch","index","rules","_currentRules","flex","begin","condition","popState","pop","conditions","topState","Math","abs","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","YYSTATE","INITIAL","inclusive","Parser","main","commonjsMain","console","log","process","exit","source","readFileSync","normalize","argv","composeFun","fn","b","Fun","composeAppL","App","composeAppR","markStep","assign","__exportStar","parse_1","defineProperty","enumerable","get","format_1","reduce_program_1","grammar_1","defs","terms","forEach","resolveTermRefs","refNames","keys","resolveDefRefs","boundNames","free","defName","bound","checkForCircularRefs","collapseWhitespace","boundOnBody","refName","path","circularNote","nextRefs","nextRef","alpha_eq_1","reduce_1","reduceTerm","enough","terminates","stepTerm","findStep","last","findSynonyms","expandStep","highlightFunctionVar","fun","hs","ha","beforeStr","replaceStep","afterStr","hx","ht","replacement","free_in_1","helpers_1","reduce","cb","reducer","reduceFunctions","reduced","reduceEta","reduceCallByName","reduceNormal","reduceCallByValue","reduceApplicative","subst","renameCb","renamedBody","renameForSubstitution","renamed","applied","applySubstitution","normal","applicative","cbn","cbv","newVarName","renameVar","oldName","base","newName","isValid","varRenameCollides","Def","logTimings","time","res","timeEnd","disableLogTimings","indent","min","re","RegExp","unindented","trim"],"mappings":"CAAA,WAAA,SAAAA,EAAAC,EAAAC,EAAAC,GAAA,SAAAC,EAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,IAAAE,EAAA,mBAAAC,SAAAA,QAAA,IAAAF,GAAAC,EAAA,OAAAA,EAAAF,GAAA,GAAA,GAAAI,EAAA,OAAAA,EAAAJ,GAAA,GAAA,IAAAK,EAAA,IAAAC,MAAA,uBAAAN,EAAA,KAAA,MAAAK,EAAAE,KAAA,mBAAAF,EAAA,IAAAG,EAAAX,EAAAG,GAAA,CAAAS,QAAA,IAAAb,EAAAI,GAAA,GAAAU,KAAAF,EAAAC,QAAA,SAAAd,GAAA,IAAAE,EAAAD,EAAAI,GAAA,GAAAL,GAAA,OAAAI,EAAAF,GAAAF,IAAAa,EAAAA,EAAAC,QAAAd,EAAAC,EAAAC,EAAAC,GAAA,OAAAD,EAAAG,GAAAS,QAAA,IAAA,IAAAL,EAAA,mBAAAD,SAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAa,OAAAX,IAAAD,EAAAD,EAAAE,IAAA,OAAAD,EAAA,OAAAJ,GAAA,EAAA,CAAA,CAAAiB,EAAA,CAAA,SAAAT,QAAAU,OAAAJ,2LCCA,MAAAK,MAAAX,QAAA,SACA,MAAAY,WAAAC,gBAAAb,QAAA,eACA,MAAAc,SAAAd,QAAA,YACA,MAAAe,QAAAf,QAAA,YAEA,EAAAe,QAAAC,oBAEA,MAAMC,OAAQ,EAAAN,MAAAO,GAAE,UAChB,MAAMC,QAAS,EAAAR,MAAAO,GAAE,WAGjBE,SAASC,iBAAiB,QAAS5B,IACjC,GAAIA,EAAE6B,UAAY,IAAM7B,EAAE8B,QAAS,CACjCC,SAIJP,MAAMI,iBAAiB,WAAYI,QAEjC,GAAIA,MAAMC,MAAQ,KAAM,CACtBD,MAAME,iBACN,MAAMC,MAAQX,MAAMY,gBAAkB,EACtC,MAAMC,IAAMb,MAAMc,cAAgB,EAClC,MAAMC,SAAWf,MAAMgB,MAEvBhB,MAAMgB,MAAQD,SAASE,MAAM,EAAGN,OAAS,IAAMI,SAASE,MAAMJ,KAG9Db,MAAMY,eAAiBZ,MAAMc,aAAeH,MAAQ,MAIxD,EAAAjB,MAAAO,GAAE,QAAQG,iBAAiB,QAASc,GAAKX,OAEzC,MAAMY,WAAa,CAACC,KAAcC,UAAY,0BACvBA,cAAcD,cAErC,MAAME,YAAc,CAACC,OAAgBC,6BACdD,gBAAgBC,uBAEvC,MAAMC,aAAe,CACnBC,MAAO,IACPC,KAAM,IACNC,IAAK,IACLC,IAAK,IAGP,MAAMC,eAAkBC,UACtBA,SAASxC,gCAAkCwC,SAASC,KAAK,gBAAkB,GAE7E,MAAMC,WAAa,KACjB,MAAMC,kBAAoBC,UACxB,EAAAzC,MAAAO,GAAoB,yBAAyBe,OAAS,IACtD,IAEF,MAAMoB,UAAW,EAAA1C,MAAAO,GAAoB,gCAClCe,MACH,MAAMqB,YAAa,EAAA3C,MAAAO,GAAoB,yBAAyBqC,QAChE,MAAO,CAAEJ,kBAAAA,kBAAmBE,SAAAA,SAAUC,WAAAA,aAGxC,IAAIE,WAA0B,GAC9B,MAAMhC,IAAM,KACV,MAAMpB,KAAOa,MAAMgB,MACnB,IACEuB,YAAa,EAAA1C,SAAA2C,eAAcrD,KAAM8C,cACjCQ,mBACA,MAAOC,KACPxC,OAAOyC,YAAcD,eAAexD,MAAQwD,IAAIE,QAAUC,OAAOH,KACjExC,OAAO4C,UAAUC,IAAI,WAIzB,MAAMN,kBAAmB,EAAA3C,QAAAkD,OAAM,cAAe,KAC5C9C,OAAO+C,UAAYV,WAAWW,IAAIC,0BAA0BnB,KAAK,IACjE9B,OAAO4C,UAAUM,OAAO,YAG1B,EAAA1D,MAAA2D,UAAS,QAASnD,OAAQ,aAAcoD,UACtC,MAAMC,UAAYhB,YAAW,EAAA7C,MAAA8D,WAAUF,UACvC,GAAIC,UAAUE,aAAe,EAAG,CAC9B,OAEF,MAAMC,SAAWJ,QAAQK,cAAc,aACvC,MAAMC,UAAYN,QAAQK,cAAc,cACxC,GAAID,SAAU,CACZA,SAASZ,UAAUe,OAAO,UAC1BD,UAAWd,UAAUe,OAAO,cACvB,CACLD,UAAWd,UAAUC,IAAI,UACzBO,QAAQL,WAAaa,4BAA4BP,eAIrD,EAAA7D,MAAA2D,UAAS,YAAanD,OAAQ,kBAAmBoD,UAC/CA,QAAQR,UAAUC,IAAI,aAEtB,MAAMgB,KAAOT,QAAQU,uBACrB,GAAID,KAAM,CACRA,KAAKJ,cAAc,UAAWb,UAAUC,IAAI,cAIhD,EAAArD,MAAA2D,UAAS,WAAYnD,OAAQ,kBAAmBoD,UAC9CA,QAAQR,UAAUM,OAAO,aACzB,MAAMW,KAAOT,QAAQU,uBACrB,GAAID,KAAM,CACRA,KAAKJ,cAAc,UAAWb,UAAUM,OAAO,aAInD,MAAMD,yBAA4BI,mCACRU,6BAA6BV,mBAEvD,MAAMU,6BAAgCV,YACpC,MAAMW,QAAU/C,WAAWoC,UAAUW,SACrC,IAAIC,MAAQ,GACZ,IAAIC,MAAQ,GACZ,GAAIb,UAAUc,eAAiB,EAAG,CAChCF,MAAQ7C,YAAY,QAASiC,UAAUc,mBACvCD,MAAQjD,WAAWoC,UAAUa,OAE/B,MAAMrC,SAAWD,eAAeyB,UAAUe,eAC1C,8BAA+BJ,WAAWC,SAASC,SAASrC,kBAG9D,MAAM+B,4BAA+BP,YACnC,MAAMgB,MAAQ,GACd,IAAK,IAAI3F,EAAI,EAAGA,EAAI2E,UAAUE,WAAY7E,IAAK,CAC7C,MAAM4F,KAAOjB,UAAUkB,WAAW7F,EAAG8F,mBACrC,MAAMC,OAASxD,WAAWqD,KAAKG,OAAQ,UACvC,MAAMC,MAAQzD,WAAWqD,KAAKI,MAAO,SACrC,MAAMC,YAAcL,KAAKM,OAAS,MAAQ,IAAM,IAChD,MAAMC,WAAatD,aAAa+C,KAAKM,MACrC,MAAMX,MAAQ7C,YAAYuD,YAAaE,YACvC,MAAMC,SAAWpG,IAAM2E,UAAUE,WAAa,EAC9C,MAAM1B,SAAWiD,SAAWlD,eAAeyB,UAAUe,eAAiB,GACtEC,MAAMU,yBACgBN,aAAaR,SAASS,SAAS7C,mBAIvD,6BAA8BwC,MAAMvC,KAAK,aAG3C,MAAM0C,kBAAoB,CACxBQ,cAAgBC,wBAAmCA,WACnDC,oBAAsBD,8BAAyCA,WAC/DE,0BAA4BF,6BAAwCA,YAGtEnF,MAAMgB,OAAQ,EAAAlB,QAAAwF,iHAIdtF,MAAMuF,QAEN,MAAMC,cAAe,EAAA9F,MAAAO,GAAE,kBACvB,MAAMwF,aAAe9F,WAAA+F,QAASxC,IAAI,CAACyC,QAAS/G,KAC1C,MAAMgH,KAAOC,eAAeF,QAAQxG,QACpC,sBAAuByG,SAAShH,OAAO+G,QAAQG,kBAGjDN,aAAavC,UAAYwC,aAAazD,KAAK,KAC3C,EAAAtC,MAAA2D,UAAS,QAASmC,aAAc,KAAM,CAAClC,QAAS9C,SAC9CA,MAAME,iBACNV,MAAMgB,MAAQrB,WAAA+F,SAAS,EAAAhG,MAAA8D,WAAUF,UAAUnE,KAC3Ca,MAAM+F,UAAY,IAGpB,MAAMC,kBAAmB,EAAAtG,MAAAO,GAAE,sBAC3B+F,iBAAiB5F,iBAAiB,QAAS5B,IACzC,GAAIwH,iBAAiBlD,UAAUmD,SAAS,UAAW,CACjD,OAEFzH,EAAE0H,kBACFF,iBAAiBlD,UAAUC,IAAI,UAC/B5C,SAASC,iBACP,QACA,KACE4F,iBAAiBlD,UAAUM,OAAO,WAEpC,CAAE+C,KAAM,UAIZ,EAAAzG,MAAAO,GAAE,eAAeG,iBAAiB,QAAS,KACzC,MAAMjB,KAAOa,MAAMgB,MACnBoF,SAASC,SAAWlH,SAGtB,MAAMmH,oBAAsB,KAC1B,MAAMD,KAAOE,UAAUH,SAASC,MAChC,MAAMG,UAAYH,KAAKI,QAAQ,KAC/B,GAAID,WAAa,EAAG,CAClBxG,MAAMgB,MAAQqF,KAAKpF,MAAMuF,UAAY,KAIzCE,OAAOtG,iBAAiB,aAAckG,qBACtCA,2OCzMO,MAAMrG,EAAwBkF,GACnChF,SAASwD,cAAcwB,GADZ9F,QAAAY,EAACA,EAIP,MAAMoD,SAAW,CACtBsD,UACArD,QACAsD,SACAC,WAEAvD,QAAQlD,iBAAiBuG,UAAWnG,QAClC,GAAIA,MAAMsG,kBAAkBC,QAAS,CACnC,MAAMC,QAAUxG,MAAMsG,OAAOE,QAAQJ,UACrC,GAAII,SAAW1D,QAAQ2C,SAASe,SAAU,CACxCH,QAAQG,QAASxG,YAVZnB,QAAAgE,SAAQA,SAgBd,MAAMG,UAAaF,UACxB,OAAO2D,MAAMC,UAAUT,QAAQnH,KAAKgE,QAAQ6D,WAAYC,WAAY9D,UADzDjE,QAAAmE,UAASA,yHCpBtB,MAAA1D,QAAAf,QAAA,WAEA,MAAMsI,SAAW,CACf,CACEvB,KAAM,SACN3G,MAAM,EAAAW,QAAAwF,wzCAkCR,CACEQ,KAAM,WACN3G,MAAM,EAAAW,QAAAwF,ktBA8BR,CACEQ,KAAM,UACN3G,MAAM,EAAAW,QAAAwF,43FA8ER,CACEQ,KAAM,YACN3G,MAAM,EAAAW,QAAAwF,wtFAkER,CACEQ,KAAM,SACN3G,MAAM,EAAAW,QAAAwF,izCA6CVjG,QAAAqG,QAAe2B,oIC1Qf,MAAAC,aAAAvI,QAAA,gBACA,MAAAwI,QAAAxI,QAAA,WAGA,MAAMyI,QAAU,CAACC,GAAUC,MACzB,GAAID,GAAG3C,OAAS,MAAO,CACrB,OAAO0C,QAAQC,GAAGrG,KAAMsG,IAE1B,GAAIA,GAAG5C,OAAS,MAAO,CACrB,OAAO0C,QAAQC,GAAIC,GAAGtG,MAExB,GAAIqG,GAAG3C,OAAS,OAAS4C,GAAG5C,OAAS,MAAO,CAC1C,OAAO2C,GAAG3B,OAAS4B,GAAG5B,KAExB,GAAI2B,GAAG3C,OAAS,OAAS4C,GAAG5C,OAAS,MAAO,CAC1C,OAAO0C,QAAQC,GAAGE,KAAMD,GAAGC,OAASH,QAAQC,GAAGG,MAAOF,GAAGE,OAE3D,GAAIH,GAAG3C,OAAS,OAAS4C,GAAG5C,OAAS,MAAO,CAC1C,GAAI2C,GAAGI,QAAUH,GAAGG,MAAO,CACzB,OAAOL,QAAQC,GAAGK,KAAMJ,GAAGI,UACtB,CACL,OAAON,QAAQC,GAAGK,MAAM,EAAAR,aAAAS,YAAWL,GAAGI,KAAMJ,GAAGG,OAAO,EAAAN,QAAAS,KAAIP,GAAGI,UAGjE,OAAO,OAGTxI,QAAAqG,QAAe8B,qJC3Bf,MAAA1H,QAAAf,QAAA,YAIA,MAAMkJ,OAAS,CAACvJ,EAASwJ,UAAY,MAAOC,UAAY,SAEtD,MAAQC,UAAWC,EAAIvI,QAAAwI,SAAQC,aAAEA,cAAiB7J,EAClD,OAAQA,EAAEoG,MACR,IAAK,MACL,IAAK,MACH,OAAOuD,EAAE3J,EAAEoH,MACb,IAAK,MACH,IAAI0C,WAAa9J,EAAEmJ,QACnB,GAAIU,aAAc,CAChBC,OAASD,aAAaC,QAExB,MAAMC,UAAYD,UAAUP,OAAOvJ,EAAEoJ,QACrC,OAAOO,EAAEF,cAAgBM,UAAYA,QACvC,IAAK,MACH,MAAMC,KAAOT,OAAOvJ,EAAEiJ,KAAM,MAAO,MACnC,MAAMgB,KAAOV,OAAOvJ,EAAEkJ,MAAO,KAAMO,WACnC,MAAMS,UAAYF,QAAQC,OAC1B,OAAON,EAAEH,cAAgBU,UAAYA,UAI3CvJ,QAAAqG,QAAeuC,mICvBf,MAAMY,OAAS,CAACC,EAAWpK,KACzB,OAAQA,EAAEoG,MACR,IAAK,MACH,OAAOpG,EAAEoH,OAASgD,EACpB,IAAK,MACH,OAAOpK,EAAEmJ,QAAUiB,GAAKD,OAAOC,EAAGpK,EAAEoJ,MACtC,IAAK,MACH,OAAOe,OAAOC,EAAGpK,EAAEiJ,OAASkB,OAAOC,EAAGpK,EAAEkJ,OAC1C,IAAK,MAEH,OAAO,QAIbvI,QAAAqG,QAAemD,gDCwDf,IAAAE,QAAA,WACA,IAAApK,EAAA,SAAAqK,EAAAC,EAAAtK,EAAAuK,GACA,IAAAvK,EAAAA,GAAA,GAAAuK,EAAAF,EAAAzJ,OAAA2J,IAAAvK,EAAAqK,EAAAE,IAAAD,GACA,OAAAtK,GAEAwK,IAAA,CAAA,EAAA,GACAC,IAAA,CAAA,EAAA,GACAC,IAAA,CAAA,EAAA,GACAC,IAAA,CAAA,EAAA,GACAC,IAAA,CAAA,EAAA,IACAC,IAAA,CAAA,EAAA,EAAA,GAAA,GAAA,GAAA,IACA,IAAAC,OAAA,CACAC,MAAA,SAAAA,UACAC,GAAA,GACAC,SAAA,CACAC,MAAA,EACAC,KAAA,EACAC,QAAA,EACAC,IAAA,EACAC,KAAA,EACAC,UAAA,EACA9I,KAAA,EACA+I,MAAA,EACAC,IAAA,GACAC,OAAA,GACAC,IAAA,GACAC,IAAA,GACAC,IAAA,GACAC,MAAA,GACAC,QAAA,EACAC,KAAA,GAEAC,WAAA,CACAC,EAAA,QACAC,EAAA,MACAC,EAAA,YACAC,GAAA,IACAC,GAAA,SACAC,GAAA,IACAC,GAAA,IACAC,GAAA,IACAC,GAAA,SAEAC,aAAA,CACA,EACA,CAAA,EAAA,GACA,CAAA,EAAA,GACA,CAAA,EAAA,GACA,CAAA,EAAA,GACA,CAAA,EAAA,GACA,CAAA,EAAA,GACA,CAAA,EAAA,GACA,CAAA,EAAA,GACA,CAAA,EAAA,GACA,CAAA,EAAA,GACA,CAAA,EAAA,GACA,CAAA,EAAA,IAEAC,cAAA,SAAAC,UACAC,OACAC,OACAC,SACAhC,GACAiC,QACAC,GACAC,IAIA,IAAAC,GAAAF,GAAAtM,OAAA,EACA,OAAAqM,SACA,KAAA,EAGA,MACA,KAAA,EACAI,KAAA/L,EAAA0J,GAAAsC,kBAAAJ,GAAAE,KACA,MACA,KAAA,EACAC,KAAA/L,EAAA0J,GAAAuC,gBAAAL,GAAAE,GAAA,GAAAF,GAAAE,KACA,MACA,KAAA,EACAC,KAAA/L,EAAA0J,GAAAwC,cAAAN,GAAAE,GAAA,GAAAF,GAAAE,KACA,MACA,KAAA,EACAC,KAAA/L,EAAA0J,GAAAyC,iBAAAP,GAAAE,GAAA,GAAAF,GAAAE,KACA,MACA,KAAA,GACAC,KAAA/L,EAAA0J,GAAA0C,gBAAAR,GAAAE,KACA,MACA,KAAA,GACAC,KAAA/L,EAAA4L,GAAAE,GAAA,GACA,MACA,KAAA,GACAC,KAAA/L,EAAAwL,OACA,QAGAa,MAAA,CACA3N,EAAAwK,IAAA,CAAA,EAAA,GAAA,CACAoD,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACA1B,GAAA7B,IACA+B,GAAA9B,IACAgC,GAAA/B,MAEA,CAAA9J,EAAA,CAAA,IACA,CAAAsL,EAAA,CAAA,EAAA,GAAAC,EAAA,CAAA,EAAA,KACApM,EAAAwK,IAAA,CAAA,EAAA,IACAxK,EAAAwK,IAAA,CAAA,EAAA,GAAA,CAAAuD,EAAA,GAAAC,EAAA,GAAA1B,GAAA7B,IAAA+B,GAAA9B,IAAAgC,GAAA/B,MACA3K,EAAA,CAAA,EAAA,EAAA,GAAA,GAAA,IAAA4K,IAAA,CAAAyB,GAAA,CAAA,EAAA,MACA,CAAA2B,EAAA,GAAAtB,GAAA/B,KACA,CAAAoD,EAAA,GAAAC,EAAA,GAAA1B,GAAA7B,IAAA+B,GAAA9B,IAAAgC,GAAA/B,KACA3K,EAAA,CAAA,EAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IAAA,CAAA,EAAA,KACA,CAAAa,EAAA,CAAA,EAAA,IACAb,EAAAwK,IAAA,CAAA,EAAA,GAAA,CAAAuD,EAAA,EAAAC,EAAA,EAAAF,EAAA,GAAAxB,GAAA7B,IAAA+B,GAAA9B,IAAAgC,GAAA/B,MACA3K,EAAA6K,IAAA,CAAA,EAAA,GAAA,CAAAkD,EAAA,GAAAC,EAAA,KACAhO,EAAA6K,IAAAD,KACA,CAAAmD,EAAA,GAAAC,EAAA,GAAA1B,GAAA7B,IAAA+B,GAAA9B,IAAAgC,GAAA/B,KACA,CAAA4B,GAAA,CAAA,EAAA,KACA,CAAAwB,EAAA,GAAAC,EAAA,GAAA1B,GAAA7B,IAAA+B,GAAA9B,IAAA+B,GAAA,CAAA,EAAA,IAAAC,GAAA/B,KACA3K,EAAAwK,IAAA,CAAA,EAAA,IACAxK,EAAAwK,IAAA,CAAA,EAAA,GAAA,CAAAuD,EAAA,GAAAC,EAAA,GAAA1B,GAAA7B,IAAA+B,GAAA9B,IAAAgC,GAAA/B,MACA,CAAAoD,EAAA,GAAAC,EAAA,GAAA1B,GAAA7B,IAAA+B,GAAA9B,IAAAgC,GAAA/B,KACA3K,EAAA6K,IAAA,CAAA,EAAA,KACA7K,EAAA,CAAA,EAAA,EAAA,IAAA,CAAA,EAAA,GAAA,CAAA+N,EAAA,GAAAC,EAAA,GAAA1B,GAAA7B,IAAA+B,GAAA9B,IAAAgC,GAAA/B,OAEAsD,eAAA,CAAAD,EAAA,CAAA,EAAA,IACAE,WAAA,SAAAA,WAAAC,IAAAzG,MACA,GAAAA,KAAA0G,YAAA,CACAf,KAAAtC,MAAAoD,SACA,CACA,IAAAjD,MAAA,IAAA3K,MAAA4N,KACAjD,MAAAxD,KAAAA,KACA,MAAAwD,QAGAmD,MAAA,SAAAA,MAAAhN,OACA,IAAAiN,KAAAjB,KACAkB,MAAA,CAAA,GACAC,OAAA,GACAC,OAAA,CAAA,MACAC,OAAA,GACAf,MAAAN,KAAAM,MACAb,OAAA,GACAE,SAAA,EACAD,OAAA,EACA4B,WAAA,EACAC,OAAA,EACAvD,IAAA,EACA,IAAAwD,KAAAH,OAAApM,MAAA3B,KAAAmO,UAAA,GACA,IAAAC,MAAAC,OAAAC,OAAA5B,KAAA0B,OACA,IAAAG,YAAA,CAAAlE,GAAA,IACA,IAAA,IAAAX,KAAAgD,KAAArC,GAAA,CACA,GAAAgE,OAAAzG,UAAA4G,eAAAxO,KAAA0M,KAAArC,GAAAX,GAAA,CACA6E,YAAAlE,GAAAX,GAAAgD,KAAArC,GAAAX,IAGA0E,MAAAK,SAAA/N,MAAA6N,YAAAlE,IACAkE,YAAAlE,GAAA+D,MAAAA,MACAG,YAAAlE,GAAAF,OAAAuC,KACA,UAAA0B,MAAAM,QAAA,YAAA,CACAN,MAAAM,OAAA,GAEA,IAAAC,MAAAP,MAAAM,OACAX,OAAApI,KAAAgJ,OACA,IAAAC,OAAAR,MAAAS,SAAAT,MAAAS,QAAAD,OACA,UAAAL,YAAAlE,GAAAkD,aAAA,WAAA,CACAb,KAAAa,WAAAgB,YAAAlE,GAAAkD,eACA,CACAb,KAAAa,WAAAc,OAAAS,eAAApC,MAAAa,WAEA,SAAAwB,SAAA5P,GACAyO,MAAA3N,OAAA2N,MAAA3N,OAAA,EAAAd,EACA2O,OAAA7N,OAAA6N,OAAA7N,OAAAd,EACA4O,OAAA9N,OAAA8N,OAAA9N,OAAAd,EAEA6P,aAAA,IAAAC,IAAA,WACA,IAAAC,MACAA,MAAAd,MAAAa,OAAAvE,IACA,UAAAwE,QAAA,SAAA,CACAA,MAAAvB,KAAArD,SAAA4E,QAAAA,MAEA,OAAAA,OAEA,IAAAjN,OACAkN,eACAC,MACAC,OACA1P,EACAV,EACAqQ,MAAA,GACAxP,EACAyP,IACAC,SACAC,SACA,MAAA,KAAA,CACAL,MAAAxB,MAAAA,MAAA3N,OAAA,GACA,GAAAyM,KAAAY,eAAA8B,OAAA,CACAC,OAAA3C,KAAAY,eAAA8B,WACA,CACA,GAAAnN,SAAA,aAAAA,QAAA,YAAA,CACAA,OAAAgN,MAEAI,OAAArC,MAAAoC,QAAApC,MAAAoC,OAAAnN,QAEA,UAAAoN,SAAA,cAAAA,OAAApP,SAAAoP,OAAA,GAAA,CACA,IAAAK,OAAA,GACAD,SAAA,GACA,IAAA3P,KAAAkN,MAAAoC,OAAA,CACA,GAAA1C,KAAApB,WAAAxL,IAAAA,EAAAmO,OAAA,CACAwB,SAAA9J,KAAA,IAAA+G,KAAApB,WAAAxL,GAAA,MAGA,GAAAsO,MAAAuB,aAAA,CACAD,OACA,wBACArD,SAAA,GACA,MACA+B,MAAAuB,eACA,eACAF,SAAA/M,KAAA,MACA,WACAgK,KAAApB,WAAArJ,SAAAA,QACA,QACA,CACAyN,OACA,wBACArD,SAAA,GACA,iBACApK,QAAAyI,IACA,eACA,KAAAgC,KAAApB,WAAArJ,SAAAA,QAAA,KAEAyK,KAAAa,WAAAmC,OAAA,CACAE,KAAAxB,MAAAyB,MACAX,MAAAxC,KAAApB,WAAArJ,SAAAA,OACA0I,KAAAyD,MAAA/B,SACAyD,IAAAnB,MACAc,SAAAA,WAGA,GAAAJ,OAAA,aAAA1H,OAAA0H,OAAApP,OAAA,EAAA,CACA,MAAA,IAAAL,MACA,oDACAwP,MACA,YACAnN,QAGA,OAAAoN,OAAA,IACA,KAAA,EACAzB,MAAAjI,KAAA1D,QACA6L,OAAAnI,KAAAyI,MAAAjC,QACA4B,OAAApI,KAAAyI,MAAAM,QACAd,MAAAjI,KAAA0J,OAAA,IACApN,OAAA,KACA,IAAAkN,eAAA,CACA/C,OAAAgC,MAAAhC,OACAD,OAAAiC,MAAAjC,OACAE,SAAA+B,MAAA/B,SACAsC,MAAAP,MAAAM,OACA,GAAAV,WAAA,EAAA,CACAA,kBAEA,CACA/L,OAAAkN,eACAA,eAAA,KAEA,MACA,KAAA,EACAI,IAAA7C,KAAAV,aAAAqD,OAAA,IAAA,GACAC,MAAA3O,EAAAmN,OAAAA,OAAA7N,OAAAsP,KACAD,MAAA9C,GAAA,CACAuD,WAAAhC,OAAAA,OAAA9N,QAAAsP,KAAA,IAAAQ,WACAC,UAAAjC,OAAAA,OAAA9N,OAAA,GAAA+P,UACAC,aAAAlC,OAAAA,OAAA9N,QAAAsP,KAAA,IAAAU,aACAC,YAAAnC,OAAAA,OAAA9N,OAAA,GAAAiQ,aAEA,GAAAtB,OAAA,CACAU,MAAA9C,GAAA2D,MAAA,CACApC,OAAAA,OAAA9N,QAAAsP,KAAA,IAAAY,MAAA,GACApC,OAAAA,OAAA9N,OAAA,GAAAkQ,MAAA,IAGAlR,EAAAyN,KAAAT,cAAAmE,MACAd,MACA,CACAnD,OACAC,OACAC,SACAkC,YAAAlE,GACAgF,OAAA,GACAvB,OACAC,QACAsC,OAAAnC,OAEA,UAAAjP,IAAA,YAAA,CACA,OAAAA,EAEA,GAAAsQ,IAAA,CACA3B,MAAAA,MAAAjM,MAAA,GAAA,EAAA4N,IAAA,GACAzB,OAAAA,OAAAnM,MAAA,GAAA,EAAA4N,KACAxB,OAAAA,OAAApM,MAAA,GAAA,EAAA4N,KAEA3B,MAAAjI,KAAA+G,KAAAV,aAAAqD,OAAA,IAAA,IACAvB,OAAAnI,KAAA2J,MAAA3O,GACAoN,OAAApI,KAAA2J,MAAA9C,IACAgD,SAAAxC,MAAAY,MAAAA,MAAA3N,OAAA,IAAA2N,MAAAA,MAAA3N,OAAA,IACA2N,MAAAjI,KAAA6J,UACA,MACA,KAAA,EACA,OAAA,MAGA,OAAA,OAGA,IAAAc,WAAA,EACA,IAAAlC,MAAA,WACA,IAAAA,MAAA,CACA1D,IAAA,EAEA6C,WAAA,SAAAA,WAAAC,IAAAzG,MACA,GAAA2F,KAAArC,GAAAF,OAAA,CACAuC,KAAArC,GAAAF,OAAAoD,WAAAC,IAAAzG,UACA,CACA,MAAA,IAAAnH,MAAA4N,OAKAiB,SAAA,SAAA/N,MAAA2J,IACAqC,KAAArC,GAAAA,IAAAqC,KAAArC,IAAA,GACAqC,KAAA6D,OAAA7P,MACAgM,KAAA8D,MAAA9D,KAAA+D,WAAA/D,KAAAgE,KAAA,MACAhE,KAAAL,SAAAK,KAAAN,OAAA,EACAM,KAAAP,OAAAO,KAAAiE,QAAAjE,KAAAmD,MAAA,GACAnD,KAAAkE,eAAA,CAAA,WACAlE,KAAAgC,OAAA,CACAqB,WAAA,EACAE,aAAA,EACAD,UAAA,EACAE,YAAA,GAEA,GAAAxD,KAAAmC,QAAAD,OAAA,CACAlC,KAAAgC,OAAAyB,MAAA,CAAA,EAAA,GAEAzD,KAAAmE,OAAA,EACA,OAAAnE,MAIAhM,MAAA,WACA,IAAAoQ,GAAApE,KAAA6D,OAAA,GACA7D,KAAAP,QAAA2E,GACApE,KAAAN,SACAM,KAAAmE,SACAnE,KAAAmD,OAAAiB,GACApE,KAAAiE,SAAAG,GACA,IAAAC,MAAAD,GAAAjB,MAAA,mBACA,GAAAkB,MAAA,CACArE,KAAAL,WACAK,KAAAgC,OAAAsB,gBACA,CACAtD,KAAAgC,OAAAwB,cAEA,GAAAxD,KAAAmC,QAAAD,OAAA,CACAlC,KAAAgC,OAAAyB,MAAA,KAGAzD,KAAA6D,OAAA7D,KAAA6D,OAAA5O,MAAA,GACA,OAAAmP,IAIAE,MAAA,SAAAF,IACA,IAAAvB,IAAAuB,GAAA7Q,OACA,IAAA8Q,MAAAD,GAAAG,MAAA,iBAEAvE,KAAA6D,OAAAO,GAAApE,KAAA6D,OACA7D,KAAAP,OAAAO,KAAAP,OAAA+E,OAAA,EAAAxE,KAAAP,OAAAlM,OAAAsP,KAEA7C,KAAAmE,QAAAtB,IACA,IAAA4B,SAAAzE,KAAAmD,MAAAoB,MAAA,iBACAvE,KAAAmD,MAAAnD,KAAAmD,MAAAqB,OAAA,EAAAxE,KAAAmD,MAAA5P,OAAA,GACAyM,KAAAiE,QAAAjE,KAAAiE,QAAAO,OAAA,EAAAxE,KAAAiE,QAAA1Q,OAAA,GAEA,GAAA8Q,MAAA9Q,OAAA,EAAA,CACAyM,KAAAL,UAAA0E,MAAA9Q,OAAA,EAEA,IAAAhB,EAAAyN,KAAAgC,OAAAyB,MAEAzD,KAAAgC,OAAA,CACAqB,WAAArD,KAAAgC,OAAAqB,WACAC,UAAAtD,KAAAL,SAAA,EACA4D,aAAAvD,KAAAgC,OAAAuB,aACAC,YAAAa,OACAA,MAAA9Q,SAAAkR,SAAAlR,OACAyM,KAAAgC,OAAAuB,aACA,GACAkB,SAAAA,SAAAlR,OAAA8Q,MAAA9Q,QAAAA,OACA8Q,MAAA,GAAA9Q,OACAyM,KAAAgC,OAAAuB,aAAAV,KAGA,GAAA7C,KAAAmC,QAAAD,OAAA,CACAlC,KAAAgC,OAAAyB,MAAA,CAAAlR,EAAA,GAAAA,EAAA,GAAAyN,KAAAN,OAAAmD,KAEA7C,KAAAN,OAAAM,KAAAP,OAAAlM,OACA,OAAAyM,MAIA0E,KAAA,WACA1E,KAAA8D,MAAA,KACA,OAAA9D,MAIA2E,OAAA,WACA,GAAA3E,KAAAmC,QAAAyC,gBAAA,CACA5E,KAAA+D,WAAA,SACA,CACA,OAAA/D,KAAAa,WACA,0BACAb,KAAAL,SAAA,GACA,mIACAK,KAAAiD,eACA,CACAC,KAAA,GACAV,MAAA,KACAvE,KAAA+B,KAAAL,WAIA,OAAAK,MAIA6E,KAAA,SAAApS,GACAuN,KAAAsE,MAAAtE,KAAAmD,MAAAlO,MAAAxC,KAIAqS,UAAA,WACA,IAAAC,KAAA/E,KAAAiE,QAAAO,OACA,EACAxE,KAAAiE,QAAA1Q,OAAAyM,KAAAmD,MAAA5P,QAEA,OACAwR,KAAAxR,OAAA,GAAA,MAAA,IAAAwR,KAAAP,QAAA,IAAAQ,QAAA,MAAA,KAKAC,cAAA,WACA,IAAAC,KAAAlF,KAAAmD,MACA,GAAA+B,KAAA3R,OAAA,GAAA,CACA2R,MAAAlF,KAAA6D,OAAAW,OAAA,EAAA,GAAAU,KAAA3R,QAEA,OAAA2R,KAAAV,OAAA,EAAA,KAAAU,KAAA3R,OAAA,GAAA,MAAA,KAAAyR,QACA,MACA,KAKA/B,aAAA,WACA,IAAAkC,IAAAnF,KAAA8E,YACA,IAAAhS,EAAA,IAAAmI,MAAAkK,IAAA5R,OAAA,GAAAyC,KAAA,KACA,OAAAmP,IAAAnF,KAAAiF,gBAAA,KAAAnS,EAAA,KAIAsS,WAAA,SAAAjC,MAAAkC,cACA,IAAA7C,MAAA6B,MAAAiB,OAEA,GAAAtF,KAAAmC,QAAAyC,gBAAA,CAEAU,OAAA,CACA3F,SAAAK,KAAAL,SACAqC,OAAA,CACAqB,WAAArD,KAAAgC,OAAAqB,WACAC,UAAAtD,KAAAsD,UACAC,aAAAvD,KAAAgC,OAAAuB,aACAC,YAAAxD,KAAAgC,OAAAwB,aAEA/D,OAAAO,KAAAP,OACA0D,MAAAnD,KAAAmD,MACAoC,QAAAvF,KAAAuF,QACAtB,QAAAjE,KAAAiE,QACAvE,OAAAM,KAAAN,OACAyE,OAAAnE,KAAAmE,OACAL,MAAA9D,KAAA8D,MACAD,OAAA7D,KAAA6D,OACAlG,GAAAqC,KAAArC,GACAuG,eAAAlE,KAAAkE,eAAAjP,MAAA,GACA+O,KAAAhE,KAAAgE,MAEA,GAAAhE,KAAAmC,QAAAD,OAAA,CACAoD,OAAAtD,OAAAyB,MAAAzD,KAAAgC,OAAAyB,MAAAxO,MAAA,IAIAoP,MAAAlB,MAAA,GAAAA,MAAA,mBACA,GAAAkB,MAAA,CACArE,KAAAL,UAAA0E,MAAA9Q,OAEAyM,KAAAgC,OAAA,CACAqB,WAAArD,KAAAgC,OAAAsB,UACAA,UAAAtD,KAAAL,SAAA,EACA4D,aAAAvD,KAAAgC,OAAAwB,YACAA,YAAAa,MACAA,MAAAA,MAAA9Q,OAAA,GAAAA,OACA8Q,MAAAA,MAAA9Q,OAAA,GAAA4P,MAAA,UAAA,GAAA5P,OACAyM,KAAAgC,OAAAwB,YAAAL,MAAA,GAAA5P,QAEAyM,KAAAP,QAAA0D,MAAA,GACAnD,KAAAmD,OAAAA,MAAA,GACAnD,KAAAuF,QAAApC,MACAnD,KAAAN,OAAAM,KAAAP,OAAAlM,OACA,GAAAyM,KAAAmC,QAAAD,OAAA,CACAlC,KAAAgC,OAAAyB,MAAA,CAAAzD,KAAAmE,OAAAnE,KAAAmE,QAAAnE,KAAAN,QAEAM,KAAA8D,MAAA,MACA9D,KAAA+D,WAAA,MACA/D,KAAA6D,OAAA7D,KAAA6D,OAAA5O,MAAAkO,MAAA,GAAA5P,QACAyM,KAAAiE,SAAAd,MAAA,GACAX,MAAAxC,KAAAT,cAAAjM,KACA0M,KACAA,KAAArC,GACAqC,KACAqF,aACArF,KAAAkE,eAAAlE,KAAAkE,eAAA3Q,OAAA,IAEA,GAAAyM,KAAAgE,MAAAhE,KAAA6D,OAAA,CACA7D,KAAAgE,KAAA,MAEA,GAAAxB,MAAA,CACA,OAAAA,WACA,GAAAxC,KAAA+D,WAAA,CAEA,IAAA,IAAA/G,KAAAsI,OAAA,CACAtF,KAAAhD,GAAAsI,OAAAtI,GAEA,OAAA,MAEA,OAAA,OAIAkI,KAAA,WACA,GAAAlF,KAAAgE,KAAA,CACA,OAAAhE,KAAAhC,IAEA,IAAAgC,KAAA6D,OAAA,CACA7D,KAAAgE,KAAA,KAGA,IAAAxB,MAAAW,MAAAqC,UAAAC,MACA,IAAAzF,KAAA8D,MAAA,CACA9D,KAAAP,OAAA,GACAO,KAAAmD,MAAA,GAEA,IAAAuC,MAAA1F,KAAA2F,gBACA,IAAA,IAAA/S,EAAA,EAAAA,EAAA8S,MAAAnS,OAAAX,IAAA,CACA4S,UAAAxF,KAAA6D,OAAAV,MAAAnD,KAAA0F,MAAAA,MAAA9S,KACA,GAAA4S,aAAArC,OAAAqC,UAAA,GAAAjS,OAAA4P,MAAA,GAAA5P,QAAA,CACA4P,MAAAqC,UACAC,MAAA7S,EACA,GAAAoN,KAAAmC,QAAAyC,gBAAA,CACApC,MAAAxC,KAAAoF,WAAAI,UAAAE,MAAA9S,IACA,GAAA4P,QAAA,MAAA,CACA,OAAAA,WACA,GAAAxC,KAAA+D,WAAA,CACAZ,MAAA,MACA,aACA,CAEA,OAAA,YAEA,IAAAnD,KAAAmC,QAAAyD,KAAA,CACA,QAIA,GAAAzC,MAAA,CACAX,MAAAxC,KAAAoF,WAAAjC,MAAAuC,MAAAD,QACA,GAAAjD,QAAA,MAAA,CACA,OAAAA,MAGA,OAAA,MAEA,GAAAxC,KAAA6D,SAAA,GAAA,CACA,OAAA7D,KAAAhC,QACA,CACA,OAAAgC,KAAAa,WACA,0BACAb,KAAAL,SAAA,GACA,yBACAK,KAAAiD,eACA,CACAC,KAAA,GACAV,MAAA,KACAvE,KAAA+B,KAAAL,aAOA4C,IAAA,SAAAA,MACA,IAAAhQ,EAAAyN,KAAAkF,OACA,GAAA3S,EAAA,CACA,OAAAA,MACA,CACA,OAAAyN,KAAAuC,QAKAsD,MAAA,SAAAA,MAAAC,WACA9F,KAAAkE,eAAAjL,KAAA6M,YAIAC,SAAA,SAAAA,WACA,IAAAtT,EAAAuN,KAAAkE,eAAA3Q,OAAA,EACA,GAAAd,EAAA,EAAA,CACA,OAAAuN,KAAAkE,eAAA8B,UACA,CACA,OAAAhG,KAAAkE,eAAA,KAKAyB,cAAA,SAAAA,gBACA,GACA3F,KAAAkE,eAAA3Q,QACAyM,KAAAkE,eAAAlE,KAAAkE,eAAA3Q,OAAA,GACA,CACA,OAAAyM,KAAAiG,WACAjG,KAAAkE,eAAAlE,KAAAkE,eAAA3Q,OAAA,IACAmS,UACA,CACA,OAAA1F,KAAAiG,WAAA,WAAAP,QAKAQ,SAAA,SAAAA,SAAAzT,GACAA,EAAAuN,KAAAkE,eAAA3Q,OAAA,EAAA4S,KAAAC,IAAA3T,GAAA,GACA,GAAAA,GAAA,EAAA,CACA,OAAAuN,KAAAkE,eAAAzR,OACA,CACA,MAAA,YAKA4T,UAAA,SAAAA,UAAAP,WACA9F,KAAA6F,MAAAC,YAIAQ,eAAA,SAAAA,iBACA,OAAAtG,KAAAkE,eAAA3Q,QAEA4O,QAAA,GACA5C,cAAA,SAAAC,UACA7B,GACA4I,IACAC,0BACAC,UAEA,IAAAC,QAAAD,SACA,OAAAD,2BACA,KAAA,EACA5C,aACA,OAAA,GACA,MACA,KAAA,EACAA,aACA,OAAA,GACA,MACA,KAAA,EACA,OAAA,GACA,MACA,KAAA,EACA,OAAA,GACA,MACA,KAAA,EACA,OAAA,GACA,MACA,KAAA,EACA,GAAAA,YAAA,EAAA,OAAA,EAEA,MACA,KAAA,EACA,MACA,KAAA,EACA,MACA,KAAA,EACA,OAAA,GACA,MACA,KAAA,EACA,OAAA,EACA,QAGA8B,MAAA,CACA,UACA,UACA,YACA,UACA,SACA,UACA,gBACA,WACA,wBACA,UAEAO,WAAA,CACAU,QAAA,CAAAjB,MAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAAkB,UAAA,QAGA,OAAAlF,MAzZA,GA2ZAjE,OAAAiE,MAAAA,MACA,SAAAmF,SACA7G,KAAArC,GAAA,GAEAkJ,OAAA3L,UAAAuC,OACAA,OAAAoJ,OAAAA,OACA,OAAA,IAAAA,OAnuBA,GAsuBA,UAAA9T,UAAA,oBAAAM,UAAA,YAAA,CACAA,QAAAoK,OAAAV,QACA1J,QAAAwT,OAAA9J,QAAA8J,OACAxT,QAAA2N,MAAA,WACA,OAAAjE,QAAAiE,MAAA0C,MAAA3G,QAAA0E,YAEApO,QAAAyT,KAAA,SAAAC,aAAAvF,MACA,IAAAA,KAAA,GAAA,CACAwF,QAAAC,IAAA,UAAAzF,KAAA,GAAA,SACA0F,QAAAC,KAAA,GAEA,IAAAC,OAAArU,QAAA,MAAAsU,aACAtU,QAAA,QAAAuU,UAAA9F,KAAA,IACA,QAEA,OAAAnO,QAAAoK,OAAAuD,MAAAoG,SAEA,UAAA3T,SAAA,aAAAV,QAAA+T,OAAArT,OAAA,CACAJ,QAAAyT,KAAAI,QAAAK,KAAAtS,MAAA,mOCj0BA,MAAAsG,QAAAxI,QAAA,WAKO,MAAMyU,WAAa,CAACC,GAAc3K,IAAe4K,GACtDD,IAAG,EAAAlM,QAAAoM,KAAI7K,EAAG4K,IADCrU,QAAAmU,WAAUA,WAEhB,MAAMI,YAAc,CAACH,GAAcvK,IAAa3K,GAAYkV,IAAG,EAAAlM,QAAAsM,KAAI3K,EAAG3K,IAAhEc,QAAAuU,YAAWA,YACjB,MAAME,YAAc,CAACL,GAAclV,IAAa2K,GAAYuK,IAAG,EAAAlM,QAAAsM,KAAI3K,EAAG3K,IAAhEc,QAAAyU,YAAWA,YAcjB,MAAMC,SAAYvP,MAA8BmJ,OAAAqG,OAAArG,OAAAqG,OAAA,GAAMxP,KAAKI,OAAK,CAAEJ,KAAAA,OAA5DnF,QAAA0U,SAAQA,o0BCtBrBE,aAAAlV,QAAA,WAAAM,SACA,IAAA6U,QAAAnV,QAAA,WAAS4O,OAAAwG,eAAA9U,QAAA,QAAA,CAAA+U,WAAA,KAAAC,IAAA,WAAA,OAAAzU,gBAAAsU,SAAAxO,WACT,IAAA4O,SAAAvV,QAAA,YAAS4O,OAAAwG,eAAA9U,QAAA,SAAA,CAAA+U,WAAA,KAAAC,IAAA,WAAA,OAAAzU,gBAAA0U,UAAA5O,WACT,IAAA6O,iBAAAxV,QAAA,oBAAS4O,OAAAwG,eAAA9U,QAAA,gBAAA,CAAA+U,WAAA,KAAAC,IAAA,WAAA,OAAAE,iBAAA/R,6LCHT,MAAA1C,QAAAf,QAAA,YACA,MAAAyV,UAAAzV,QAAA,aAEA,MAAAwI,QAAAxI,QAAA,WAIA,MAAMiO,OAAQ,EAAAlN,QAAAkD,OAAM,QAAU8J,MAE5B,MAAMrD,OAAS,IAAI+K,UAAA3B,OAGnB,MAAM4B,KAAoB,GAE1B,MAAMC,MAAgB,GAGtBjL,OAAOE,GAAK,CACVwC,cAAe5E,QAAAoM,IACfvH,iBAAkB7E,QAAAsM,IAClB3H,gBAAiB,CAACpG,KAAc1E,QAC9B,GAAIqT,KAAK3O,MAAO,CACd,MAAM5G,SAAS4G,wBAEjB2O,KAAK3O,MAAQ1E,MAEf6K,kBAAoB7K,OAClBsT,MAAMzP,KAAK7D,OAEbiL,gBAAkBvG,OAAiB,CAAGhB,KAAM,MAAOgB,KAAAA,QAGrD2D,OAAOuD,MAAMF,KAEb4H,MAAMC,QAAQjW,GAAKkW,gBAAgBlW,EAAG+V,OAEtC,MAAMI,SAAW,GACjBlH,OAAOmH,KAAKL,MAAME,QAAQ7O,OACxBiP,eAAejP,KAAM2O,KAAK3O,MAAO2O,KAAMI,YAGzC,MAAO,CAAEJ,KAAAA,KAAMC,MAAAA,SAGjBrV,QAAAqG,QAAesH,MAWf,MAAM4H,gBAAkB,CACtBlW,EACA+V,KACAO,WAAuB,MAEvB,OAAQtW,EAAEoG,MACR,IAAK,MACH,MAAMmQ,KAAOD,WAAWvO,QAAQ/H,EAAEoH,MAAQ,EAC1C,GAAIpH,EAAEoH,QAAQ2O,MAAQQ,KAAM,CAC1BtH,OAAOqG,OAAOtV,EAAG,CAAEoG,KAAM,MAAO1D,KAAMqT,KAAK/V,EAAEoH,YACxC,CACL6H,OAAOqG,OAAOtV,EAAG,CAAEoG,KAAM,QAE3B,MACF,IAAK,MACH8P,gBAAgBlW,EAAEiJ,KAAM8M,KAAMO,YAC9BJ,gBAAgBlW,EAAEkJ,MAAO6M,KAAMO,YAC/B,MACF,IAAK,MACHJ,gBAAgBlW,EAAEoJ,KAAM2M,KAAMO,WAAWrF,OAAOjR,EAAEmJ,QAClD,QAON,MAAMkN,eAAiB,CACrBG,QACAxW,EACA+V,KACAI,SACAG,WAAuB,MAEvB,OAAQtW,EAAEoG,MACR,IAAK,MACH,MAAMqQ,MAAQH,WAAWvO,QAAQ/H,EAAEoH,OAAS,EAC5C,GAAIqP,MAAO,CACTxH,OAAOqG,OAAOtV,EAAG,CAAEoG,KAAM,aACpB,GAAIpG,EAAEoH,QAAQ2O,KAAM,CACzBI,SAASK,SAAW,IAAKL,SAASK,UAAY,GAAKxW,EAAEoH,MACrDsP,qBAAqBF,QAASxW,EAAEoH,KAAM+O,UACtClH,OAAOqG,OAAOtV,EAAG,CAAEoG,KAAM,MAAO1D,KAAMqT,KAAK/V,EAAEoH,YACxC,CACL,MAAM5G,OACJ,EAAAY,QAAAuV,8CAC4B3W,EAAEoH,aAAaoP,gEAK/C,MACF,IAAK,MACHH,eAAeG,QAASxW,EAAEiJ,KAAM8M,KAAMI,SAAUG,YAChDD,eAAeG,QAASxW,EAAEkJ,MAAO6M,KAAMI,SAAUG,YACjD,MACF,IAAK,MACH,MAAMM,YAAcN,WAAWrF,OAAOjR,EAAEmJ,OACxCkN,eAAeG,QAASxW,EAAEoJ,KAAM2M,KAAMI,SAAUS,aAChD,QAIN,MAAMF,qBAAuB,CAC3BtP,KACAyP,QACAV,SACAW,KAAiB,MAEjB,GAAI1P,OAASyP,QAAS,CACpB,MAAME,aAAeD,KAAKjW,mHAEO,CAACuG,QAAS0P,KAAM1P,MAAM9D,KAAK,UACxD,GACJ,MAAM9C,OACJ,EAAAY,QAAAuV,uDACqCvP,+GAEnC2P,8FAMN,MAAMC,SAAWb,SAASU,UAAY,GACtCG,SAASf,QAAQgB,SACfP,qBAAqBtP,KAAM6P,QAASd,SAAU,IAAIW,KAAMD,6SC7I5D,MAAAzV,QAAAf,QAAA,YACA,MAAA6W,WAAAhW,gBAAAb,QAAA,eACA,MAAAuV,SAAA1U,gBAAAb,QAAA,aAEA,MAAAmV,QAAAtU,gBAAAb,QAAA,YACA,MAAA8W,SAAAjW,gBAAAb,QAAA,aACA,MAAAuI,aAAAvI,QAAA,gBACA,MAAAwI,QAAAxI,QAAA,WA+BO,MAAMyD,cAAgB,CAACuH,QAAiBoE,QAAmB,MAChE,MAAMuG,MAAEA,MAAKD,KAAEA,OAAS,EAAAP,QAAAxO,SAAMqE,SAC9B,OAAO2K,MAAMxR,IAAI9B,MAAQ0U,WAAW1U,KAAMqT,KAAMtG,WAFrC9O,QAAAmD,cAAaA,cAM1B,IAAIsT,WAAa,CACf1U,KACAqT,MACEvS,kBAAAA,kBAAoB,IAAKE,SAAAA,SAAW,SAAUC,WAAAA,WAAa,UAE7D,MAAM0T,OAAS,GACf,MAAMxR,MAAgB,GACtB,IAAIF,eAAiB,EACrB,IAAI2R,WAAa,MACjB,KACE,EAAAH,SAAAnQ,SAAOtE,KAAM,CAAEgB,SAAAA,SAAUC,WAAAA,YAAc4T,WACrC,GAAI5R,gBAAkBnC,kBAAmB,CACvC,MAAM6T,OAERxR,MAAMU,KAAKgR,UAKX,MAAMzR,KAAO0R,SAASD,UACtB,IAAKzR,KAAM,CACT,MAAM,IAAItF,MAAM,8CAElB,GAAIsF,KAAKM,OAAS,QAAUN,KAAKM,OAAS,MAAO,CAC/CT,gBAAkB,KAGtB2R,WAAa,KACb,MAAOxX,GACP,GAAIA,IAAMuX,OAAQ,CAChB,MAAMvX,EAERwX,WAAa,MAGf,MAAMG,KAAO5R,MAAMA,MAAMhF,OAAS,IAAM6B,KACxC,MAAO,CACL8C,SAAS,EAAAoQ,SAAA5O,SAAOtE,MAChBgD,OAAO,EAAAkQ,SAAA5O,SAAOyQ,MACd7R,cAAe8R,aAAaD,KAAM1B,MAClCuB,WAAAA,WACA3R,eAAAA,eACAZ,WAAYc,MAAMhF,OAClBkF,WAAY,CAAC7F,EAAGuP,UAAYkI,WAAW9R,MAAM3F,GAAIuP,WAGrD2H,YAAa,EAAAhW,QAAAkD,OAAM,SAAU8S,YAE7B,MAAMO,WAAa,CAAC3X,EAASyP,QAA6B,MACxD,MAAM3J,KAAO0R,SAASxX,GACtB,IAAK8F,KAAM,CACT,MAAM,IAAItF,MAAM,8CAGlB,IAAIyF,OAAeH,KAAKG,OACxB,IAAIC,MAAcJ,KAAKI,MAEvB,MAAMQ,oBACJA,oBAAsBtF,QAAAwI,SAAQjD,0BAC9BA,0BAA4BvF,QAAAwI,SAAQpD,cACpCA,cAAgBpF,QAAAwI,UACd6F,QAEJ,OAAQ3J,KAAKM,MACX,IAAK,QACHH,OAAS2R,qBACP9R,KAAKG,OAAOmD,KACZtD,KAAKG,OAAOkD,MACZzC,qBAEFR,MAAQ0R,qBACN9R,KAAKI,MAAMkD,KACXtD,KAAKI,MAAMiD,MACXxC,2BAEF,MACF,IAAK,OACH,MAAMkR,IAAM/R,KAAKG,OAAOgD,KACxB,MAAM6O,GAAKpO,UAAU5D,KAAKG,OAAOiD,MAAOvC,2BACxC,MAAMoR,GAAKH,qBAAqBC,IAAIzO,KAAMyO,IAAI1O,MAAOzC,qBACrDT,QAAS,EAAA4C,QAAAsM,KAAI4C,GAAID,IACjB5R,OAAQ,EAAA0C,aAAAS,YAAWwO,IAAIzO,KAAMyO,IAAI1O,MAAO2O,IACxC,MACF,IAAK,MACL,IAAK,MACH7R,OAASyD,UAAU5D,KAAKG,OAAQS,qBAChCR,MAAQwD,UAAU5D,KAAKI,MAAOS,2BAC9B,MAGJV,OAASyD,UAAUzD,OAAQO,eAC3BN,MAAQwD,UAAUxD,MAAOM,eAEzB,MAAMwR,WAAY,EAAApC,SAAA5O,SAAOiR,YAAYjY,EAAGiG,SACxC,MAAMiS,UAAW,EAAAtC,SAAA5O,SAAOiR,YAAYjY,EAAGkG,QAEvC,MAAO,CAAEE,KAAMN,KAAKM,KAAMH,OAAQ+R,UAAW9R,MAAOgS,WAGtD,MAAMxO,UAAY,CAAC1J,EAAS+U,MAC1B,MAAMpL,EAAa3J,EAAU0J,UAC7B,MAAMA,UAAoBC,EAAIlD,GAAKsO,GAAGpL,EAAElD,IAAMsO,GAC9C,OAAA9F,OAAAqG,OAAArG,OAAAqG,OAAA,GAAYtV,GAAC,CAAE0J,UAAAA,aAGjB,MAAMkO,qBAAuB,CAAC5X,EAASoK,EAAW2K,MAChD,MAAMoD,GAAKzO,WAAU,EAAAb,QAAAS,KAAIc,GAAI2K,IAC7B,MAAMqD,IAAK,EAAAxP,aAAAS,YAAWrJ,EAAGoK,EAAG+N,IAC5B,OAAAlJ,OAAAqG,OAAArG,OAAAqG,OAAA,IAAY,EAAAzM,QAAAoM,KAAI7K,EAAGgO,KAAG,CAAEvO,aAAckL,MAGxC,MAAMyC,SAAYxX,IAChB,GAAI,SAAUA,EAAG,CACf,OAAOA,EAAE8F,KAGX,OAAQ9F,EAAEoG,MACR,IAAK,MACH,OAAOoR,SAASxX,EAAEoJ,MACpB,IAAK,MACH,OAAOoO,SAASxX,EAAEiJ,OAASuO,SAASxX,EAAEkJ,SAI5C,MAAM+O,YAAc,CAACjY,EAAyBqY,eAC5C,GAAI,SAAUrY,GAAKA,EAAE8F,KAAM,CACzB,OAAOuS,YAGT,OAAQrY,EAAEoG,MACR,IAAK,MACL,IAAK,MACH,OAAOpG,EACT,IAAK,MACH,MAAMoJ,KAAO6O,YAAYjY,EAAEoJ,KAAMiP,aACjC,OAAOrY,EAAEoJ,OAASA,KAAOpJ,GAAI,EAAA6I,QAAAoM,KAAIjV,EAAEmJ,MAAOC,MAC5C,IAAK,MACH,MAAMoB,EAAIyN,YAAYjY,EAAEiJ,KAAMoP,aAC9B,GAAIrY,EAAEiJ,OAASuB,EAAG,CAChB,OAAO,EAAA3B,QAAAsM,KAAI3K,EAAGxK,EAAEkJ,OAElB,MAAMrJ,EAAIoY,YAAYjY,EAAEkJ,MAAOmP,aAC/B,OAAOrY,EAAEkJ,QAAUrJ,EAAIG,GAAI,EAAA6I,QAAAsM,KAAI3K,EAAG3K,KAIxC,MAAM6X,aAAe,CAAChV,KAAYqT,QAChC,MAAM1S,SAAW,GACjB,IAAK,MAAM+D,QAAQ2O,KAAM,CACvB,IAAI,EAAAmB,WAAAlQ,SAAQtE,KAAMqT,KAAK3O,OAAQ,CAC7B/D,SAASkD,KAAKa,OAGlB,OAAO/D,yUCrMT,MAAAiV,UAAApX,gBAAAb,QAAA,cACA,MAAAkY,UAAAlY,QAAA,aAOA,MAAAuI,aAAAvI,QAAA,gBACA,MAAAwI,QAAAxI,QAAA,WAOA,MAAMmY,OAAS,CAACxY,GAAW0D,SAAAA,SAAUC,WAAAA,YAAuB8U,MAC1D,MAAMC,QAAUC,gBAAgBjV,UAChC,IAAIkV,QAAUF,QAAQ1Y,EAAGyY,IACzB,GAAI9U,WAAY,CACdiV,QAAUC,UAAUD,QAASH,IAE/B,OAAOG,SAGTjY,QAAAqG,QAAewR,OAIf,MAAMM,iBAA4B,CAAC9Y,EAAGyY,MACpC,OAAQzY,EAAEoG,MACR,IAAK,MACL,IAAK,MACH,OAAOpG,EACT,IAAK,MACH,MAAMwK,EAAIsO,iBAAiB9Y,EAAEiJ,MAAM,EAAAsP,UAAAnD,aAAYqD,GAAIzY,EAAEkJ,QACrD,OAAOsB,EAAEpE,OAAS,MACd0S,iBAAiB9H,MAAMxG,EAAGxK,EAAEkJ,MAAOuP,IAAKA,KACxC,EAAA5P,QAAAsM,KAAI3K,EAAGxK,EAAEkJ,OACf,IAAK,MACHuP,IAAG,EAAAF,UAAAlD,UAAS,CAAEjP,KAAM,MAAOH,OAAQjG,EAAGkG,MAAOlG,EAAE0C,QAC/C,OAAOoW,iBAAiB9Y,EAAE0C,KAAM+V,MAItC,MAAMM,aAAwB,CAAC/Y,EAAGyY,MAChC,OAAQzY,EAAEoG,MACR,IAAK,MACH,OAAOpG,EACT,IAAK,MACH,OAAO,EAAA6I,QAAAoM,KAAIjV,EAAEmJ,MAAO4P,aAAa/Y,EAAEoJ,MAAM,EAAAmP,UAAAzD,YAAW2D,GAAIzY,EAAEmJ,SAC5D,IAAK,MACH,IAAIqB,EAAIsO,iBAAiB9Y,EAAEiJ,MAAM,EAAAsP,UAAAnD,aAAYqD,GAAIzY,EAAEkJ,QACnD,GAAIsB,EAAEpE,OAAS,MAAO,CACpB,OAAO2S,aAAa/H,MAAMxG,EAAGxK,EAAEkJ,MAAOuP,IAAKA,QACtC,CACLjO,EAAIuO,aAAavO,GAAG,EAAA+N,UAAAnD,aAAYqD,GAAIzY,EAAEkJ,QACtC,MAAMrJ,EAAIkZ,aAAa/Y,EAAEkJ,OAAO,EAAAqP,UAAArD,aAAYuD,GAAIjO,IAChD,OAAO,EAAA3B,QAAAsM,KAAI3K,EAAG3K,GAElB,IAAK,MACH4Y,IAAG,EAAAF,UAAAlD,UAAS,CAAEjP,KAAM,MAAOH,OAAQjG,EAAGkG,MAAOlG,EAAE0C,QAC/C,OAAOqW,aAAa/Y,EAAE0C,KAAM+V,MAIlC,MAAMO,kBAA6B,CAAChZ,EAAGyY,MACrC,OAAQzY,EAAEoG,MACR,IAAK,MACL,IAAK,MACH,OAAOpG,EACT,IAAK,MACH,MAAMwK,EAAIwO,kBAAkBhZ,EAAEiJ,MAAM,EAAAsP,UAAAnD,aAAYqD,GAAIzY,EAAEkJ,QACtD,MAAMrJ,EAAImZ,kBAAkBhZ,EAAEkJ,OAAO,EAAAqP,UAAArD,aAAYuD,GAAIjO,IACrD,OAAOA,EAAEpE,OAAS,MACd4S,kBAAkBhI,MAAMxG,EAAG3K,EAAG4Y,IAAKA,KACnC,EAAA5P,QAAAsM,KAAI3K,EAAG3K,GACb,IAAK,MACH4Y,IAAG,EAAAF,UAAAlD,UAAS,CAAEjP,KAAM,MAAOH,OAAQjG,EAAGkG,MAAOlG,EAAE0C,QAC/C,OAAOsW,kBAAkBhZ,EAAE0C,KAAM+V,MAIvC,MAAMQ,kBAA6B,CAACjZ,EAAGyY,MACrC,OAAQzY,EAAEoG,MACR,IAAK,MACH,OAAOpG,EACT,IAAK,MACH,OAAO,EAAA6I,QAAAoM,KAAIjV,EAAEmJ,MAAO8P,kBAAkBjZ,EAAEoJ,MAAM,EAAAmP,UAAAzD,YAAW2D,GAAIzY,EAAEmJ,SACjE,IAAK,MACH,IAAIqB,EAAIwO,kBAAkBhZ,EAAEiJ,MAAM,EAAAsP,UAAAnD,aAAYqD,GAAIzY,EAAEkJ,QACpD,GAAIsB,EAAEpE,OAAS,MAAO,CACpB,MAAMvG,EAAImZ,kBAAkBhZ,EAAEkJ,OAAO,EAAAqP,UAAArD,aAAYuD,GAAIjO,IACrD,OAAOyO,kBAAkBjI,MAAMxG,EAAG3K,EAAG4Y,IAAKA,QACrC,CACLjO,EAAIyO,kBAAkBzO,GAAG,EAAA+N,UAAAnD,aAAYqD,GAAIzY,EAAEkJ,QAC3C,MAAMrJ,EAAIoZ,kBAAkBjZ,EAAEkJ,OAAO,EAAAqP,UAAArD,aAAYuD,GAAIjO,IACrD,OAAO,EAAA3B,QAAAsM,KAAI3K,EAAG3K,GAElB,IAAK,MACH4Y,IAAG,EAAAF,UAAAlD,UAAS,CAAEjP,KAAM,MAAOH,OAAQjG,EAAGkG,MAAOlG,EAAE0C,QAC/C,OAAOuW,kBAAkBjZ,EAAE0C,KAAM+V,MAIvC,MAAMzH,MAAQ,CAAC6G,IAAUqB,MAAaT,MACpC,MAAMU,UAAW,EAAAZ,UAAAzD,aAAW,EAAAyD,UAAAnD,aAAYqD,GAAIS,OAAQrB,IAAI1O,OACxD,MAAMiQ,aAAc,EAAAxQ,aAAAyQ,uBAClBxB,IAAIzO,KACJyO,IAAI1O,MACJ+P,MACAC,UAEF,MAAMG,SAAU,EAAAzQ,QAAAsM,MAAI,EAAAtM,QAAAoM,KAAI4C,IAAI1O,MAAOiQ,aAAcF,OACjD,MAAMK,SAAU,EAAA3Q,aAAA4Q,mBAAkBJ,YAAavB,IAAI1O,MAAO+P,OAC1DT,IAAG,EAAAF,UAAAlD,UAAS,CAAEjP,KAAM,OAAQH,OAAQqT,QAASpT,MAAOqT,WACpD,OAAOA,SAIT,MAAMV,UAAqB,CAAC7Y,EAAGyY,MAC7B,OAAQzY,EAAEoG,MACR,IAAK,MACH,OAAOpG,EACT,IAAK,MAEH,GACEA,EAAEoJ,KAAKhD,OAAS,OAChBpG,EAAEoJ,KAAKF,MAAM9C,OAAS,OACtBpG,EAAEoJ,KAAKF,MAAM9B,OAASpH,EAAEmJ,SACvB,EAAAmP,UAAAtR,SAAOhH,EAAEmJ,MAAOnJ,EAAEoJ,KAAKH,MACxB,CACAwP,IAAG,EAAAF,UAAAlD,UAAS,CAAEjP,KAAM,MAAOH,OAAQjG,EAAGkG,MAAOlG,EAAEoJ,KAAKH,QACpD,OAAOjJ,EAAEoJ,KAAKH,SACT,CACL,OAAO,EAAAJ,QAAAoM,KAAIjV,EAAEmJ,MAAO0P,UAAU7Y,EAAEoJ,MAAM,EAAAmP,UAAAzD,YAAW2D,GAAIzY,EAAEmJ,SAE3D,IAAK,MACH,MAAMqB,EAAIqO,UAAU7Y,EAAEiJ,MAAM,EAAAsP,UAAAnD,aAAYqD,GAAIzY,EAAEkJ,QAC9C,MAAMrJ,EAAIgZ,UAAU7Y,EAAEkJ,OAAO,EAAAqP,UAAAnD,aAAYqD,GAAIjO,IAC7C,OAAO,EAAA3B,QAAAsM,KAAI3K,EAAG3K,GAChB,IAAK,MACH,OAAOG,IAIb,MAAM2Y,gBAAkB,CACtBc,OAAQV,aACRW,YAAaT,kBACbU,IAAKb,iBACLc,IAAKZ,2XCtJP,MAAAV,UAAApX,gBAAAb,QAAA,cACA,MAAAkY,UAAAlY,QAAA,aAOA,MAAAwI,QAAAxI,QAAA,WAIO,MAAMgJ,WAAa,CAACrJ,EAASoK,EAAW3D,KAC7C,OAAQzG,EAAEoG,MACR,IAAK,MAGH,OAAOpG,EAAEoH,OAASgD,EAAI3D,EAAIzG,EAC5B,IAAK,MAGH,GAAIA,EAAEmJ,QAAUiB,EAAG,CACjB,OAAOpK,EAKT,IAAI,EAAAsY,UAAAtR,SAAOhH,EAAEmJ,MAAO1C,KAAM,EAAA6R,UAAAtR,SAAOoD,EAAGpK,EAAEoJ,MAAO,CAE3C,MAAMyQ,WAAaC,UAAU9Z,EAAEmJ,MAAOnJ,EAAEoJ,KAAM3C,GAC9C,MAAM2S,aAAc,EAAAzY,QAAA6Y,mBAAkBxZ,EAAEoJ,KAAMpJ,EAAEmJ,OAAO,EAAAN,QAAAS,KAAIuQ,aAC3D,OAAO,EAAAhR,QAAAoM,KAAI4E,YAAY,EAAAlZ,QAAA0I,YAAW+P,YAAahP,EAAG3D,QAC7C,CAEL,OAAO,EAAAoC,QAAAoM,KAAIjV,EAAEmJ,OAAO,EAAAxI,QAAA0I,YAAWrJ,EAAEoJ,KAAMgB,EAAG3D,IAE9C,IAAK,MAEH,OAAO,EAAAoC,QAAAsM,MAAI,EAAAxU,QAAA0I,YAAWrJ,EAAEiJ,KAAMmB,EAAG3D,IAAI,EAAA9F,QAAA0I,YAAWrJ,EAAEkJ,MAAOkB,EAAG3D,IAC9D,IAAK,MACH,OAAOzG,IA5BAW,QAAA0I,WAAUA,WAwChB,MAAMgQ,sBAAwB,CACnCrZ,EACAoK,EACA3D,EACAgS,MAEA,OAAQzY,EAAEoG,MACR,IAAK,MACL,IAAK,MACH,OAAOpG,EACT,IAAK,MACH,GAAIA,EAAEmJ,QAAUiB,EAAG,CACjB,OAAOpK,EAET,IAAI,EAAAsY,UAAAtR,SAAOhH,EAAEmJ,MAAO1C,KAAM,EAAA6R,UAAAtR,SAAOoD,EAAGpK,EAAEoJ,MAAO,CAC3C,MAAMyQ,WAAaC,UAAU9Z,EAAEmJ,MAAOnJ,EAAEoJ,KAAM3C,GAC9C,MAAM2S,aAAc,EAAAzY,QAAA6Y,mBAAkBxZ,EAAEoJ,KAAMpJ,EAAEmJ,OAAO,EAAAN,QAAAS,KAAIuQ,aAC3DpB,IACE,EAAAF,UAAAlD,UAAS,CACPjP,KAAM,QACNH,OAAQjG,EACRkG,MAAQlG,GAAI,EAAA6I,QAAAoM,KAAI4E,WAAYT,gBAIlC,MAAMhQ,MAAO,EAAAzI,QAAA0Y,uBAAsBrZ,EAAEoJ,KAAMgB,EAAG3D,GAAG,EAAA8R,UAAAzD,YAAW2D,GAAIzY,EAAEmJ,QAClE,OAAO,EAAAN,QAAAoM,KAAIjV,EAAEmJ,MAAOC,MACtB,IAAK,MACH,MAAMoB,GAAI,EAAA7J,QAAA0Y,uBAAsBrZ,EAAEiJ,KAAMmB,EAAG3D,GAAG,EAAA8R,UAAAnD,aAAYqD,GAAIzY,EAAEkJ,QAChE,MAAMrJ,GAAI,EAAAc,QAAA0Y,uBAAsBrZ,EAAEkJ,MAAOkB,EAAG3D,GAAG,EAAA8R,UAAArD,aAAYuD,GAAIjO,IAC/D,OAAO,EAAA3B,QAAAsM,KAAI3K,EAAG3K,KA9BPc,QAAA0Y,sBAAqBA,sBAmC3B,MAAMG,kBAAoB,CAACxZ,EAASoK,EAAW3D,KACpD,OAAQzG,EAAEoG,MACR,IAAK,MACH,OAAOpG,EAAEoH,OAASgD,EAAI3D,EAAIzG,EAC5B,IAAK,MACH,OAAOA,EAAEmJ,QAAUiB,EAAIpK,GAAI,EAAA6I,QAAAoM,KAAIjV,EAAEmJ,OAAO,EAAAxI,QAAA6Y,mBAAkBxZ,EAAEoJ,KAAMgB,EAAG3D,IACvE,IAAK,MACH,MAAM+D,GAAI,EAAA7J,QAAA6Y,mBAAkBxZ,EAAEiJ,KAAMmB,EAAG3D,GACvC,MAAM5G,GAAI,EAAAc,QAAA6Y,mBAAkBxZ,EAAEkJ,MAAOkB,EAAG3D,GACxC,OAAO,EAAAoC,QAAAsM,KAAI3K,EAAG3K,GAChB,IAAK,MACH,OAAOG,IAXAW,QAAA6Y,kBAAiBA,kBAgB9B,MAAMM,UAAY,CAACC,QAAiB/Z,EAASyG,KAE3C,MAAMuT,KAAOD,QAAQzH,QAAQ,OAAQ,IACrC,MAAM7B,MAAQsJ,QAAQtJ,MAAM,QAC5B,IAAI1Q,EAAI0Q,MAAQhN,SAASgN,MAAM,GAAI,IAAM,EAEzC,MAAO,KAAM,CACX1Q,IACA,MAAMka,QAAUD,KAAOja,EACvB,MAAMma,UAEH,EAAA5B,UAAAtR,SAAOiT,QAASxT,MAEhB,EAAA6R,UAAAtR,SAAOiT,QAASja,KAEhBma,kBAAkBna,EAAG+Z,QAASE,SAEjC,GAAIC,QAAS,CACX,OAAOD,WAQb,MAAME,kBAAoB,CACxBna,EACA+Z,QACAE,WAEA,OAAQja,EAAEoG,MACR,IAAK,MACL,IAAK,MACH,OAAO,MACT,IAAK,MAKH,OACGpG,EAAEmJ,QAAU8Q,UAAW,EAAA3B,UAAAtR,SAAO+S,QAAS/Z,IAExCma,kBAAkBna,EAAEoJ,KAAM2Q,QAASE,SAEvC,IAAK,MACH,OACEE,kBAAkBna,EAAEiJ,KAAM8Q,QAASE,UACnCE,kBAAkBna,EAAEkJ,MAAO6Q,QAASE,0NChJ5C,MAAM3Q,IAAOlC,OAAsB,CAAGhB,KAAM,MAAOgB,KAAAA,OAKpCzG,QAAA2I,IAAAA,IAJf,MAAM2L,IAAM,CAAC9L,MAAeC,QAAoB,CAAGhD,KAAM,MAAO+C,MAAAA,MAAOC,KAAAA,OAInDzI,QAAAsU,IAAAA,IAHpB,MAAME,IAAM,CAAClM,KAAYC,SAAqB,CAAG9C,KAAM,MAAO6C,KAAAA,KAAMC,MAAAA,QAG3CvI,QAAAwU,IAAAA,IAFzB,MAAMiF,IAAM,CAAChT,KAAc1E,QAAoB,CAAG0D,KAAM,MAAOgB,KAAAA,KAAM1E,KAAAA,OAEvC/B,QAAAyZ,IAAAA,uPCZ9B,IAAIC,WAAa,MAEV,MAAM/V,MAAQ,CACnB8C,KACA2N,KACG,IAAIjG,QACP,GAAIuL,WAAY,CACd/F,QAAQgG,KAAKlT,MAEf,MAAMmT,IAAMxF,MAAMjG,MAClB,GAAIuL,WAAY,CACd/F,QAAQkG,QAAQpT,MAElB,OAAOmT,KAXI5Z,QAAA2D,MAAKA,MAcX,MAAMjD,iBAAmB,KAC9BgZ,WAAa,MADF1Z,QAAAU,iBAAgBA,iBAGtB,MAAMoZ,kBAAoB,KAC/BJ,WAAa,OADF1Z,QAAA8Z,kBAAiBA,kBAIvB,MAAM7Q,SAAeQ,GAASA,EAAxBzJ,QAAAiJ,SAAQA,SAId,MAAMhD,OAAUwH,MACrB,MAAMqC,MAAQrC,IAAIqC,MAAM,mBACxB,IAAKA,MAAO,CACV,OAAOrC,IAGT,MAAMsM,OAASjH,KAAKkH,OAAOlK,MAAMjM,IAAI4F,GAAKA,EAAEvJ,SAC5C,MAAM+Z,GAAK,IAAIC,kBAAkBH,UAAW,MAC5C,MAAMI,WAAaJ,OAAS,EAAItM,IAAIkE,QAAQsI,GAAI,IAAMxM,IAEtD,OAAO0M,WAAWC,QAVPpa,QAAAiG,OAAMA,OAaZ,MAAM+P,mBAAsBvI,KAAgBA,IAAIkE,QAAQ,QAAS,KAA3D3R,QAAAgW,mBAAkBA","sourceRoot":".","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","// Script for index.html\nimport { $, delegate, nodeIndex } from './dom'\nimport examples from './examples'\nimport { Options, reduceProgram, Reduction } from './lambda'\nimport { dedent, enableLogTimings, timed } from './utils'\n\nenableLogTimings()\n\nconst input = $('.input') as HTMLInputElement\nconst output = $('.output')\n\n// Run code on ctrl+enter.\ndocument.addEventListener('keyup', e => {\n  if (e.keyCode === 13 && e.ctrlKey) {\n    run()\n  }\n})\n\ninput.addEventListener('keypress', event => {\n  // Replace every \"\\\" with \"Î»\" while typing.\n  if (event.key === '\\\\') {\n    event.preventDefault()\n    const start = input.selectionStart || 0\n    const end = input.selectionEnd || 0\n    const oldValue = input.value\n\n    input.value = oldValue.slice(0, start) + 'Î»' + oldValue.slice(end)\n\n    // Update selection\n    input.selectionStart = input.selectionEnd = start + 1\n  }\n})\n\n$('.run').addEventListener('click', _ => run())\n\nconst renderTerm = (term: string, className = '') =>\n  `<span class=\"term ${className}\">${term}</span>`\n\nconst renderArrow = (symbol: string, label: string) =>\n  `<span class=arrow>${symbol}<small>${label}</small></span>`\n\nconst arrowSymbols = {\n  alpha: 'Î±',\n  beta: 'Î²',\n  eta: 'Î·',\n  def: ''\n}\n\nconst renderSynonyms = (synonyms: string[]) =>\n  synonyms.length ? `<span class=synonyms>(${synonyms.join(', ')})</span>` : ''\n\nconst getOptions = (): Options => {\n  const maxReductionSteps = parseInt(\n    $<HTMLInputElement>('input[name=max-steps]').value || '0',\n    10\n  )\n  const strategy = $<HTMLInputElement>('input[name=strategy]:checked')\n    .value as Options['strategy']\n  const etaEnabled = $<HTMLInputElement>('[name=eta-reductions]').checked\n  return { maxReductionSteps, strategy, etaEnabled }\n}\n\nlet reductions: Reduction[] = []\nconst run = () => {\n  const code = input.value\n  try {\n    reductions = reduceProgram(code, getOptions())\n    renderReductions()\n  } catch (err) {\n    output.textContent = err instanceof Error ? err.message : String(err)\n    output.classList.add('error')\n  }\n}\n\nconst renderReductions = timed('render html', () => {\n  output.innerHTML = reductions.map(renderCollapsedReduction).join('')\n  output.classList.remove('error')\n})\n\ndelegate('click', output, '.reduction', element => {\n  const reduction = reductions[nodeIndex(element)]\n  if (reduction.totalSteps === 0) {\n    return\n  }\n  const expanded = element.querySelector('.expanded')\n  const collapsed = element.querySelector('.collapsed')\n  if (expanded) {\n    expanded.classList.toggle('hidden')\n    collapsed!.classList.toggle('hidden')\n  } else {\n    collapsed!.classList.add('hidden')\n    element.innerHTML += renderExpandedReductionForm(reduction)\n  }\n})\n\ndelegate('mouseover', output, '.expanded .step', element => {\n  element.classList.add('highlight')\n  // Hide the previous step's after term.\n  const prev = element.previousElementSibling\n  if (prev) {\n    prev.querySelector('.after')!.classList.add('hidden')\n  }\n})\n\ndelegate('mouseout', output, '.expanded .step', element => {\n  element.classList.remove('highlight')\n  const prev = element.previousElementSibling\n  if (prev) {\n    prev.querySelector('.after')!.classList.remove('hidden')\n  }\n})\n\nconst renderCollapsedReduction = (reduction: Reduction) =>\n  `<div class=reduction>${renderCollapsedReductionForm(reduction)}</div>`\n\nconst renderCollapsedReductionForm = (reduction: Reduction) => {\n  const initial = renderTerm(reduction.initial)\n  let arrow = ''\n  let final = ''\n  if (reduction.reductionSteps > 0) {\n    arrow = renderArrow('â', `(${reduction.reductionSteps})`)\n    final = renderTerm(reduction.final)\n  }\n  const synonyms = renderSynonyms(reduction.finalSynonyms)\n  return `<div class=collapsed>${initial} ${arrow} ${final} ${synonyms}</div>`\n}\n\nconst renderExpandedReductionForm = (reduction: Reduction) => {\n  const steps = []\n  for (let i = 0; i < reduction.totalSteps; i++) {\n    const step = reduction.renderStep(i, renderStepOptions)\n    const before = renderTerm(step.before, 'before')\n    const after = renderTerm(step.after, 'after')\n    const arrowSymbol = step.type === 'def' ? 'â¡' : 'â'\n    const arrowLabel = arrowSymbols[step.type]\n    const arrow = renderArrow(arrowSymbol, arrowLabel)\n    const lastStep = i === reduction.totalSteps - 1\n    const synonyms = lastStep ? renderSynonyms(reduction.finalSynonyms) : ''\n    steps.push(\n      `<span class=step>${before}<br>${arrow} ${after} ${synonyms}</span>`\n    )\n  }\n\n  return `<div class=expanded>${steps.join('')}</div>`\n}\n\nconst renderStepOptions = {\n  highlightStep: (s: string) => `<span class=match>${s}</span>`,\n  highlightFormerTerm: (s: string) => `<span class=former-term>${s}</span>`,\n  highlightSubstitutionTerm: (s: string) => `<span class=subst-term>${s}</span>`\n}\n\ninput.value = dedent(`\n  ; Write some Î»-expressions here and hit Run. Use \"\\\\\" to enter \"Î»\" ;)\n  (Î»x.Î»y.Î»z.z y x) a b c\n`)\ninput.focus()\n\nconst examplesMenu = $('.examples-menu')\nconst examplesHtml = examples.map((example, i) => {\n  const href = encodeURI(`#>${example.code}`)\n  return `<li><a href=\"${href}\">${i} - ${example.name}</a></li>`\n})\n\nexamplesMenu.innerHTML = examplesHtml.join('')\ndelegate('click', examplesMenu, 'li', (element, event) => {\n  event.preventDefault() // Don't change the location.hash\n  input.value = examples[nodeIndex(element)].code\n  input.scrollTop = 0\n})\n\nconst examplesDropdown = $('.examples-dropdown')\nexamplesDropdown.addEventListener('click', e => {\n  if (examplesDropdown.classList.contains('active')) {\n    return\n  }\n  e.stopPropagation()\n  examplesDropdown.classList.add('active')\n  document.addEventListener(\n    'click',\n    () => {\n      examplesDropdown.classList.remove('active')\n    },\n    { once: true }\n  )\n})\n\n$('button.link').addEventListener('click', () => {\n  const code = input.value\n  location.hash = `>${code}`\n})\n\nconst updateInputFromHash = () => {\n  const hash = decodeURI(location.hash)\n  const codeStart = hash.indexOf('>')\n  if (codeStart >= 0) {\n    input.value = hash.slice(codeStart + 1)\n  }\n}\n\nwindow.addEventListener('hashchange', updateInputFromHash)\nupdateInputFromHash()\n","export const $ = <T extends Element>(s: string) =>\n  document.querySelector(s) as T\n\n// Similar to jQuery.fn.on(type, selector, handler)\nexport const delegate = (\n  eventType: string,\n  element: Element,\n  selector: string,\n  handler: (el: Element, ev: Event) => void\n) => {\n  element.addEventListener(eventType, event => {\n    if (event.target instanceof Element) {\n      const closest = event.target.closest(selector)\n      if (closest && element.contains(closest)) {\n        handler(closest, event)\n      }\n    }\n  })\n}\n\nexport const nodeIndex = (element: Element): number => {\n  return Array.prototype.indexOf.call(element.parentNode!.childNodes, element)\n}\n","import { dedent } from './utils'\n\nconst examples = [\n  {\n    name: 'Basics',\n    code: dedent(`\n    ; This example is not intend to be a tutorial nor an introduction to Î» Calculus.\n    ; You should check http://en.wikipedia.org/wiki/Lambda_calculus for that :)\n    ; As you can see, these are comments. You can run this example clicking the Run\n    ; button below or pressing Ctrl+Enter.\n    ; So, the three basic types of Î» expressions are:\n    ; Variables:\n    x\n    ; Applications:\n    x y\n    ; And lambda abstractions (also known as functions):\n    Î»x.x\n    ; If the left-side of an application is an abstraction, then a reduction takes place:\n    (Î»x.x) y\n    ; That little abstraction at the left is the identity, a very simple function that\n    ; just reduces to whatever you apply to it. We can give it a name like so:\n    id = Î»x.x\n    ; And then just refer it by that name:\n    id a\n    ; You can apply any kind of Î» expression to an abstraction, like another function:\n    id Î»b.c\n    ; Or an application:\n    id (x y)\n    ; Or even the identity function itself:\n    id id\n    ; That means you can apply identity to itself as many times as you want and it'll still\n    ; be identity:\n    id id id id id\n    ; Notice that applications are left-associative, so the line above is equivalent to:\n    ((((id id) id) id) id)\n\n    ; TODO: explain applicative and normal order...\n  `)\n  },\n  {\n    name: 'Booleans',\n    code: dedent(`\n    ; Church booleans\n\n    ; The booleans and their operations can be encoded as the following Î»-terms:\n    true = Î»t.Î»f.t\n    false = Î»t.Î»f.f\n    not = Î»p.p false true\n    and = Î»p.Î»q.p q p\n    or = Î»p.Î»q.p p q\n    if = Î»p.p\n\n    ; Print truth tables for not, and and or:\n    not true\n    not false\n    and false false\n    and false true\n    and true false\n    and true true\n    or false false\n    or false true\n    or true false\n    or true true\n\n    ; Terms can be nested as much as we want:\n    if (not (not true)) (or false (if true true false)) false\n\n    ; There's nothing special about \"operators\", we can treat them as any other value:\n    (if false or and) true false\n  `)\n  },\n  {\n    name: 'Numbers',\n    code: dedent(`\n    ; Church numerals\n\n    ; The first few numbers are:\n    zero = Î»s.Î»z.z\n    one = Î»s.Î»z.s z\n    two = Î»s.Î»z.s (s z)\n    three = Î»s.Î»z.s (s (s z))\n    ; In general, any natural number n can be encoded as:\n    ; N = Î»s.Î»z.s (s (s ... (s (s z)) ... ))\n    ; with s applied n times.\n\n    ; When we get tired of writing numbers like that, we can define a successor function:\n    succ = Î»n.Î»s.Î»z.s (n s z)\n    succ three\n\n    ; We can think of Church numerals as functions that apply a given function s to a\n    ; given value z a number of times. Zero will apply it 0 times (i.e. it'll give\n    ; us z back untouched) and three will call it 3 times.\n    ; So, we can represent the addition of numbers m and n as first applying n times s to z,\n    ; and then applying m times s to that:\n    add = Î»m.Î»n.Î»s.Î»z.m s (n s z)\n    add two three\n    ; ...or, more succinctly, as applying n times the successor function on m (or vice versa):\n    add' = Î»m.Î»n.n succ m\n    add' two three\n    ; Conversely, we could define the successor function as adding one:\n    succ' = add one\n    succ' three\n\n    ; Multiplication of m by n is applying m times a function that applies s n times:\n    mult = Î»m.Î»n.Î»s.m (n s)\n    mult three three\n    ; ...or applying m times the addition of n to zero:\n    mult' = Î»m.Î»n.m (add n) zero\n    mult' three three\n\n    ; Exponentiation n^m has a simple encoding: applying the base m to the exponent n,\n    ; which can be understood as applying m successively n times:\n    exp = Î»m.Î»n.n m\n    exp two three\n    ; ...or, alternatively, applying m times the multiplication by n to one:\n    exp' = Î»m.Î»n.m (mult n) one\n    exp' two three\n\n    ; The encoding for the predecessor function is quite complex.\n    ; The Wikipedia article on Church encoding has a good explanation for this term ;-)\n    pred = Î»n.Î»s.Î»z.n (Î»f.Î»g.g (f s)) (Î»x.z) (Î»x.x)\n    pred three\n\n    ; But given the predecessor function is then easy to define the subtraction:\n    sub = Î»m.Î»n.n pred m\n    sub three two\n\n    ; To build some predicate functions, we'll use some known boolean terms (see\n    ; Booleans example for more info):\n    true = Î»t.Î»f.t\n    false = Î»t.Î»f.f\n    and = Î»p.Î»q.p q p\n\n    ; To know if a number n is zero we can pass true as the base value and a function\n    ; that always returns false (note that the \"?\" is no special syntax; it's just\n    ; part of the name of the predicate):\n    zero? = Î»n.n (Î»x.false) true\n    zero? zero\n    zero? two\n\n    ; To know if a number is less or equal to another number, we can subtract them and\n    ; see if the result is zero:\n    leq = Î»m.Î»n.zero? (sub m n)\n\n    ; And given that predicate, numeric equality between m and n can be defined as:\n    eq = Î»m.Î»n.and (leq m n) (leq n m)\n\n    ; Throwing everything into the mix, we can prove that 2Â³ = 3Â² - 1:\n    eq (exp two three) (pred (exp three two))\n  `)\n  },\n  {\n    name: 'Factorial',\n    code: dedent(`\n    ; Factorial function and recursion\n\n    ; Note: for this example we'll use boolean and numeric terms from previous\n    ; examples (see below).\n    ; Also not that these factorial definitions won't work with applicative order ;)\n\n    ; We'd like to be able to define a factorial function as:\n    ; fact = Î»n.if (zero? n) one (mult n (fact (pred n)))\n    ; But we can't use a term in its own definition.\n    ; To achieve recursion, we can instead define a function that will receive itself\n    ; as a parameter r, and then recur by calling r with itself and n - 1:\n    fact-rec = Î»r.Î»n.if (zero? n) one (mult n (r r (pred n)))\n    ; The real factorial function would then be:\n    fact = fact-rec fact-rec\n    fact four\n\n    ; Another way to recur is to use a general purpose fixed-point combinator.\n    ; Behold, the almighty Y Combinator:\n    Y = Î»f.(Î»x.f (x x)) (Î»x.f (x x))\n    ; And then there's no need to define a separate function:\n    fact2 = Y Î»r.Î»n.if (zero? n) one (mult n (r (pred n)))\n    fact2 four\n\n    ; A different way of computing the factorial of n is to use the number n itself\n    ; as a function that will call a given function n times, starting with a given value.\n    ; The function given will take a pair [a, b] and return a new pair [a-1, a*b], and start with [n, 1].\n    ; After applying this given function n times, the resulting pair will be [0, factorial(n)],\n    ; of which we take the 2nd component.\n    ; This way of defining factorial requires much fewer reduction steps.\n    fact3 = Î»n.2nd (n (Î»p.pair (pred (1st p)) (mult (1st p) (2nd p))) (pair n one))\n    fact3 four\n\n    ; Yet another way of defining factorial is as the successive multiplication of the numbers n...1,\n    ; which results in this very elegant solution:\n    fact4 = Î»n.reduce mult (iota n) one\n    fact4 four\n\n    ; Pair-handling functions:\n    pair = Î»x.Î»y.Î»f.f x y\n    1st = Î»p.p (Î»x.Î»y.x)\n    2nd = Î»p.p (Î»x.Î»y.y)\n\n    ; List-handling functions. Lists can be considered functions handling a nil (empty) case\n    ; and a cons (head+tail) case:\n    nil = Î»n.Î»c.n\n    cons = Î»h.Î»t.Î»n.Î»c.c h t\n    reduce = Y Î»r.Î»f.Î»list.Î»initial.list initial (Î»h.Î»t.f h (r f t initial))\n    ; For a given number n, iota produces the list of numbers 1, 2, ..., n\n    iota = Î»n.n (Î»list.list (cons n nil) (Î»h.Î»t.cons (pred h) list)) nil\n\n    ; Borrow some terms from previous examples:\n    true = Î»t.Î»f.t\n    false = Î»t.Î»f.f\n    if = Î»p.p\n    zero = Î»s.Î»z.z\n    one = Î»s.Î»z.s z\n    two = Î»s.Î»z.s (s z)\n    three = Î»s.Î»z.s (s (s z))\n    four = Î»s.Î»z.s (s (s (s z)))\n    succ = Î»n.Î»s.Î»z.s (n s z)\n    pred = Î»n.Î»s.Î»z.n (Î»f.Î»g.g (f s)) (Î»x.z) (Î»x.x)\n    mult = Î»m.Î»n.Î»s.m (n s)\n    zero? = Î»n.n (Î»x.false) true\n  `)\n  },\n  {\n    name: 'Extras',\n    code: dedent(`\n    ; Syntactic Trivia and Miscellaneous\n\n    ; Identifiers can contain basically any character (except the few ones reserved for\n    ; syntax: \"Î»\", \".\", \"=\", \"(\" and \")\").\n    ; This means you can write some pretty code-looking lambda terms!\n    0 = Î»s.Î»z.z\n    1 = Î»s.Î»z.s z\n    2 = Î»s.Î»z.s (s z)\n    + = Î»m.Î»n.Î»s.Î»z.m s (n s z)\n    * = Î»m.Î»n.Î»s.m (n s)\n    (+ (* 2 1) 0)\n    ; Reinventing (a part of) Lisp is always fun...\n\n    ; You can even use emojis as identifiers! But make sure to use this power responsibly.\n    (Î»ð´.â) ð\n\n    ; Although line breaks usually act as separators between terms/definitions,\n    ; you can use parentheses to split a complex term into multiple lines:\n    fib = Y Î»f.Î»n.(\n      if (â¤ n 1)\n         n\n         (+ (f (- n 1))\n            (f (- n 2))))\n    fib 0\n    fib 1\n    fib 2\n    fib 7\n\n    ; The rest of the definitions to make the above code work. Not much to see here...\n    Y = Î»f.(Î»x.f (x x)) (Î»x.f (x x))\n    - = Î»m.Î»n.n pred m\n    â¤ = Î»m.Î»n.zero? (- m n)\n    pred = Î»n.Î»s.Î»z.n (Î»f.Î»g.g (f s)) (Î»x.z) (Î»x.x)\n    zero? = Î»n.n (Î»x.false) true\n    true = Î»t.Î»f.t\n    false = Î»t.Î»f.f\n    if = Î»p.p\n    7 = Î»s.Î»z.s (s (s (s (s (s (s z))))))\n    13 = Î»s.Î»z.s (s (s (s (s (s (s (s (s (s (s (s (s z))))))))))))\n    â = Î»ð©.ð© ð© ð©\n  `)\n  }\n]\n\nexport default examples\n","import { substitute } from './substitute'\nimport { Term, Var } from './terms'\n\n// Whether two terms are alpha-equivalent.\nconst alphaEq = (t1: Term, t2: Term): boolean => {\n  if (t1.type === 'def') {\n    return alphaEq(t1.term, t2)\n  }\n  if (t2.type === 'def') {\n    return alphaEq(t1, t2.term)\n  }\n  if (t1.type === 'var' && t2.type === 'var') {\n    return t1.name === t2.name\n  }\n  if (t1.type === 'app' && t2.type === 'app') {\n    return alphaEq(t1.left, t2.left) && alphaEq(t1.right, t2.right)\n  }\n  if (t1.type === 'fun' && t2.type === 'fun') {\n    if (t1.param === t2.param) {\n      return alphaEq(t1.body, t2.body)\n    } else {\n      return alphaEq(t1.body, substitute(t2.body, t2.param, Var(t1.param)))\n    }\n  }\n  return false\n}\n\nexport default alphaEq\n","import { identity } from '../utils'\nimport { Term } from './terms'\n\n// Returns the string representation for a given term t.\nconst format = (t: Term, appParens = false, funParens = false): string => {\n  // TODO: Remove highlighting hack of storing data on terms.\n  const { highlight: h = identity, highlightVar } = t as any\n  switch (t.type) {\n    case 'var':\n    case 'def':\n      return h(t.name)\n    case 'fun':\n      let lambda = `Î»${t.param}`\n      if (highlightVar) {\n        lambda = highlightVar(lambda)\n      }\n      const funStr = `${lambda}.${format(t.body)}`\n      return h(funParens ? `(${funStr})` : funStr)\n    case 'app':\n      const lStr = format(t.left, false, true)\n      const rStr = format(t.right, true, funParens)\n      const appStr = `${lStr} ${rStr}`\n      return h(appParens ? `(${appStr})` : appStr)\n  }\n}\n\nexport default format\n","import { Term } from './terms'\n\n// Whether the variable x appears free in the term t.\nconst freeIn = (x: string, t: Term): boolean => {\n  switch (t.type) {\n    case 'var':\n      return t.name === x\n    case 'fun':\n      return t.param !== x && freeIn(x, t.body)\n    case 'app':\n      return freeIn(x, t.left) || freeIn(x, t.right)\n    case 'def':\n      // Definitions don't have free variables.\n      return false\n  }\n}\n\nexport default freeIn\n","/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar grammar = (function() {\n  var o = function(k, v, o, l) {\n      for (o = o || {}, l = k.length; l--; o[k[l]] = v);\n      return o\n    },\n    $V0 = [5, 7],\n    $V1 = [1, 6],\n    $V2 = [1, 7],\n    $V3 = [1, 8],\n    $V4 = [2, 10],\n    $V5 = [5, 7, 11, 13, 14, 15]\n  var parser = {\n    trace: function trace() {},\n    yy: {},\n    symbols_: {\n      error: 2,\n      root: 3,\n      program: 4,\n      EOF: 5,\n      line: 6,\n      SEPARATOR: 7,\n      term: 8,\n      ident: 9,\n      '=': 10,\n      LAMBDA: 11,\n      '.': 12,\n      '(': 13,\n      ')': 14,\n      IDENT: 15,\n      $accept: 0,\n      $end: 1\n    },\n    terminals_: {\n      2: 'error',\n      5: 'EOF',\n      7: 'SEPARATOR',\n      10: '=',\n      11: 'LAMBDA',\n      12: '.',\n      13: '(',\n      14: ')',\n      15: 'IDENT'\n    },\n    productions_: [\n      0,\n      [3, 2],\n      [4, 0],\n      [4, 1],\n      [4, 2],\n      [4, 3],\n      [6, 1],\n      [6, 3],\n      [8, 4],\n      [8, 2],\n      [8, 1],\n      [8, 3],\n      [9, 1]\n    ],\n    performAction: function anonymous(\n      yytext,\n      yyleng,\n      yylineno,\n      yy,\n      yystate /* action[1] */,\n      $$ /* vstack */,\n      _$ /* lstack */\n    ) {\n      /* this == yyval */\n\n      var $0 = $$.length - 1\n      switch (yystate) {\n        case 1:\n          /* do nothing; terms and definitions already collected */\n\n          break\n        case 6:\n          this.$ = yy.parseTopLevelTerm($$[$0])\n          break\n        case 7:\n          this.$ = yy.parseDefinition($$[$0 - 2], $$[$0])\n          break\n        case 8:\n          this.$ = yy.parseFunction($$[$0 - 2], $$[$0])\n          break\n        case 9:\n          this.$ = yy.parseApplication($$[$0 - 1], $$[$0])\n          break\n        case 10:\n          this.$ = yy.parseIdentifier($$[$0])\n          break\n        case 11:\n          this.$ = $$[$0 - 1]\n          break\n        case 12:\n          this.$ = yytext\n          break\n      }\n    },\n    table: [\n      o($V0, [2, 2], {\n        3: 1,\n        4: 2,\n        6: 3,\n        8: 4,\n        9: 5,\n        11: $V1,\n        13: $V2,\n        15: $V3\n      }),\n      { 1: [3] },\n      { 5: [1, 9], 7: [1, 10] },\n      o($V0, [2, 3]),\n      o($V0, [2, 6], { 8: 11, 9: 12, 11: $V1, 13: $V2, 15: $V3 }),\n      o([5, 7, 11, 13, 15], $V4, { 10: [1, 13] }),\n      { 9: 14, 15: $V3 },\n      { 8: 15, 9: 12, 11: $V1, 13: $V2, 15: $V3 },\n      o([5, 7, 10, 11, 12, 13, 14, 15], [2, 12]),\n      { 1: [2, 1] },\n      o($V0, [2, 4], { 8: 4, 9: 5, 6: 16, 11: $V1, 13: $V2, 15: $V3 }),\n      o($V5, [2, 9], { 8: 11, 9: 12 }),\n      o($V5, $V4),\n      { 8: 17, 9: 12, 11: $V1, 13: $V2, 15: $V3 },\n      { 12: [1, 18] },\n      { 8: 11, 9: 12, 11: $V1, 13: $V2, 14: [1, 19], 15: $V3 },\n      o($V0, [2, 5]),\n      o($V0, [2, 7], { 8: 11, 9: 12, 11: $V1, 13: $V2, 15: $V3 }),\n      { 8: 20, 9: 12, 11: $V1, 13: $V2, 15: $V3 },\n      o($V5, [2, 11]),\n      o([5, 7, 14], [2, 8], { 8: 11, 9: 12, 11: $V1, 13: $V2, 15: $V3 })\n    ],\n    defaultActions: { 9: [2, 1] },\n    parseError: function parseError(str, hash) {\n      if (hash.recoverable) {\n        this.trace(str)\n      } else {\n        var error = new Error(str)\n        error.hash = hash\n        throw error\n      }\n    },\n    parse: function parse(input) {\n      var self = this,\n        stack = [0],\n        tstack = [],\n        vstack = [null],\n        lstack = [],\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1\n      var args = lstack.slice.call(arguments, 1)\n      var lexer = Object.create(this.lexer)\n      var sharedState = { yy: {} }\n      for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n          sharedState.yy[k] = this.yy[k]\n        }\n      }\n      lexer.setInput(input, sharedState.yy)\n      sharedState.yy.lexer = lexer\n      sharedState.yy.parser = this\n      if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {}\n      }\n      var yyloc = lexer.yylloc\n      lstack.push(yyloc)\n      var ranges = lexer.options && lexer.options.ranges\n      if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError\n      } else {\n        this.parseError = Object.getPrototypeOf(this).parseError\n      }\n      function popStack(n) {\n        stack.length = stack.length - 2 * n\n        vstack.length = vstack.length - n\n        lstack.length = lstack.length - n\n      }\n      _token_stack: var lex = function() {\n        var token\n        token = lexer.lex() || EOF\n        if (typeof token !== 'number') {\n          token = self.symbols_[token] || token\n        }\n        return token\n      }\n      var symbol,\n        preErrorSymbol,\n        state,\n        action,\n        a,\n        r,\n        yyval = {},\n        p,\n        len,\n        newState,\n        expected\n      while (true) {\n        state = stack[stack.length - 1]\n        if (this.defaultActions[state]) {\n          action = this.defaultActions[state]\n        } else {\n          if (symbol === null || typeof symbol == 'undefined') {\n            symbol = lex()\n          }\n          action = table[state] && table[state][symbol]\n        }\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n          var errStr = ''\n          expected = []\n          for (p in table[state]) {\n            if (this.terminals_[p] && p > TERROR) {\n              expected.push(\"'\" + this.terminals_[p] + \"'\")\n            }\n          }\n          if (lexer.showPosition) {\n            errStr =\n              'Parse error on line ' +\n              (yylineno + 1) +\n              ':\\n' +\n              lexer.showPosition() +\n              '\\nExpecting ' +\n              expected.join(', ') +\n              \", got '\" +\n              (this.terminals_[symbol] || symbol) +\n              \"'\"\n          } else {\n            errStr =\n              'Parse error on line ' +\n              (yylineno + 1) +\n              ': Unexpected ' +\n              (symbol == EOF\n                ? 'end of input'\n                : \"'\" + (this.terminals_[symbol] || symbol) + \"'\")\n          }\n          this.parseError(errStr, {\n            text: lexer.match,\n            token: this.terminals_[symbol] || symbol,\n            line: lexer.yylineno,\n            loc: yyloc,\n            expected: expected\n          })\n        }\n        if (action[0] instanceof Array && action.length > 1) {\n          throw new Error(\n            'Parse Error: multiple actions possible at state: ' +\n              state +\n              ', token: ' +\n              symbol\n          )\n        }\n        switch (action[0]) {\n          case 1:\n            stack.push(symbol)\n            vstack.push(lexer.yytext)\n            lstack.push(lexer.yylloc)\n            stack.push(action[1])\n            symbol = null\n            if (!preErrorSymbol) {\n              yyleng = lexer.yyleng\n              yytext = lexer.yytext\n              yylineno = lexer.yylineno\n              yyloc = lexer.yylloc\n              if (recovering > 0) {\n                recovering--\n              }\n            } else {\n              symbol = preErrorSymbol\n              preErrorSymbol = null\n            }\n            break\n          case 2:\n            len = this.productions_[action[1]][1]\n            yyval.$ = vstack[vstack.length - len]\n            yyval._$ = {\n              first_line: lstack[lstack.length - (len || 1)].first_line,\n              last_line: lstack[lstack.length - 1].last_line,\n              first_column: lstack[lstack.length - (len || 1)].first_column,\n              last_column: lstack[lstack.length - 1].last_column\n            }\n            if (ranges) {\n              yyval._$.range = [\n                lstack[lstack.length - (len || 1)].range[0],\n                lstack[lstack.length - 1].range[1]\n              ]\n            }\n            r = this.performAction.apply(\n              yyval,\n              [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n              ].concat(args)\n            )\n            if (typeof r !== 'undefined') {\n              return r\n            }\n            if (len) {\n              stack = stack.slice(0, -1 * len * 2)\n              vstack = vstack.slice(0, -1 * len)\n              lstack = lstack.slice(0, -1 * len)\n            }\n            stack.push(this.productions_[action[1]][0])\n            vstack.push(yyval.$)\n            lstack.push(yyval._$)\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]]\n            stack.push(newState)\n            break\n          case 3:\n            return true\n        }\n      }\n      return true\n    }\n  }\n  var openParens = 0 /* generated by jison-lex 0.3.4 */\n  var lexer = (function() {\n    var lexer = {\n      EOF: 1,\n\n      parseError: function parseError(str, hash) {\n        if (this.yy.parser) {\n          this.yy.parser.parseError(str, hash)\n        } else {\n          throw new Error(str)\n        }\n      },\n\n      // resets the lexer, sets new input\n      setInput: function(input, yy) {\n        this.yy = yy || this.yy || {}\n        this._input = input\n        this._more = this._backtrack = this.done = false\n        this.yylineno = this.yyleng = 0\n        this.yytext = this.matched = this.match = ''\n        this.conditionStack = ['INITIAL']\n        this.yylloc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0\n        }\n        if (this.options.ranges) {\n          this.yylloc.range = [0, 0]\n        }\n        this.offset = 0\n        return this\n      },\n\n      // consumes and returns one char from the input\n      input: function() {\n        var ch = this._input[0]\n        this.yytext += ch\n        this.yyleng++\n        this.offset++\n        this.match += ch\n        this.matched += ch\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g)\n        if (lines) {\n          this.yylineno++\n          this.yylloc.last_line++\n        } else {\n          this.yylloc.last_column++\n        }\n        if (this.options.ranges) {\n          this.yylloc.range[1]++\n        }\n\n        this._input = this._input.slice(1)\n        return ch\n      },\n\n      // unshifts one char (or a string) into the input\n      unput: function(ch) {\n        var len = ch.length\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g)\n\n        this._input = ch + this._input\n        this.yytext = this.yytext.substr(0, this.yytext.length - len)\n        //this.yyleng -= len;\n        this.offset -= len\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g)\n        this.match = this.match.substr(0, this.match.length - 1)\n        this.matched = this.matched.substr(0, this.matched.length - 1)\n\n        if (lines.length - 1) {\n          this.yylineno -= lines.length - 1\n        }\n        var r = this.yylloc.range\n\n        this.yylloc = {\n          first_line: this.yylloc.first_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.first_column,\n          last_column: lines\n            ? (lines.length === oldLines.length\n                ? this.yylloc.first_column\n                : 0) +\n              oldLines[oldLines.length - lines.length].length -\n              lines[0].length\n            : this.yylloc.first_column - len\n        }\n\n        if (this.options.ranges) {\n          this.yylloc.range = [r[0], r[0] + this.yyleng - len]\n        }\n        this.yyleng = this.yytext.length\n        return this\n      },\n\n      // When called from action, caches matched text and appends it on next action\n      more: function() {\n        this._more = true\n        return this\n      },\n\n      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n      reject: function() {\n        if (this.options.backtrack_lexer) {\n          this._backtrack = true\n        } else {\n          return this.parseError(\n            'Lexical error on line ' +\n              (this.yylineno + 1) +\n              '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' +\n              this.showPosition(),\n            {\n              text: '',\n              token: null,\n              line: this.yylineno\n            }\n          )\n        }\n        return this\n      },\n\n      // retain first n characters of the match\n      less: function(n) {\n        this.unput(this.match.slice(n))\n      },\n\n      // displays already matched input, i.e. for error messages\n      pastInput: function() {\n        var past = this.matched.substr(\n          0,\n          this.matched.length - this.match.length\n        )\n        return (\n          (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, '')\n        )\n      },\n\n      // displays upcoming input, i.e. for error messages\n      upcomingInput: function() {\n        var next = this.match\n        if (next.length < 20) {\n          next += this._input.substr(0, 20 - next.length)\n        }\n        return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(\n          /\\n/g,\n          ''\n        )\n      },\n\n      // displays the character position where the lexing error occurred, i.e. for error messages\n      showPosition: function() {\n        var pre = this.pastInput()\n        var c = new Array(pre.length + 1).join('-')\n        return pre + this.upcomingInput() + '\\n' + c + '^'\n      },\n\n      // test the lexed token: return FALSE when not a match, otherwise return token\n      test_match: function(match, indexed_rule) {\n        var token, lines, backup\n\n        if (this.options.backtrack_lexer) {\n          // save context\n          backup = {\n            yylineno: this.yylineno,\n            yylloc: {\n              first_line: this.yylloc.first_line,\n              last_line: this.last_line,\n              first_column: this.yylloc.first_column,\n              last_column: this.yylloc.last_column\n            },\n            yytext: this.yytext,\n            match: this.match,\n            matches: this.matches,\n            matched: this.matched,\n            yyleng: this.yyleng,\n            offset: this.offset,\n            _more: this._more,\n            _input: this._input,\n            yy: this.yy,\n            conditionStack: this.conditionStack.slice(0),\n            done: this.done\n          }\n          if (this.options.ranges) {\n            backup.yylloc.range = this.yylloc.range.slice(0)\n          }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g)\n        if (lines) {\n          this.yylineno += lines.length\n        }\n        this.yylloc = {\n          first_line: this.yylloc.last_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.last_column,\n          last_column: lines\n            ? lines[lines.length - 1].length -\n              lines[lines.length - 1].match(/\\r?\\n?/)[0].length\n            : this.yylloc.last_column + match[0].length\n        }\n        this.yytext += match[0]\n        this.match += match[0]\n        this.matches = match\n        this.yyleng = this.yytext.length\n        if (this.options.ranges) {\n          this.yylloc.range = [this.offset, (this.offset += this.yyleng)]\n        }\n        this._more = false\n        this._backtrack = false\n        this._input = this._input.slice(match[0].length)\n        this.matched += match[0]\n        token = this.performAction.call(\n          this,\n          this.yy,\n          this,\n          indexed_rule,\n          this.conditionStack[this.conditionStack.length - 1]\n        )\n        if (this.done && this._input) {\n          this.done = false\n        }\n        if (token) {\n          return token\n        } else if (this._backtrack) {\n          // recover context\n          for (var k in backup) {\n            this[k] = backup[k]\n          }\n          return false // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false\n      },\n\n      // return next match in input\n      next: function() {\n        if (this.done) {\n          return this.EOF\n        }\n        if (!this._input) {\n          this.done = true\n        }\n\n        var token, match, tempMatch, index\n        if (!this._more) {\n          this.yytext = ''\n          this.match = ''\n        }\n        var rules = this._currentRules()\n        for (var i = 0; i < rules.length; i++) {\n          tempMatch = this._input.match(this.rules[rules[i]])\n          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n            match = tempMatch\n            index = i\n            if (this.options.backtrack_lexer) {\n              token = this.test_match(tempMatch, rules[i])\n              if (token !== false) {\n                return token\n              } else if (this._backtrack) {\n                match = false\n                continue // rule action called reject() implying a rule MISmatch.\n              } else {\n                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                return false\n              }\n            } else if (!this.options.flex) {\n              break\n            }\n          }\n        }\n        if (match) {\n          token = this.test_match(match, rules[index])\n          if (token !== false) {\n            return token\n          }\n          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n          return false\n        }\n        if (this._input === '') {\n          return this.EOF\n        } else {\n          return this.parseError(\n            'Lexical error on line ' +\n              (this.yylineno + 1) +\n              '. Unrecognized text.\\n' +\n              this.showPosition(),\n            {\n              text: '',\n              token: null,\n              line: this.yylineno\n            }\n          )\n        }\n      },\n\n      // return next match that has a token\n      lex: function lex() {\n        var r = this.next()\n        if (r) {\n          return r\n        } else {\n          return this.lex()\n        }\n      },\n\n      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n      begin: function begin(condition) {\n        this.conditionStack.push(condition)\n      },\n\n      // pop the previously active lexer condition state off the condition stack\n      popState: function popState() {\n        var n = this.conditionStack.length - 1\n        if (n > 0) {\n          return this.conditionStack.pop()\n        } else {\n          return this.conditionStack[0]\n        }\n      },\n\n      // produce the lexer rule set which is active for the currently active lexer condition state\n      _currentRules: function _currentRules() {\n        if (\n          this.conditionStack.length &&\n          this.conditionStack[this.conditionStack.length - 1]\n        ) {\n          return this.conditions[\n            this.conditionStack[this.conditionStack.length - 1]\n          ].rules\n        } else {\n          return this.conditions['INITIAL'].rules\n        }\n      },\n\n      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n      topState: function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0)\n        if (n >= 0) {\n          return this.conditionStack[n]\n        } else {\n          return 'INITIAL'\n        }\n      },\n\n      // alias for begin(condition)\n      pushState: function pushState(condition) {\n        this.begin(condition)\n      },\n\n      // return the number of states currently on the stack\n      stateStackSize: function stateStackSize() {\n        return this.conditionStack.length\n      },\n      options: {},\n      performAction: function anonymous(\n        yy,\n        yy_,\n        $avoiding_name_collisions,\n        YY_START\n      ) {\n        var YYSTATE = YY_START\n        switch ($avoiding_name_collisions) {\n          case 0:\n            openParens++\n            return 13\n            break\n          case 1:\n            openParens--\n            return 14\n            break\n          case 2:\n            return 11\n            break\n          case 3:\n            return 12\n            break\n          case 4:\n            return 10\n            break\n          case 5 /* ignore separators inside parens */:\n            if (openParens <= 0) return 7\n\n            break\n          case 6 /* ignore whitespace */:\n            break\n          case 7 /* ignore line comments */:\n            break\n          case 8:\n            return 15\n            break\n          case 9:\n            return 5\n            break\n        }\n      },\n      rules: [\n        /^(?:\\()/,\n        /^(?:\\))/,\n        /^(?:\\\\|Î»)/,\n        /^(?:\\.)/,\n        /^(?:=)/,\n        /^(?:\\n)/,\n        /^(?:[^\\S\\n]+)/,\n        /^(?:;.*)/,\n        /^(?:[^\\s\\(\\)\\\\Î»\\.=]+)/,\n        /^(?:$)/\n      ],\n      conditions: {\n        INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], inclusive: true }\n      }\n    }\n    return lexer\n  })()\n  parser.lexer = lexer\n  function Parser() {\n    this.yy = {}\n  }\n  Parser.prototype = parser\n  parser.Parser = Parser\n  return new Parser()\n})()\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n  exports.parser = grammar\n  exports.Parser = grammar.Parser\n  exports.parse = function() {\n    return grammar.parse.apply(grammar, arguments)\n  }\n  exports.main = function commonjsMain(args) {\n    if (!args[1]) {\n      console.log('Usage: ' + args[0] + ' FILE')\n      process.exit(1)\n    }\n    var source = require('fs').readFileSync(\n      require('path').normalize(args[1]),\n      'utf8'\n    )\n    return exports.parser.parse(source)\n  }\n  if (typeof module !== 'undefined' && require.main === module) {\n    exports.main(process.argv.slice(1))\n  }\n}\n","import { App, Def, Fun, Term } from './terms'\n\nexport type Callback = (t: Term) => void\n\n// Compose a callback function with a term constructor.\nexport const composeFun = (fn: Callback, x: string) => (b: Term) =>\n  fn(Fun(x, b))\nexport const composeAppL = (fn: Callback, l: Term) => (r: Term) => fn(App(l, r))\nexport const composeAppR = (fn: Callback, r: Term) => (l: Term) => fn(App(l, r))\n\nexport type Definitions = { [key: string]: Term }\n\n// Represents a reduction \"step\" as displayed on the application.\nexport type Step =\n  | { type: 'alpha'; before: Fun; after: Fun }\n  | { type: 'beta'; before: App; after: Term }\n  | { type: 'eta'; before: Fun; after: Term }\n  | { type: 'def'; before: Def; after: Term }\n\nexport type AnnotatedTerm = Term & { step: Step }\n\n// Mark a reduction step on the `after` term.\nexport const markStep = (step: Step): AnnotatedTerm => ({ ...step.after, step })\n","export * from './terms'\nexport { default as parse } from './parse'\nexport { default as format } from './format'\nexport { reduceProgram, Reduction, Options } from './reduce-program'\nexport { Definitions } from './helpers'\n","import { collapseWhitespace, timed } from '../utils'\nimport { Parser } from './grammar'\nimport { Definitions } from './helpers'\nimport { App, Fun, Term } from './terms'\n\n// Parses an input program string and returns an object with the top-level terms\n// and definitions of the program.\nconst parse = timed('parse', (str: string) => {\n  // A custom Jison parser.\n  const parser = new Parser()\n\n  // A definition table with the definition term by their names.\n  const defs: Definitions = {}\n  // The terms of the program.\n  const terms: Term[] = []\n\n  // Add some handy functions so the parser can build the AST.\n  parser.yy = {\n    parseFunction: Fun,\n    parseApplication: App,\n    parseDefinition: (name: string, term: Term) => {\n      if (defs[name]) {\n        throw Error(`${name} already defined`)\n      }\n      defs[name] = term\n    },\n    parseTopLevelTerm: (term: Term) => {\n      terms.push(term)\n    },\n    parseIdentifier: (name: string) => ({ type: 'ref', name })\n  }\n\n  parser.parse(str)\n\n  terms.forEach(t => resolveTermRefs(t, defs))\n\n  const refNames = {}\n  Object.keys(defs).forEach(name => {\n    resolveDefRefs(name, defs[name], defs, refNames)\n  })\n\n  return { defs, terms }\n})\n\nexport default parse\n\n// Temporary term used only while parsing as a placeholder for wither a Var o a\n// Ref. On the first pass the parser cannot know if an identifier is a variable\n// or a definition (because definitions can be declared after their use), so it\n// stores a Ref instead and then on a second pass decides what it should be and\n// *mutates* the Ref in-place to become either a Var or a Ref.\n// TODO: Remove this hack.\ntype TermOrRef = Term | { type: 'ref'; name: string }\n\n// Changes all Refs inside term t to either Vars or Defs.\nconst resolveTermRefs = (\n  t: TermOrRef,\n  defs: Definitions,\n  boundNames: string[] = []\n) => {\n  switch (t.type) {\n    case 'ref':\n      const free = boundNames.indexOf(t.name) < 0\n      if (t.name in defs && free) {\n        Object.assign(t, { type: 'def', term: defs[t.name] })\n      } else {\n        Object.assign(t, { type: 'var' })\n      }\n      break\n    case 'app':\n      resolveTermRefs(t.left, defs, boundNames)\n      resolveTermRefs(t.right, defs, boundNames)\n      break\n    case 'fun':\n      resolveTermRefs(t.body, defs, boundNames.concat(t.param))\n      break\n  }\n}\n\ntype RefNames = { [key: string]: string[] }\n\n// Changes all Refs inside term t to either Vars or Defs.\nconst resolveDefRefs = (\n  defName: string,\n  t: TermOrRef,\n  defs: Definitions,\n  refNames: RefNames,\n  boundNames: string[] = []\n) => {\n  switch (t.type) {\n    case 'ref':\n      const bound = boundNames.indexOf(t.name) >= 0\n      if (bound) {\n        Object.assign(t, { type: 'var' })\n      } else if (t.name in defs) {\n        refNames[defName] = [...(refNames[defName] || []), t.name]\n        checkForCircularRefs(defName, t.name, refNames)\n        Object.assign(t, { type: 'def', term: defs[t.name] })\n      } else {\n        throw Error(\n          collapseWhitespace(\n            `Illegal free variable \"${t.name}\" in \"${defName}\". \n        Definitions cannot have free variables.`\n          )\n        )\n      }\n      break\n    case 'app':\n      resolveDefRefs(defName, t.left, defs, refNames, boundNames)\n      resolveDefRefs(defName, t.right, defs, refNames, boundNames)\n      break\n    case 'fun':\n      const boundOnBody = boundNames.concat(t.param)\n      resolveDefRefs(defName, t.body, defs, refNames, boundOnBody)\n      break\n  }\n}\n\nconst checkForCircularRefs = (\n  name: string,\n  refName: string,\n  refNames: RefNames,\n  path: string[] = []\n) => {\n  if (name === refName) {\n    const circularNote = path.length\n      ? `In this case the definition does not reference itself directly, but \n        through other definitions: ${[name, ...path, name].join(' â ')}.`\n      : ''\n    throw Error(\n      collapseWhitespace(\n        `Illegal recursive reference in \"${name}\". Definitions cannot\n      reference themselves; they are just simple find&replace mechanisms.\n      ${circularNote}\n      If you want to write a recursive function, look for \"Y combinator\" ;)`\n      )\n    )\n  }\n\n  const nextRefs = refNames[refName] || []\n  nextRefs.forEach(nextRef =>\n    checkForCircularRefs(name, nextRef, refNames, [...path, refName])\n  )\n}\n","import { identity, timed } from '../utils'\nimport alphaEq from './alpha-eq'\nimport format from './format'\nimport { AnnotatedTerm, Definitions, Step } from './helpers'\nimport parse from './parse'\nimport reduce, { Options as ReduceOptions } from './reduce'\nimport { substitute } from './substitute'\nimport { App, Fun, Term, Var } from './terms'\n\nexport type Options = Partial<ReduceOptions> & {\n  maxReductionSteps?: number\n}\n\nexport type Reduction = {\n  initial: string\n  final: string\n  finalSynonyms: string[]\n  terminates: boolean\n  reductionSteps: number\n  totalSteps: number\n  renderStep: (i: number, options: RenderStepOptions) => RenderedStep\n}\n\ntype RenderStepOptions = {\n  highlightFormerTerm?: StrFun\n  highlightSubstitutionTerm?: StrFun\n  highlightStep?: StrFun\n}\n\ntype StrFun = (s: string) => string\n\ntype RenderedStep = {\n  type: 'alpha' | 'beta' | 'eta' | 'def'\n  before: string\n  after: string\n}\n\n// Reduce a program and return with the reduction for each term in the program.\nexport const reduceProgram = (program: string, options: Options = {}) => {\n  const { terms, defs } = parse(program)\n  return terms.map(term => reduceTerm(term, defs, options))\n}\n\n// Reduces a term up to its normal form.\nlet reduceTerm = (\n  term: Term,\n  defs: Definitions,\n  { maxReductionSteps = 100, strategy = 'normal', etaEnabled = false }: Options\n): Reduction => {\n  const enough = {}\n  const steps: Term[] = []\n  let reductionSteps = 0\n  let terminates = false\n  try {\n    reduce(term, { strategy, etaEnabled }, stepTerm => {\n      if (reductionSteps >= maxReductionSteps) {\n        throw enough\n      }\n      steps.push(stepTerm)\n\n      // TODO: it'd be nice if we didn't need to find the step type on the term\n      // on each step. Maybe the callback function could receive the step type\n      // as an argument.\n      const step = findStep(stepTerm)\n      if (!step) {\n        throw new Error('Unexpected: term should always have a step')\n      }\n      if (step.type === 'beta' || step.type === 'eta') {\n        reductionSteps += 1\n      }\n    })\n    terminates = true\n  } catch (e) {\n    if (e !== enough) {\n      throw e\n    }\n    terminates = false\n  }\n\n  const last = steps[steps.length - 1] || term\n  return {\n    initial: format(term),\n    final: format(last),\n    finalSynonyms: findSynonyms(last, defs),\n    terminates,\n    reductionSteps,\n    totalSteps: steps.length,\n    renderStep: (i, options) => expandStep(steps[i], options)\n  }\n}\nreduceTerm = timed('reduce', reduceTerm)\n\nconst expandStep = (t: Term, options: RenderStepOptions = {}) => {\n  const step = findStep(t)\n  if (!step) {\n    throw new Error('Unexpected: term should always have a step')\n  }\n\n  let before: Term = step.before\n  let after: Term = step.after\n\n  const {\n    highlightFormerTerm = identity,\n    highlightSubstitutionTerm = identity,\n    highlightStep = identity\n  } = options\n\n  switch (step.type) {\n    case 'alpha':\n      before = highlightFunctionVar(\n        step.before.body,\n        step.before.param,\n        highlightFormerTerm\n      )\n      after = highlightFunctionVar(\n        step.after.body,\n        step.after.param,\n        highlightSubstitutionTerm\n      )\n      break\n    case 'beta':\n      const fun = step.before.left as Fun\n      const hs = highlight(step.before.right, highlightSubstitutionTerm)\n      const ha = highlightFunctionVar(fun.body, fun.param, highlightFormerTerm)\n      before = App(ha, hs)\n      after = substitute(fun.body, fun.param, hs)\n      break\n    case 'eta':\n    case 'def':\n      before = highlight(step.before, highlightFormerTerm)\n      after = highlight(step.after, highlightSubstitutionTerm)\n      break\n  }\n\n  before = highlight(before, highlightStep)\n  after = highlight(after, highlightStep)\n\n  const beforeStr = format(replaceStep(t, before))\n  const afterStr = format(replaceStep(t, after))\n\n  return { type: step.type, before: beforeStr, after: afterStr }\n}\n\nconst highlight = (t: Term, fn: StrFun) => {\n  const h: StrFun = (t as any).highlight\n  const highlight: StrFun = h ? s => fn(h(s)) : fn\n  return { ...t, highlight }\n}\n\nconst highlightFunctionVar = (t: Term, x: string, fn: StrFun) => {\n  const hx = highlight(Var(x), fn)\n  const ht = substitute(t, x, hx)\n  return { ...Fun(x, ht), highlightVar: fn }\n}\n\nconst findStep = (t: Term | AnnotatedTerm): Step | undefined => {\n  if ('step' in t) {\n    return t.step\n  }\n\n  switch (t.type) {\n    case 'fun':\n      return findStep(t.body)\n    case 'app':\n      return findStep(t.left) || findStep(t.right)\n  }\n}\n\nconst replaceStep = (t: Term | AnnotatedTerm, replacement: Term): Term => {\n  if ('step' in t && t.step) {\n    return replacement\n  }\n\n  switch (t.type) {\n    case 'var':\n    case 'def':\n      return t\n    case 'fun':\n      const body = replaceStep(t.body, replacement)\n      return t.body === body ? t : Fun(t.param, body)\n    case 'app':\n      const l = replaceStep(t.left, replacement)\n      if (t.left !== l) {\n        return App(l, t.right)\n      }\n      const r = replaceStep(t.right, replacement)\n      return t.right === r ? t : App(l, r)\n  }\n}\n\nconst findSynonyms = (term: Term, defs: Definitions) => {\n  const synonyms = []\n  for (const name in defs) {\n    if (alphaEq(term, defs[name])) {\n      synonyms.push(name)\n    }\n  }\n  return synonyms\n}\n","import freeIn from './free-in'\nimport {\n  Callback,\n  composeAppL,\n  composeAppR,\n  composeFun,\n  markStep\n} from './helpers'\nimport { applySubstitution, renameForSubstitution } from './substitute'\nimport { App, Fun, Term } from './terms'\n\nexport type Options = {\n  strategy: keyof typeof reduceFunctions\n  etaEnabled: boolean\n}\n\nconst reduce = (t: Term, { strategy, etaEnabled }: Options, cb: Callback) => {\n  const reducer = reduceFunctions[strategy]\n  let reduced = reducer(t, cb)\n  if (etaEnabled) {\n    reduced = reduceEta(reduced, cb)\n  }\n  return reduced\n}\n\nexport default reduce\n\ntype Reducer = (t: Term, cb: Callback) => Term\n\nconst reduceCallByName: Reducer = (t, cb) => {\n  switch (t.type) {\n    case 'var':\n    case 'fun':\n      return t\n    case 'app':\n      const l = reduceCallByName(t.left, composeAppR(cb, t.right))\n      return l.type === 'fun'\n        ? reduceCallByName(apply(l, t.right, cb), cb)\n        : App(l, t.right)\n    case 'def':\n      cb(markStep({ type: 'def', before: t, after: t.term }))\n      return reduceCallByName(t.term, cb)\n  }\n}\n\nconst reduceNormal: Reducer = (t, cb) => {\n  switch (t.type) {\n    case 'var':\n      return t\n    case 'fun':\n      return Fun(t.param, reduceNormal(t.body, composeFun(cb, t.param)))\n    case 'app':\n      let l = reduceCallByName(t.left, composeAppR(cb, t.right))\n      if (l.type === 'fun') {\n        return reduceNormal(apply(l, t.right, cb), cb)\n      } else {\n        l = reduceNormal(l, composeAppR(cb, t.right)) // Finish reducing l.\n        const r = reduceNormal(t.right, composeAppL(cb, l))\n        return App(l, r)\n      }\n    case 'def':\n      cb(markStep({ type: 'def', before: t, after: t.term }))\n      return reduceNormal(t.term, cb)\n  }\n}\n\nconst reduceCallByValue: Reducer = (t, cb) => {\n  switch (t.type) {\n    case 'var':\n    case 'fun':\n      return t\n    case 'app':\n      const l = reduceCallByValue(t.left, composeAppR(cb, t.right))\n      const r = reduceCallByValue(t.right, composeAppL(cb, l))\n      return l.type === 'fun'\n        ? reduceCallByValue(apply(l, r, cb), cb)\n        : App(l, r)\n    case 'def':\n      cb(markStep({ type: 'def', before: t, after: t.term }))\n      return reduceCallByValue(t.term, cb)\n  }\n}\n\nconst reduceApplicative: Reducer = (t, cb) => {\n  switch (t.type) {\n    case 'var':\n      return t\n    case 'fun':\n      return Fun(t.param, reduceApplicative(t.body, composeFun(cb, t.param)))\n    case 'app':\n      let l = reduceCallByValue(t.left, composeAppR(cb, t.right))\n      if (l.type === 'fun') {\n        const r = reduceCallByValue(t.right, composeAppL(cb, l))\n        return reduceApplicative(apply(l, r, cb), cb)\n      } else {\n        l = reduceApplicative(l, composeAppR(cb, t.right))\n        const r = reduceApplicative(t.right, composeAppL(cb, l))\n        return App(l, r)\n      }\n    case 'def':\n      cb(markStep({ type: 'def', before: t, after: t.term }))\n      return reduceApplicative(t.term, cb)\n  }\n}\n\nconst apply = (fun: Fun, subst: Term, cb: Callback) => {\n  const renameCb = composeFun(composeAppR(cb, subst), fun.param)\n  const renamedBody = renameForSubstitution(\n    fun.body,\n    fun.param,\n    subst,\n    renameCb\n  )\n  const renamed = App(Fun(fun.param, renamedBody), subst)\n  const applied = applySubstitution(renamedBody, fun.param, subst)\n  cb(markStep({ type: 'beta', before: renamed, after: applied }))\n  return applied\n}\n\n// Performs any available Î·-reductions on a term.\nconst reduceEta: Reducer = (t, cb) => {\n  switch (t.type) {\n    case 'var':\n      return t\n    case 'fun':\n      // Î»x.(F x) = F if x is free in F\n      if (\n        t.body.type === 'app' &&\n        t.body.right.type === 'var' &&\n        t.body.right.name === t.param &&\n        !freeIn(t.param, t.body.left)\n      ) {\n        cb(markStep({ type: 'eta', before: t, after: t.body.left }))\n        return t.body.left\n      } else {\n        return Fun(t.param, reduceEta(t.body, composeFun(cb, t.param)))\n      }\n    case 'app':\n      const l = reduceEta(t.left, composeAppR(cb, t.right))\n      const r = reduceEta(t.right, composeAppR(cb, l))\n      return App(l, r)\n    case 'def':\n      return t\n  }\n}\n\nconst reduceFunctions = {\n  normal: reduceNormal,\n  applicative: reduceApplicative,\n  cbn: reduceCallByName,\n  cbv: reduceCallByValue\n}\n","import freeIn from './free-in'\nimport {\n  Callback,\n  composeAppL,\n  composeAppR,\n  composeFun,\n  markStep\n} from './helpers'\nimport { App, Fun, Term, Var } from './terms'\n\n// Applies the substitution T[x := S]\n// I.e., substitutes the variable x for the term S in the term T.\nexport const substitute = (t: Term, x: string, s: Term): Term => {\n  switch (t.type) {\n    case 'var':\n      // x[x := S] = S\n      // y[x := S] = y\n      return t.name === x ? s : t\n    case 'fun':\n      // (Î»x.E)[x := S] = Î»x.E\n      // Î»x creates a new context for x so no further substitution is needed.\n      if (t.param === x) {\n        return t\n      }\n      // (Î»y.E)[x := S] with x != y\n      // If y is free in S and x is free in E, then must Î±-convert Î»y.E to avoid\n      // name conflicts.\n      if (freeIn(t.param, s) && freeIn(x, t.body)) {\n        // (Î»y.E)[x := S] = Î»y'.(E[y := y'][x := S])\n        const newVarName = renameVar(t.param, t.body, s)\n        const renamedBody = applySubstitution(t.body, t.param, Var(newVarName))\n        return Fun(newVarName, substitute(renamedBody, x, s))\n      } else {\n        // (Î»y.E)[x := S] = Î»y.(E[x := S])\n        return Fun(t.param, substitute(t.body, x, s))\n      }\n    case 'app':\n      // (U V)[x := S] = (U[x := S]) (V[x := S])\n      return App(substitute(t.left, x, s), substitute(t.right, x, s))\n    case 'def':\n      return t\n  }\n}\n\n// Note: renameForSubstitution() and applySubstitution() are the same as\n// substitute(), only split up into two different steps. We need them that way\n// to be able to do all alpha-renaming steps before each beta-reduction, but it\n// would be nice to have these three functions DRY up a bit.\n\n// Performs the Î±-conversions necessary for the substitution T[x := S], but does\n// not perform the substitution itself.\n// Records the Î±-conversions by calling cb.\nexport const renameForSubstitution = (\n  t: Term,\n  x: string,\n  s: Term,\n  cb: Callback\n): Term => {\n  switch (t.type) {\n    case 'var':\n    case 'def':\n      return t\n    case 'fun':\n      if (t.param === x) {\n        return t\n      }\n      if (freeIn(t.param, s) && freeIn(x, t.body)) {\n        const newVarName = renameVar(t.param, t.body, s)\n        const renamedBody = applySubstitution(t.body, t.param, Var(newVarName))\n        cb(\n          markStep({\n            type: 'alpha',\n            before: t,\n            after: (t = Fun(newVarName, renamedBody))\n          })\n        )\n      }\n      const body = renameForSubstitution(t.body, x, s, composeFun(cb, t.param))\n      return Fun(t.param, body)\n    case 'app':\n      const l = renameForSubstitution(t.left, x, s, composeAppR(cb, t.right))\n      const r = renameForSubstitution(t.right, x, s, composeAppL(cb, l))\n      return App(l, r)\n  }\n}\n\n// Applies the substitution T[x := S] directly, without doing Î±-conversions.\nexport const applySubstitution = (t: Term, x: string, s: Term): Term => {\n  switch (t.type) {\n    case 'var':\n      return t.name === x ? s : t\n    case 'fun':\n      return t.param === x ? t : Fun(t.param, applySubstitution(t.body, x, s))\n    case 'app':\n      const l = applySubstitution(t.left, x, s)\n      const r = applySubstitution(t.right, x, s)\n      return App(l, r)\n    case 'def':\n      return t\n  }\n}\n\n// Renames a variable to avoid naming conflicts case doing: a substitution.\nconst renameVar = (oldName: string, t: Term, s: Term) => {\n  // Split the name into base and number part.\n  const base = oldName.replace(/\\d+$/, '')\n  const match = oldName.match(/\\d+$/)\n  let n = match ? parseInt(match[0], 10) : 0\n\n  while (true) {\n    n++\n    const newName = base + n\n    const isValid =\n      // Avoid name collisions with substitution term.\n      !freeIn(newName, s) &&\n      // Avoid name collisions with free variables in body.\n      !freeIn(newName, t) &&\n      // Avoid name collisions with inner functions.\n      !varRenameCollides(t, oldName, newName)\n\n    if (isValid) {\n      return newName\n    }\n  }\n}\n\n// Whether a variable rename collides in a given term. That is, if changing the\n// occurrences of oldName with newName in t would make it change t's meaning\n// (i.e. not be Î±-equivalent).\nconst varRenameCollides = (\n  t: Term,\n  oldName: string,\n  newName: string\n): boolean => {\n  switch (t.type) {\n    case 'var':\n    case 'def':\n      return false\n    case 'fun':\n      // A variable rename collides with this function if the old variable\n      // was free in the function and the new name for the variable is the\n      // same as the param of the function, thus changing old free variable\n      // binding.\n      return (\n        (t.param === newName && freeIn(oldName, t)) ||\n        // Or if the renaming collides in the body of the function.\n        varRenameCollides(t.body, oldName, newName)\n      )\n    case 'app':\n      return (\n        varRenameCollides(t.left, oldName, newName) ||\n        varRenameCollides(t.right, oldName, newName)\n      )\n  }\n}\n","type Var = { type: 'var'; name: string }\ntype Fun = { type: 'fun'; param: string; body: Term }\ntype App = { type: 'app'; left: Term; right: Term }\ntype Def = { type: 'def'; name: string; term: Term }\ntype Term = Var | Fun | App | Def\n\n// Term constructors.\nconst Var = (name: string): Var => ({ type: 'var', name })\nconst Fun = (param: string, body: Term): Fun => ({ type: 'fun', param, body })\nconst App = (left: Term, right: Term): App => ({ type: 'app', left, right })\nconst Def = (name: string, term: Term): Def => ({ type: 'def', name, term })\n\nexport { Term, Var, Fun, App, Def }\n","let logTimings = false\n\nexport const timed = <TS extends any[], R>(\n  name: string,\n  fn: (...args: TS) => R\n) => (...args: TS) => {\n  if (logTimings) {\n    console.time(name)\n  }\n  const res = fn(...args)\n  if (logTimings) {\n    console.timeEnd(name)\n  }\n  return res\n}\n\nexport const enableLogTimings = () => {\n  logTimings = true\n}\nexport const disableLogTimings = () => {\n  logTimings = false\n}\n\nexport const identity = <T>(x: T) => x\n\n// Note: it would be nice to replace this overly-clever function with\n// String.dedent() once it gets standardized. See https://github.com/tc39/proposal-string-dedent\nexport const dedent = (str: string) => {\n  const match = str.match(/^[ \\t]*(?=\\S)/gm)\n  if (!match) {\n    return str\n  }\n\n  const indent = Math.min(...match.map(x => x.length))\n  const re = new RegExp(`^[ \\\\t]{${indent}}`, 'gm')\n  const unindented = indent > 0 ? str.replace(re, '') : str\n\n  return unindented.trim()\n}\n\nexport const collapseWhitespace = (str: string) => str.replace(/\\s+/gm, ' ')\n"]}