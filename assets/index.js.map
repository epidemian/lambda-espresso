{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/app.ts","src/dom.ts","src/examples.ts","src/lambda/alpha-eq.ts","src/lambda/format.ts","src/lambda/free-in.ts","src/lambda/grammar.js","src/lambda/helpers.ts","src/lambda/index.ts","src/lambda/parse.ts","src/lambda/reduce-program.ts","src/lambda/reduce.ts","src/lambda/substitute.ts","src/lambda/terms.ts","src/utils.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","lambda_1","examples_1","__importDefault","utils_1","dom_1","enableLogTimings","input","$","output","document","addEventListener","keyCode","ctrlKey","run","value","replace","start","selectionStart","end","selectionEnd","_","renderTerm","term","className","renderArrow","symbol","label","arrowSymbols","alpha","beta","eta","def","renderSynonyms","synonyms","join","getOptions","maxSteps","parseInt","strategy","etaEnabled","checked","reductions","reduceProgram","renderReductions","err","textContent","message","classList","add","timeIt","innerHTML","map","renderCollapsedReduction","remove","delegate","element","reduction","nodeIndex","totalSteps","expanded","querySelector","collapsed","toggle","renderExpandedReductionForm","prev","previousElementSibling","renderCollapsedReductionForm","initial","arrow","final","finalSynonyms","steps","step","renderStep","renderStepOptions","before","after","arrowSymbol","type","arrowLabel","lastStep","push","highlightStep","highlightFormerTerm","highlightSubstitutionTerm","dedent","focus","examplesMenu","examplesHtml","default","example","href","encodeURI","name","event","preventDefault","scrollTop","examplesDropdown","contains","stopPropagation","once","location","hash","updateInputFromHash","decodeURI","codeStart","indexOf","slice","window","eventType","selector","handler","target","Element","closest","Array","prototype","parentNode","childNodes","examples","terms_1","substitute_1","alphaEq","t1","t2","left","right","param","body","substitute","Var","format","appParens","funParens","highlight","h","identity","highlightVar","lambda","funStr","lStr","rStr","appStr","freeIn","x","grammar","k","v","$V0","$V1","$V2","$V3","$V4","$V5","parser","trace","yy","symbols_","error","root","program","EOF","line","SEPARATOR","ident","=","LAMBDA",".","(",")","IDENT","$accept","$end","terminals_","2","5","7","10","11","12","13","14","15","productions_","performAction","anonymous","yytext","yyleng","yylineno","yystate","$$","_$","$0","this","parseTopLevelTerm","parseDefinition","parseFunction","parseApplication","parseIdentifier","table","3","4","6","8","9","defaultActions","parseError","str","recoverable","_parseError","msg","parse","self","stack","tstack","vstack","lstack","recovering","TERROR","args","arguments","lexer","Object","create","sharedState","hasOwnProperty","setInput","yylloc","yyloc","ranges","options","getPrototypeOf","popStack","_token_stack","lex","token","preErrorSymbol","state","action","yyval","p","len","newState","expected","errStr","showPosition","text","match","loc","first_line","last_line","first_column","last_column","range","apply","concat","openParens","_input","_more","_backtrack","done","matched","conditionStack","offset","ch","lines","unput","split","substr","oldLines","more","reject","backtrack_lexer","less","pastInput","past","upcomingInput","next","pre","c","test_match","indexed_rule","backup","matches","tempMatch","index","rules","_currentRules","flex","begin","condition","popState","pop","conditions","topState","Math","abs","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","YYSTATE","INITIAL","inclusive","Parser","main","commonjsMain","console","log","process","exit","source","readFileSync","normalize","argv","composeFun","fn","b","Fun","composeAppL","App","composeAppR","markStep","assign","Def","parse_1","format_1","reduce_program_1","grammar_1","defs","terms","forEach","resolveTermRefs","refNames","resolveDefRefs","boundNames","free","defName","bound","checkForCircularRefs","collapseWhitespace","boundOnBody","refName","path","circularNote","nextRefs","nextRef","reduce_1","alpha_eq_1","reduceTerm","enough","terminates","last","findSynonyms","expandStep","findStep","highlightFunctionVar","fun","hs","ha","beforeStr","replaceStep","afterStr","hx","ht","replacement","helpers_1","free_in_1","reduce","cb","reduceFunctions","reduced","reduceEta","reduceCallByName","reduceNormal","reduceCallByValue","reduceApplicative","subst","renameCb","renamedBody","renameForSubstitution","renamed","applied","applySubstitution","normal","applicative","cbn","cbv","newVarName","renameVar","oldName","base","newName","isValid","varRenameCollides","logTimings","time","res","timeEnd","disableLogTimings","indent","min","re","RegExp","unindented","trim"],"mappings":"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","sourceRoot":".","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// Script for index.html\nimport { reduceProgram, Options, Reduction } from './lambda'\nimport examples from './examples'\nimport { timeIt, enableLogTimings, dedent } from './utils'\nimport { $, delegate, nodeIndex } from './dom'\n\nenableLogTimings()\n\nlet input = $('.input') as HTMLInputElement\nlet output = $('.output')\n\n// Run code on ctrl+enter.\ndocument.addEventListener('keyup', e => {\n  if (e.keyCode === 13 && e.ctrlKey) {\n    run()\n  }\n})\n\ninput.addEventListener('keyup', () => {\n  // Replace every \"\\\" with \"λ\" while typing.\n  let code = input.value\n  code = code.replace(/\\\\/g, 'λ')\n  // Preserve selection\n  let start = input.selectionStart\n  let end = input.selectionEnd\n  input.value = code\n  input.selectionStart = start\n  input.selectionEnd = end\n})\n\n$('.run').addEventListener('click', _ => run())\n\nlet renderTerm = (term: string, className = '') =>\n  `<span class=\"term ${className}\">${term}</span>`\n\nlet renderArrow = (symbol: string, label: string) =>\n  `<span class=arrow>${symbol}<small>${label}</small></span>`\n\nlet arrowSymbols = {\n  alpha: 'α',\n  beta: 'β',\n  eta: 'η',\n  def: ''\n}\n\nlet renderSynonyms = (synonyms: string[]) =>\n  synonyms.length\n    ? `<span class=synonyms>(${synonyms.join(', ')})</span>`\n    : ''\n\nlet getOptions = (): Options => {\n  let maxSteps = parseInt($<HTMLInputElement>('input[name=max-steps]').value || '0')\n  let strategy = $<HTMLInputElement>('input[name=strategy]:checked').value as Options['strategy']\n  let etaEnabled = $<HTMLInputElement>('[name=eta-reductions]').checked\n  return { maxSteps, strategy, etaEnabled }\n}\n\nlet reductions: Reduction[] = []\nlet run = () => {\n  let code = input.value\n  try {\n    reductions = reduceProgram(code, getOptions())\n    renderReductions()\n  } catch (err) {\n    output.textContent = err.message\n    output.classList.add('error')\n  }\n}\n\nlet renderReductions = () => timeIt('render html', () => {\n  output.innerHTML = reductions.map(renderCollapsedReduction).join('')\n  output.classList.remove('error')\n})\n\ndelegate('click', output, '.reduction', element => {\n  let reduction = reductions[nodeIndex(element)]\n  if (reduction.totalSteps === 0) return\n  let expanded = element.querySelector('.expanded')\n  let collapsed = element.querySelector('.collapsed')\n  if (expanded) {\n    expanded.classList.toggle('hidden')\n    collapsed!.classList.toggle('hidden')\n  } else {\n    collapsed!.classList.add('hidden')\n    element.innerHTML += renderExpandedReductionForm(reduction)\n  }\n})\n\ndelegate('mouseover', output, '.expanded .step', element => {\n  element.classList.add('highlight')\n  // Hide the previous step's after term.\n  let prev = element.previousElementSibling\n  prev && prev.querySelector('.after')!.classList.add('hidden')\n})\n\ndelegate('mouseout', output, '.expanded .step', element => {\n  element.classList.remove('highlight')\n  let prev = element.previousElementSibling\n  prev && prev.querySelector('.after')!.classList.remove('hidden')\n})\n\nlet renderCollapsedReduction = (reduction: Reduction) =>\n  `<div class=reduction>${renderCollapsedReductionForm(reduction)}</div>`\n\nlet renderCollapsedReductionForm = (reduction: Reduction) => {\n  let initial = renderTerm(reduction.initial)\n  let arrow = ''\n  let final = ''\n  if (reduction.totalSteps > 0) {\n    arrow = renderArrow('→', `(${reduction.totalSteps})`)\n    final = renderTerm(reduction.final)\n  }\n  let synonyms = renderSynonyms(reduction.finalSynonyms)\n  return `<div class=collapsed>${initial} ${arrow} ${final} ${synonyms}</div>`\n}\n\nlet renderExpandedReductionForm = (reduction: Reduction) => {\n  let steps = []\n  for (let i = 0; i < reduction.totalSteps; i++) {\n    let step = reduction.renderStep(i, renderStepOptions)\n    let before = renderTerm(step.before, 'before')\n    let after = renderTerm(step.after, 'after')\n    let arrowSymbol = step.type === 'def' ? '≡' : '→'\n    let arrowLabel = arrowSymbols[step.type]\n    let arrow = renderArrow(arrowSymbol, arrowLabel)\n    let lastStep = i === reduction.totalSteps - 1\n    let synonyms = lastStep ? renderSynonyms(reduction.finalSynonyms) : ''\n    steps.push(\n      `<span class=step>${before}<br>${arrow} ${after} ${synonyms}</span>`\n    )\n  }\n\n  return `<div class=expanded>${steps.join('')}</div>`\n}\n\nlet renderStepOptions = {\n  highlightStep: (s: string) => `<span class=match>${s}</span>`,\n  highlightFormerTerm: (s: string) => `<span class=former-term>${s}</span>`,\n  highlightSubstitutionTerm: (s: string) => `<span class=subst-term>${s}</span>`\n}\n\ninput.value = dedent(`\n  ; Write some λ-expressions here and hit Run. Use \"\\\\\" to enter \"λ\" ;)\n  (λx.λy.λz.z y x) a b c\n`)\ninput.focus()\n\nlet examplesMenu = $('.examples-menu')\nlet examplesHtml = examples.map((example, i) => {\n  let href = encodeURI(`#>${example.code}`)\n  return `<li><a href=\"${href}\">${i} - ${example.name}</a></li>`\n})\n\nexamplesMenu.innerHTML = examplesHtml.join('')\ndelegate('click', examplesMenu, 'li', (element, event) => {\n  event.preventDefault() // Don't change the location.hash\n  input.value = examples[nodeIndex(element)].code\n  input.scrollTop = 0\n})\n\nlet examplesDropdown = $('.examples-dropdown')\nexamplesDropdown.addEventListener('click', e => {\n  if (examplesDropdown.classList.contains('active')) return\n  e.stopPropagation()\n  examplesDropdown.classList.add('active')\n  document.addEventListener('click', () => { \n    examplesDropdown.classList.remove('active') \n  }, { once: true })\n})\n\n$('button.link').addEventListener('click', () => {\n  let code = input.value\n  location.hash = `>${code}`\n})\n\nlet updateInputFromHash = () => {\n  let hash = decodeURI(location.hash)\n  let codeStart = hash.indexOf('>')\n  if (codeStart >= 0) {\n    input.value = hash.slice(codeStart + 1)\n  }\n}\n\nwindow.addEventListener('hashchange', updateInputFromHash)\nupdateInputFromHash()\n","export const $ = <T extends Element>(s: string) => \n  document.querySelector(s) as T\n\n// Similar to jQuery.fn.on(type, selector, handler)\nexport const delegate = (\n  eventType: string, \n  element: Element, \n  selector: string, \n  handler: (el: Element, ev: Event) => void\n) => { \n  element.addEventListener(eventType, event => {\n    if (event.target instanceof Element) {\n      let closest = event.target.closest(selector)\n      if (closest && element.contains(closest))\n        handler(closest, event)\n    }\n  })\n}\n\nexport const nodeIndex = (element: Element): number => {\n  return Array.prototype.indexOf.call(element.parentNode!.childNodes, element)\n}\n","import { dedent } from './utils'\n\n/* eslint-disable max-len */\nconst examples = [{\n  name: 'Basics',\n  code: dedent(`\n    ; This example is not intend to be a tutorial nor an introduction to λ Calculus.\n    ; You should check http://en.wikipedia.org/wiki/Lambda_calculus for that :)\n    ; As you can see, these are comments. You can run this example clicking the Run\n    ; button below or pressing Ctrl+Enter.\n    ; So, the three basic types of λ expressions are:\n    ; Variables:\n    x\n    ; Applications:\n    x y\n    ; And lambda abstractions (also known as functions):\n    λx.x\n    ; If the left-side of an application is an abstraction, then a reduction takes place:\n    (λx.x) y\n    ; That little abstraction at the left is the identity, a very simple function that\n    ; just reduces to whatever you apply to it. We can give it a name like so:\n    id = λx.x\n    ; And then just refer it by that name:\n    id a\n    ; You can apply any kind of λ expression to an abstraction, like another function:\n    id λb.c\n    ; Or an application:\n    id (x y)\n    ; Or even the identity function itself:\n    id id\n    ; That means you can apply identity to itself as many times as you want and it'll still\n    ; be identity:\n    id id id id id\n    ; Notice that applications are left-associative, so the line above is equivalent to:\n    ((((id id) id) id) id)\n\n    ; TODO: explain applicative and normal order...\n  `)\n}, {\n  name: 'Booleans',\n  code: dedent(`\n    ; Church booleans\n\n    ; The booleans and their operations can be encoded as the following λ-terms:\n    true = λt.λf.t\n    false = λt.λf.f\n    not = λp.p false true\n    and = λp.λq.p q p\n    or = λp.λq.p p q\n    if = λp.p\n\n    ; Print truth tables for not, and and or:\n    not true\n    not false\n    and false false\n    and false true\n    and true false\n    and true true\n    or false false\n    or false true\n    or true false\n    or true true\n\n    ; Terms can be nested as much as we want:\n    if (not (not true)) (or false (if true true false)) false\n\n    ; There's nothing special about \"operators\", we can treat them as any other value:\n    (if false or and) true false\n  `)\n}, {\n  name: 'Numbers',\n  code: dedent(`\n    ; Church numerals\n\n    ; The first few numbers are:\n    zero = λs.λz.z\n    one = λs.λz.s z\n    two = λs.λz.s (s z)\n    three = λs.λz.s (s (s z))\n    ; In general, any natural number n can be encoded as:\n    ; N = λs.λz.s (s (s ... (s (s z)) ... ))\n    ; with s applied n times.\n\n    ; When we get tired of writing numbers like that, we can define a successor function:\n    succ = λn.λs.λz.s (n s z)\n    succ three\n\n    ; We can think of Church numerals as functions that apply a given function s to a\n    ; given value z a number of times. Zero will apply it 0 times (i.e. it'll give\n    ; us z back untouched) and three will call it 3 times.\n    ; So, we can represent the addition of numbers m and n as first applying n times s to z,\n    ; and then applying m times s to that:\n    add = λm.λn.λs.λz.m s (n s z)\n    add two three\n    ; ...or, more succinctly, as applying n times the successor function on m (or vice versa):\n    add' = λm.λn.n succ m\n    add' two three\n    ; Conversely, we could define the successor function as adding one:\n    succ' = add one\n    succ' three\n\n    ; Multiplication of m by n is applying m times a function that applies s n times:\n    mult = λm.λn.λs.m (n s)\n    mult three three\n    ; ...or applying m times the addition of n to zero:\n    mult' = λm.λn.m (add n) zero\n    mult' three three\n\n    ; Exponentiation n^m has a simple encoding: applying the base m to the exponent n,\n    ; which can be understood as applying m successively n times:\n    exp = λm.λn.n m\n    exp two three\n    ; ...or, alternatively, applying m times the multiplication by n to one:\n    exp' = λm.λn.m (mult n) one\n    exp' two three\n\n    ; The encoding for the predecessor function is quite complex.\n    ; The Wikipedia article on Church encoding has a good explanation for this term ;-)\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    pred three\n\n    ; But given the predecessor function is then easy to define the subtraction:\n    sub = λm.λn.n pred m\n    sub three two\n\n    ; To build some predicate functions, we'll use some known boolean terms (see \n    ; Booleans example for more info):\n    true = λt.λf.t\n    false = λt.λf.f\n    and = λp.λq.p q p\n\n    ; To know if a number n is zero we can pass true as the base value and a function\n    ; that always returns false (note that the \"?\" is no special syntax; it's just \n    ; part of the name of the predicate):\n    zero? = λn.n (λx.false) true\n    zero? zero\n    zero? two\n\n    ; To know if a number is less or equal to another number, we can subtract them and\n    ; see if the result is zero:\n    leq = λm.λn.zero? (sub m n)\n\n    ; And given that predicate, numeric equality between m and n can be defined as:\n    eq = λm.λn.and (leq m n) (leq n m)\n\n    ; Throwing everything into the mix, we can prove that 2³ = 3² - 1:\n    eq (exp two three) (pred (exp three two))\n  `)\n}, {\n  name: 'Factorial',\n  code: dedent(`\n    ; Factorial function and recursion\n\n    ; Note: for this example we'll use boolean and numeric terms from previous \n    ; examples (see below). \n    ; Also not that these factorial definitions won't work with applicative order ;)\n\n    ; We'd like to be able to define a factorial function as:\n    ; fact = λn.if (zero? n) one (mult n (fact (pred n)))\n    ; But we can't use a term in its own definition.\n    ; To achieve recursion, we can instead define a function that will receive itself\n    ; as a parameter r, and then recur by calling r with itself and n - 1:\n    fact-rec = λr.λn.if (zero? n) one (mult n (r r (pred n)))\n    ; The real factorial function would then be:\n    fact = fact-rec fact-rec\n    fact four\n\n    ; Another way to recur is to use a general purpose fixed-point combinator.\n    ; The almighty Y Combinator:\n    Y = λf.(λx.f (x x)) (λx.f (x x))\n    ; And then there's no need to define a separate function:\n    fact' = Y λr.λn.if (zero? n) one (mult n (r (pred n)))\n    fact' four\n\n    ; Borrow some terms from previous examples:\n    true = λt.λf.t\n    false = λt.λf.f\n    if = λp.p\n    zero = λs.λz.z\n    one = λs.λz.s z\n    two = λs.λz.s (s z)\n    three = λs.λz.s (s (s z))\n    four = λs.λz.s (s (s (s z)))\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    mult = λm.λn.λs.m (n s)\n    zero? = λn.n (λx.false) true\n  `)\n}, {\n  name: 'Extras',\n  code: dedent(`\n    ; Syntactic Trivia and Miscellaneous\n  \n    ; Identifiers can contain basically any character (except the few ones reserved for \n    ; syntax: \"λ\", \".\", \"=\", \"(\" and \")\").\n    ; This means you can write some pretty code-looking lambda terms!\n    0 = λs.λz.z\n    1 = λs.λz.s z\n    2 = λs.λz.s (s z)\n    + = λm.λn.λs.λz.m s (n s z)\n    * = λm.λn.λs.m (n s)\n    (+ (* 2 1) 0)\n    ; Reinventing (a part of) Lisp is always fun...\n\n    ; You can even use emojis as identifiers! But make sure to use this power responsibly.\n    (λ🐴.❓) 🍎\n\n    ; Although line breaks usually act as separators between terms/definitions, \n    ; you can use parentheses to split a complex term into multiple lines:\n    fib = Y λf.λn.(\n      if (≤ n 1)\n         n\n         (+ (f (- n 1))\n            (f (- n 2))))\n    fib 0\n    fib 1\n    fib 2\n    fib 7\n\n    ; The rest of the definitions to make the above code work. Not much to see here...\n    Y = λf.(λx.f (x x)) (λx.f (x x))\n    - = λm.λn.n pred m\n    ≤ = λm.λn.zero? (- m n)\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    zero? = λn.n (λx.false) true\n    true = λt.λf.t\n    false = λt.λf.f\n    if = λp.p\n    7 = λs.λz.s (s (s (s (s (s (s z))))))\n    13 = λs.λz.s (s (s (s (s (s (s (s (s (s (s (s (s z))))))))))))\n    ❓ = λ💩.💩 💩 💩\n  `)\n}]\n\nexport default examples","import { Term, Var } from './terms'\nimport { substitute } from './substitute'\n\n// Whether two terms are alpha-equivalent.\nconst alphaEq = (t1: Term, t2: Term): boolean => {\n  if (t1.type === 'def')\n    return alphaEq(t1.term, t2)\n  if (t2.type === 'def') \n    return alphaEq(t1, t2.term)\n  if (t1.type === 'var' && t2.type === 'var') \n    return t1.name === t2.name\n  if (t1.type === 'app' && t2.type === 'app') \n    return alphaEq(t1.left, t2.left) && alphaEq(t1.right, t2.right)\n  if (t1.type === 'fun' && t2.type === 'fun') {\n    if (t1.param === t2.param) {\n      return alphaEq(t1.body, t2.body)\n    } else {\n      return alphaEq(t1.body, substitute(t2.body, t2.param, Var(t1.param)))\n    }\n  }\n  return false\n}\n\nexport default alphaEq\n","import { Term } from './terms'\nimport { identity } from '../utils'\n\n// Returns the string representation for a given term t.\nconst format = (t: Term, appParens = false, funParens = false): string => {\n  // TODO: Remove highlighting hack of storing data on terms.\n  let { highlight: h = identity, highlightVar } = t as any\n  switch (t.type) {\n  case 'var':\n  case 'def':\n    return h(t.name)\n  case 'fun':\n    let lambda = `λ${t.param}`\n    if (highlightVar) lambda = highlightVar(lambda)\n    let funStr = `${lambda}.${format(t.body)}`\n    return h(funParens ? `(${funStr})` : funStr)\n  case 'app':\n    let lStr = format(t.left, false, true)\n    let rStr = format(t.right, true, funParens)\n    let appStr = `${lStr} ${rStr}`\n    return h(appParens ? `(${appStr})` : appStr)\n  }\n}\n\nexport default format\n","import { Term } from './terms'\n\n// Whether the variable x appears free in the term t.\nconst freeIn = (x: string, t: Term): boolean => {\n  switch (t.type) {\n  case 'var':\n    return t.name === x\n  case 'fun':\n    return t.param !== x && freeIn(x, t.body)\n  case 'app':\n    return freeIn(x, t.left) || freeIn(x, t.right)\n  case 'def':\n    // Definitions don't have free variables.\n    return false\n  }\n}\n\nexport default freeIn","/* parser generated by jison 0.4.17 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar grammar = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[5,7],$V1=[1,6],$V2=[1,7],$V3=[1,8],$V4=[2,10],$V5=[5,7,11,13,14,15];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"root\":3,\"program\":4,\"EOF\":5,\"line\":6,\"SEPARATOR\":7,\"term\":8,\"ident\":9,\"=\":10,\"LAMBDA\":11,\".\":12,\"(\":13,\")\":14,\"IDENT\":15,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",7:\"SEPARATOR\",10:\"=\",11:\"LAMBDA\",12:\".\",13:\"(\",14:\")\",15:\"IDENT\"},\nproductions_: [0,[3,2],[4,0],[4,1],[4,2],[4,3],[6,1],[6,3],[8,4],[8,2],[8,1],[8,3],[9,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\n /* do nothing; terms and definitions already collected */ \nbreak;\ncase 6:\n this.$ = yy.parseTopLevelTerm($$[$0]); \nbreak;\ncase 7:\n this.$ = yy.parseDefinition($$[$0-2], $$[$0]); \nbreak;\ncase 8:\n this.$ = yy.parseFunction($$[$0-2], $$[$0]); \nbreak;\ncase 9:\n this.$ = yy.parseApplication($$[$0-1], $$[$0]); \nbreak;\ncase 10:\n this.$ = yy.parseIdentifier($$[$0]); \nbreak;\ncase 11:\n this.$ = $$[$0-1]; \nbreak;\ncase 12:\n this.$ = yytext; \nbreak;\n}\n},\ntable: [o($V0,[2,2],{3:1,4:2,6:3,8:4,9:5,11:$V1,13:$V2,15:$V3}),{1:[3]},{5:[1,9],7:[1,10]},o($V0,[2,3]),o($V0,[2,6],{8:11,9:12,11:$V1,13:$V2,15:$V3}),o([5,7,11,13,15],$V4,{10:[1,13]}),{9:14,15:$V3},{8:15,9:12,11:$V1,13:$V2,15:$V3},o([5,7,10,11,12,13,14,15],[2,12]),{1:[2,1]},o($V0,[2,4],{8:4,9:5,6:16,11:$V1,13:$V2,15:$V3}),o($V5,[2,9],{8:11,9:12}),o($V5,$V4),{8:17,9:12,11:$V1,13:$V2,15:$V3},{12:[1,18]},{8:11,9:12,11:$V1,13:$V2,14:[1,19],15:$V3},o($V0,[2,5]),o($V0,[2,7],{8:11,9:12,11:$V1,13:$V2,15:$V3}),{8:20,9:12,11:$V1,13:$V2,15:$V3},o($V5,[2,11]),o([5,7,14],[2,8],{8:11,9:12,11:$V1,13:$V2,15:$V3})],\ndefaultActions: {9:[2,1]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        function _parseError (msg, hash) {\n            this.message = msg;\n            this.hash = hash;\n        }\n        _parseError.prototype = Error;\n\n        throw new _parseError(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n var openParens = 0; /* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0: openParens++; return 13; \nbreak;\ncase 1: openParens--; return 14; \nbreak;\ncase 2: return 11; \nbreak;\ncase 3: return 12; \nbreak;\ncase 4: return 10; \nbreak;\ncase 5: /* ignore separators inside parens */\n                   if (openParens <= 0) return 7\n                 \nbreak;\ncase 6: /* ignore whitespace */ \nbreak;\ncase 7: /* ignore line comments */ \nbreak;\ncase 8: return 15; \nbreak;\ncase 9: return 5; \nbreak;\n}\n},\nrules: [/^(?:\\()/,/^(?:\\))/,/^(?:\\\\|λ)/,/^(?:\\.)/,/^(?:=)/,/^(?:\\n)/,/^(?:[^\\S\\n]+)/,/^(?:;.*)/,/^(?:[^\\s\\(\\)\\\\λ\\.=]+)/,/^(?:$)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = grammar;\nexports.Parser = grammar.Parser;\nexports.parse = function () { return grammar.parse.apply(grammar, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}","import { Term, Fun, App, Def } from './terms'\n\nexport type Callback = (t: Term) => void\n\n// Compose a callback function with a term constructor.\nexport const composeFun = (fn: Callback, x: string) => (b: Term) => fn(Fun(x, b))\nexport const composeAppL = (fn: Callback, l: Term) => (r: Term) => fn(App(l, r))\nexport const composeAppR = (fn: Callback, r: Term) => (l: Term) => fn(App(l, r))\n\nexport type Definitions = { [key: string]: Term }\n\n// Represents a reduction \"step\" as displayed on the application.\nexport type Step =\n  | { type: 'alpha', before: Fun, after: Fun }\n  | { type: 'beta', before: App, after: Term }\n  | { type: 'eta' , before: Fun, after: Term }\n  | { type: 'def' , before: Def, after: Term }\n\n// Mark a reduction step on the `after` term.\nexport const markStep = (step: Step) => ({ ...step.after, step })\n","export { Var, Fun, App, Def } from './terms'\nexport { default as parse } from './parse'\nexport { default as format } from './format'\nexport { reduceProgram, Reduction, Options } from './reduce-program'","import { Term, Fun, App } from './terms'\nimport { timeIt, collapseWhitespace } from '../utils'\nimport { Parser } from './grammar'\nimport { Definitions } from './helpers';\n\n// Parses an input program string and returns an object with the top-level terms\n// and definitions of the program.\nconst parse = (str: string) => timeIt('parse', () => {\n  // A custom Jison parser.\n  let parser = new Parser()\n\n  // A definition table with the definition term by their names.\n  let defs: Definitions = {}\n  // The terms of the program.\n  let terms: Term[] = []\n\n  // Add some handy functions so the parser can build the AST.\n  parser.yy = {\n    parseFunction: Fun,\n    parseApplication: App,\n    parseDefinition: (name: string, term: Term) => {\n      if (defs[name]) throw Error(`${name} already defined`)\n      defs[name] = term\n    },\n    parseTopLevelTerm: (term: Term) => {\n      terms.push(term)\n    },\n    parseIdentifier: (name: string) => ({ type: 'ref', name })\n  }\n\n  parser.parse(str)\n\n  terms.forEach(t => resolveTermRefs(t, defs))\n\n  let refNames = {}\n  for (let name in defs) {\n    resolveDefRefs(name, defs[name], defs, refNames)\n  }\n\n  return {defs, terms}\n})\n\nexport default parse\n\n// Temporary term used only while parsing as a placeholder for wither a Var o a\n// Ref. On the first pass the parser cannot know if an identifier is a variable\n// or a definition (because definitions can be declared after their use), so it\n// stores a Ref instead and then on a second pass decides what it should be and\n// *mutates* the Ref in-place to become either a Var or a Ref.\n// TODO: Remove this hack.\ntype TermOrRef = Term | { type: 'ref', name: string }\n\n// Changes all Refs inside term t to either Vars or Defs.\nlet resolveTermRefs = (\n  t: TermOrRef, defs: Definitions, boundNames: string[] = []\n) => {\n  switch (t.type) {\n  case 'ref':\n    let free = boundNames.indexOf(t.name) < 0\n    if (t.name in defs && free) {\n      Object.assign(t, { type: 'def', term: defs[t.name] })\n    } else {\n      Object.assign(t, { type: 'var' })\n    }\n    break\n  case 'app':\n    resolveTermRefs(t.left, defs, boundNames)\n    resolveTermRefs(t.right, defs, boundNames)\n    break\n  case 'fun':\n    resolveTermRefs(t.body, defs, boundNames.concat(t.param))\n    break\n  }\n}\n \ntype RefNames = { [key: string]: string[] }\n\n// Changes all Refs inside term t to either Vars or Defs.\nlet resolveDefRefs = (\n  defName: string, \n  t: TermOrRef, \n  defs: Definitions, \n  refNames: RefNames, \n  boundNames: string[] = []\n) => {\n  switch (t.type) {\n  case 'ref':\n    let bound = boundNames.indexOf(t.name) >= 0\n    if (bound) {\n      Object.assign(t, { type: 'var' })\n    } else if (t.name in defs) {\n      refNames[defName] = [...refNames[defName] || [], t.name]\n      checkForCircularRefs(defName, t.name, refNames)\n      Object.assign(t, { type: 'def', term: defs[t.name]})\n    } else {\n      throw Error(collapseWhitespace(\n        `Illegal free variable \"${t.name}\" in \"${defName}\". \n        Definitions cannot have free variables.`\n      ))\n    }\n    break\n  case 'app':\n    resolveDefRefs(defName, t.left, defs, refNames, boundNames)\n    resolveDefRefs(defName, t.right, defs, refNames, boundNames)\n    break\n  case 'fun':\n    let boundOnBody = boundNames.concat(t.param)\n    resolveDefRefs(defName, t.body, defs, refNames, boundOnBody)\n    break\n  }\n}\n\nlet checkForCircularRefs = (\n  name: string, refName: string, refNames: RefNames, path: string[] = []\n) => {\n  if (name === refName) {\n    let circularNote = path.length\n      ? `In this case the definition does not reference itself directly, but \n        through other definitions: ${[name, ...path, name].join(' → ')}.`\n      : ''\n    throw Error(collapseWhitespace(\n      `Illegal recursive reference in \"${name}\". Definitions cannot\n      reference themselves; they are just simple find&replace mechanisms.\n      ${circularNote}\n      If you want to write a recursive function, look for \"Y combinator\" ;)`\n    ))\n  }\n\n  let nextRefs = refNames[refName] || []\n  nextRefs.forEach(nextRef =>\n    checkForCircularRefs(name, nextRef, refNames, [...path, refName])\n  )\n}\n","import { identity, timeIt } from '../utils'\nimport { Var, Fun, App, Term } from './terms'\nimport parse from './parse'\nimport reduce, { Options as ReduceOptions } from './reduce'\nimport { substitute } from './substitute'\nimport format from './format'\nimport alphaEq from './alpha-eq'\nimport { Step, Definitions } from './helpers';\n\nexport type Options = Partial<ReduceOptions> & {\n  maxSteps?: number\n}\n\nexport type Reduction = {\n  initial: string\n  final: string\n  finalSynonyms: string[]\n  terminates: boolean\n  totalSteps: number\n  renderStep: (i: number, options: RenderStepOptions) => RenderedStep\n}\n\ntype RenderStepOptions = {\n  highlightFormerTerm?: StrFun,\n  highlightSubstitutionTerm?: StrFun,\n  highlightStep?: StrFun\n}\n\ntype StrFun = (s: string) => string\n\ntype RenderedStep = {\n  type: \"alpha\" | \"beta\" | \"eta\" | \"def\"\n  before: string\n  after: string\n}\n\n// Reduce a program and return with the reduction for each term in the program.\nexport const reduceProgram = (program: string, options: Options = {}) => {\n  let { terms, defs } = parse(program)\n  return terms.map(term => reduceTerm(term, defs, options))\n}\n\n// Reduces a term up to its normal form.\nlet reduceTerm = (term: Term, defs: Definitions, options: Options): Reduction => timeIt('reduce', () => {\n  const { maxSteps = 100, strategy = 'normal', etaEnabled = false } = options\n  let enough = {}\n  let steps: Term[] = []\n  let terminates = false\n  try {\n    reduce(term, { strategy, etaEnabled }, step => {\n      if (steps.length >= maxSteps) throw enough\n      steps.push(step)\n    })\n    terminates = true\n  } catch (e) {\n    if (e !== enough) throw e\n    terminates = false\n  }\n\n  let last = steps[steps.length - 1] || term\n  let finalSynonyms = findSynonyms(last, defs)\n  let initial = format(term)\n  let final = format(last)\n  let totalSteps = steps.length\n  let renderStep = (i: number, options: RenderStepOptions) =>\n    expandStep(steps[i], options)\n  return { initial, final, finalSynonyms, terminates, totalSteps, renderStep }\n})\n\nlet expandStep = (t: Term, options: RenderStepOptions = {}) => {\n  let step = findStep(t)\n  if (!step) throw new Error('Unexpected: term should always have a step')\n\n  let before: Term = step.before\n  let after: Term = step.after\n\n  let {\n    highlightFormerTerm = identity,\n    highlightSubstitutionTerm = identity,\n    highlightStep = identity\n  } = options\n\n  switch (step.type) {\n  case 'alpha':\n    before = highlightFunctionVar(step.before.body, step.before.param, highlightFormerTerm)\n    after = highlightFunctionVar(step.after.body, step.after.param, highlightSubstitutionTerm)\n    break\n  case 'beta':\n    let fun = step.before.left as Fun\n    let hs = highlight(step.before.right, highlightSubstitutionTerm)\n    let ha = highlightFunctionVar(fun.body, fun.param, highlightFormerTerm)\n    before = App(ha, hs)\n    after = substitute(fun.body, fun.param, hs)\n    break\n  case 'eta':\n  case 'def':\n    before = highlight(step.before, highlightFormerTerm)\n    after = highlight(step.after, highlightSubstitutionTerm)\n    break\n  }\n\n  before = highlight(before, highlightStep)\n  after = highlight(after, highlightStep)\n\n  let beforeStr = format(replaceStep(t, before))\n  let afterStr = format(replaceStep(t, after))\n\n  return { type: step.type, before: beforeStr, after: afterStr }\n}\n\nlet highlight = (t: Term, fn: StrFun) => {\n  let h: StrFun = (t as any).highlight\n  let highlight: StrFun = h ? s => fn(h(s)) : fn\n  return { ...t, highlight }\n}\n\nlet highlightFunctionVar = (t: Term, x: string, fn: StrFun) => {\n  let hx = highlight(Var(x), fn)\n  let ht = substitute(t, x, hx)\n  return { ...Fun(x, ht), highlightVar: fn }\n}\n\nlet findStep = (t: Term): Step | undefined => {\n  let { step } = t as any \n  if (step) return step\n\n  switch (t.type) {\n  case 'fun':\n    return findStep(t.body)\n  case 'app':\n    return findStep(t.left) || findStep(t.right)\n  }\n}\n\nlet replaceStep = (t: Term, replacement: Term): Term => {\n  if ((t as any).step) return replacement\n\n  switch (t.type) {\n  case 'var':\n  case 'def':\n    return t\n  case 'fun':\n    let body = replaceStep(t.body, replacement)\n    return t.body === body ? t : Fun(t.param, body)\n  case 'app':\n    let l = replaceStep(t.left, replacement)\n    if (t.left !== l) return App(l, t.right)\n    let r = replaceStep(t.right, replacement)\n    return t.right === r ? t : App(l, r)\n  }\n}\n\nlet findSynonyms = (term: Term, defs: Definitions) => {\n  let synonyms = []\n  for (let name in defs) {\n    if (alphaEq(term, defs[name])) {\n      synonyms.push(name)\n    }\n  }\n  return synonyms\n}\n\n","import { Fun, App, Term } from './terms'\nimport { renameForSubstitution, applySubstitution } from './substitute'\nimport { markStep, composeFun, composeAppL, composeAppR, Callback } from './helpers'\nimport freeIn from './free-in'\n\nexport type Options = {\n  strategy: keyof typeof reduceFunctions\n  etaEnabled: boolean\n}\n\nconst reduce = (t: Term, { strategy, etaEnabled }: Options, cb: Callback) => {\n  let reduce = reduceFunctions[strategy]\n  let reduced = reduce(t, cb)\n  if (etaEnabled) {\n    reduced = reduceEta(reduced, cb)\n  }\n  return reduced\n}\n\nexport default reduce\n\ntype Reducer = (t: Term, cb: Callback) => Term\n\nlet reduceCallByName: Reducer = (t, cb) => {\n  switch (t.type) {\n  case 'var':\n  case 'fun':\n    return t\n  case 'app':\n    let l = reduceCallByName(t.left, composeAppR(cb, t.right))\n    return l.type === 'fun'\n      ? reduceCallByName(apply(l, t.right, cb), cb)\n      // TODO This is suspicious. If some reductions were made in previous\n      // l = reduceCallByName ... call, then we are losing the result of those\n      // reductions, but we have recorded them with cb.\n      : App(l, t.right)\n  case 'def':\n    cb(markStep({ type: 'def', before: t, after: t.term }))\n    return reduceCallByName(t.term, cb)\n  }\n}\n\nlet reduceNormal: Reducer = (t, cb) => {\n  switch (t.type) {\n  case 'var':\n    return t\n  case 'fun':\n    return Fun(t.param, reduceNormal(t.body, composeFun(cb, t.param)))\n  case 'app':\n    let l = reduceCallByName(t.left, composeAppR(cb, t.right))\n    if (l.type === 'fun') {\n      return reduceNormal(apply(l, t.right, cb), cb)\n    } else {\n      l = reduceNormal(l, composeAppR(cb, t.right)) // Finish reducing l.\n      let r = reduceNormal(t.right, composeAppL(cb, l))\n      return App(l, r)\n    }\n  case 'def':\n    cb(markStep({ type: 'def', before: t, after: t.term }))\n    return reduceNormal(t.term, cb)\n  }\n}\n\nlet reduceCallByValue: Reducer = (t, cb) => {\n  switch (t.type) {\n  case 'var':\n  case 'fun':\n    return t\n  case 'app':\n    let l = reduceCallByValue(t.left, composeAppR(cb, t.right))\n    let r = reduceCallByValue(t.right, composeAppL(cb, l))\n    return l.type === 'fun'\n      ? reduceCallByValue(apply(l, r, cb), cb)\n      : App(l, r)\n  case 'def':\n    cb(markStep({ type: 'def', before: t, after: t.term }))\n    return reduceCallByValue(t.term, cb)\n  }\n}\n\nlet reduceApplicative: Reducer = (t, cb) => {\n  switch (t.type) {\n  case 'var':\n    return t\n  case 'fun':\n    return Fun(t.param, reduceApplicative(t.body, composeFun(cb, t.param)))\n  case 'app':\n    let l = reduceCallByValue(t.left, composeAppR(cb, t.right))\n    if (l.type === 'fun') {\n      let r = reduceCallByValue(t.right, composeAppL(cb, l))\n      return reduceApplicative(apply(l, r, cb), cb)\n    } else {\n      l = reduceApplicative(l, composeAppR(cb, t.right))\n      let r = reduceApplicative(t.right, composeAppL(cb, l))\n      return App(l, r)\n    }\n  case 'def':\n    cb(markStep({ type: 'def', before: t, after: t.term }))\n    return reduceApplicative(t.term, cb)\n  }\n}\n\nlet apply = (fun: Fun, subst: Term, cb: Callback) => {\n  let renameCb = composeFun(composeAppR(cb, subst), fun.param)\n  let renamedBody = renameForSubstitution(fun.body, fun.param, subst, renameCb)\n  let renamed = App(Fun(fun.param, renamedBody), subst)\n  let applied = applySubstitution(renamedBody, fun.param, subst)\n  cb(markStep({ type: 'beta', before: renamed, after: applied }))\n  return applied\n}\n\n// Performs any available η-reductions on a term.\nlet reduceEta: Reducer = (t, cb) => {\n  switch (t.type) {\n  case 'var':\n    return t\n  case 'fun':\n    // λx.(F x) = F if x is free in F\n    if (t.body.type === 'app' &&\n        t.body.right.type === 'var' &&\n        t.body.right.name === t.param &&\n        !freeIn(t.param, t.body.left)) {\n      cb(markStep({ type: 'eta', before: t, after: t.body.left }))\n      return t.body.left\n    } else {\n      return Fun(t.param, reduceEta(t.body, composeFun(cb, t.param)))\n    }\n  case 'app':\n    let l = reduceEta(t.left, composeAppR(cb, t.right))\n    let r = reduceEta(t.right, composeAppR(cb, l))\n    return App(l, r)\n  case 'def':\n    return t\n  }\n}\n\nlet reduceFunctions = {\n  normal: reduceNormal,\n  applicative: reduceApplicative,\n  cbn: reduceCallByName,\n  cbv: reduceCallByValue\n}\n","import { Term, Var, Fun, App } from './terms'\nimport { markStep, composeFun, composeAppL, composeAppR, Callback } from './helpers'\nimport freeIn from './free-in'\n\n// Applies the substitution T[x := S]\n// I.e., substitutes the variable x for the term S in the term T.\nexport const substitute = (t: Term, x: string, s: Term): Term => {\n  switch (t.type) {\n  case 'var':\n    // x[x := S] = S\n    // y[x := S] = y\n    return t.name === x ? s : t\n  case 'fun':\n    // (λx.E)[x := S] = λx.E\n    // λx creates a new context for x so no further substitution is needed.\n    if (t.param === x) return t\n    // (λy.E)[x := S] with x != y\n    // If y is free in S and x is free in E, then must α-convert λy.E to avoid\n    // name conflicts.\n    if (freeIn(t.param, s) && freeIn(x, t.body)) {\n      // (λy.E)[x := S] = λy'.(E[y := y'][x := S])\n      let newVarName = renameVar(t.param, t.body, s)\n      let renamedBody = applySubstitution(t.body, t.param, Var(newVarName))\n      return Fun(newVarName, substitute(renamedBody, x, s))\n    } else {\n      // (λy.E)[x := S] = λy.(E[x := S])\n      return Fun(t.param, substitute(t.body, x, s))\n    }\n  case 'app':\n    // (U V)[x := S] = (U[x := S]) (V[x := S])\n    return App(substitute(t.left, x, s), substitute(t.right, x, s))\n  case 'def':\n    return t\n  }\n}\n\n// Note: renameForSubstitution() and applySubstitution() are the same as\n// substitute(), only split up into two different steps. We need them that way\n// to be able to do all alpha-renaming steps before each beta-reduction, but it\n// would be nice to have these three functions DRY up a bit.\n\n// Performs the α-conversions necessary for the substitution T[x := S], but does\n// not perform the substitution itself.\n// Records the α-conversions by calling cb.\nexport const renameForSubstitution = (t: Term, x: string, s: Term, cb: Callback): Term => {\n  switch (t.type) {\n  case 'var':\n  case 'def':\n    return t\n  case 'fun':\n    if (t.param === x) return t\n    if (freeIn(t.param, s) && freeIn(x, t.body)) {\n      let newVarName = renameVar(t.param, t.body, s)\n      let renamedBody = applySubstitution(t.body, t.param, Var(newVarName))\n      cb(markStep({ type: 'alpha', before: t, after: t = Fun(newVarName, renamedBody) }))\n    }\n    let body = renameForSubstitution(t.body, x, s, composeFun(cb, t.param))\n    return Fun(t.param, body)\n  case 'app':\n    let l = renameForSubstitution(t.left, x, s, composeAppR(cb, t.right))\n    let r = renameForSubstitution(t.right, x, s, composeAppL(cb, l))\n    return App(l, r)\n  }\n}\n\n// Applies the substitution T[x := S] directly, without doing α-conversions.\nexport const applySubstitution = (t: Term, x: string, s: Term): Term => {\n  switch (t.type) {\n  case 'var':\n    return t.name === x ? s : t\n  case 'fun':\n    return t.param === x\n      ? t\n      : Fun(t.param, applySubstitution(t.body, x, s))\n  case 'app':\n    let l = applySubstitution(t.left, x, s)\n    let r = applySubstitution(t.right, x, s)\n    return App(l, r)\n  case 'def':\n    return t\n  }\n}\n\n// Renames a variable to avoid naming conflicts case doing: a substitution.\nlet renameVar = (oldName: string, t: Term, s: Term) => {\n  // Split the name into base and number part.\n  let base = oldName.replace(/\\d+$/, '')\n  let match = oldName.match(/\\d+$/)\n  let n = match ? parseInt(match[0]) : 0\n\n  while (true) {\n    n++\n    let newName = base + n\n    let isValid =\n      // Avoid name collisions with substitution term.\n      !freeIn(newName, s) &&\n      // Avoid name collisions with free variables in body.\n      !freeIn(newName, t) &&\n      // Avoid name collisions with inner functions.\n      !varRenameCollides(t, oldName, newName)\n\n    if (isValid) return newName\n  }\n}\n\n// Whether a variable rename collides in a given term. That is, if changing the\n// occurrences of oldName with newName in t would make it change t's meaning\n// (i.e. not be α-equivalent).\nlet varRenameCollides = (t: Term, oldName: string, newName: string): boolean => {\n  switch (t.type) {\n  case 'var':\n  case 'def':\n    return false\n  case 'fun':\n    // A variable rename collides with this function if the old variable\n    // was free in the function and the new name for the variable is the\n    // same as the param of the function, thus changing old free variable\n    // binding.\n    return t.param === newName && freeIn(oldName, t) ||\n      // Or if the renaming collides in the body of the function.\n      varRenameCollides(t.body, oldName, newName)\n  case 'app':\n    return varRenameCollides(t.left, oldName, newName) ||\n      varRenameCollides(t.right, oldName, newName)\n  }\n}\n","type Var = { type: 'var', name: string }\ntype Fun = { type: 'fun', param: string, body: Term }\ntype App = { type: 'app', left: Term, right: Term }\ntype Def = { type: 'def', name: string, term: Term }\ntype Term = Var | Fun | App | Def\n\n// Term constructors.\nconst Var = (name: string): Var => ({type: 'var', name})\nconst Fun = (param: string, body: Term): Fun => ({type: 'fun', param, body})\nconst App = (left: Term, right: Term): App => ({type: 'app', left, right})\nconst Def = (name: string, term: Term): Def => ({type: 'def', name, term})\n\nexport { Term, Var, Fun, App, Def }\n","let logTimings = false\n\n// TODO: Maybe this could be a function decorator?\nexport const timeIt = <T>(name: string, fn: () => T) => {\n  logTimings && console.time(name)\n  let res = fn()\n  logTimings && console.timeEnd(name)\n  return res\n}\n\nexport const enableLogTimings = () => { logTimings = true }\nexport const disableLogTimings = () => { logTimings = false }\n\nexport const identity = <T>(x: T) => x\n\n// TODO: Maybe this could be a tagged template string function :)\nexport const dedent = (str: string) => {\n  let match = str.match(/^[ \\t]*(?=\\S)/gm)\n\n  if (!match) return str\n\n  let indent = Math.min(...match.map(x => x.length))\n  let re = new RegExp(`^[ \\\\t]{${indent}}`, 'gm')\n  let unindented = indent > 0 ? str.replace(re, '') : str\n\n  return unindented.trim()\n}\n\nexport const collapseWhitespace = (str: string) => str.replace(/\\s+/gm, ' ')\n"]}