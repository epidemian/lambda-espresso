{"version":3,"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","module","dom_1","examples_1","__importDefault","lambda_1","utils_1","enableLogTimings","input","$","HTMLTextAreaElement","output","document","addEventListener","keyCode","ctrlKey","run","event","data","includes","preventDefault","replaced","replace","start","selectionStart","end","selectionEnd","value","slice","_","renderTerm","term","className","renderArrow","symbol","label","arrowSymbols","def","alpha","beta","eta","renderSynonyms","synonyms","join","getOptions","maxReductionSteps","parseInt","HTMLInputElement","strategy","etaEnabled","checked","reductions","reduceProgram","renderReductions","err","textContent","message","String","classList","add","timed","innerHTML","map","renderCollapsedReduction","remove","delegate","element","reduction","nodeIndex","totalSteps","expanded","querySelector","collapsed","toggle","renderExpandedReductionForm","prev","previousElementSibling","renderCollapsedReductionForm","initial","arrow","reductionSteps","final","finalSynonyms","steps","isLast","step","renderStep","renderStepOptions","before","after","arrowSymbol","arrowLabel","type","push","highlightStep","s","highlightFormerTerm","highlightSubstitutionTerm","dedent","focus","examplesMenu","examplesHtml","default","example","href","encodeURI","name","scrollTop","examplesDropdown","contains","stopPropagation","once","encodeURIComponent","location","hash","updateInputFromHash","decodeURIComponent","codeStart","indexOf","window","selector","elementCtor","Element","TypeError","eventType","handler","target","closest","Array","prototype","parentNode","childNodes","examples","substitute_1","terms_1","alphaEq","t1","t2","left","right","param","body","substitute","Var","format","appParens","funParens","highlight","h","identity","highlightVar","lambda","funStr","lStr","rStr","appStr","freeIn","x","grammar","k","v","l","$V0","$V1","$V2","$V3","$V4","$V5","parser","trace","yy","symbols_","error","root","program","EOF","line","SEPARATOR","ident","LAMBDA","IDENT","$accept","$end","terminals_","productions_","performAction","anonymous","yytext","yyleng","yylineno","yystate","$$","_$","$0","this","parseTopLevelTerm","parseDefinition","parseFunction","parseApplication","parseIdentifier","table","defaultActions","parseError","str","recoverable","parse","self","stack","tstack","vstack","lstack","recovering","TERROR","args","arguments","lexer","Object","create","sharedState","hasOwnProperty","setInput","yylloc","yyloc","ranges","options","getPrototypeOf","popStack","_token_stack","lex","token","preErrorSymbol","state","action","yyval","len","newState","expected","errStr","showPosition","text","match","loc","first_line","last_line","first_column","last_column","range","apply","concat","_input","_more","_backtrack","done","matched","conditionStack","offset","ch","lines","unput","split","substr","oldLines","more","reject","backtrack_lexer","less","pastInput","past","upcomingInput","next","pre","test_match","indexed_rule","backup","matches","tempMatch","index","rules","_currentRules","flex","begin","condition","popState","pop","conditions","topState","Math","abs","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","YYSTATE","openParens","INITIAL","inclusive","Parser","main","commonjsMain","console","log","process","exit","source","readFileSync","normalize","argv","composeFun","fn","b","Fun","composeAppL","App","composeAppR","markStep","__exportStar","parse_1","defineProperty","enumerable","get","format_1","reduce_program_1","grammar_1","defs","terms","forEach","resolveTermRefs","refNames","keys","resolveDefRefs","boundNames","free","assign","defName","bound","checkForCircularRefs","boundOnBody","refName","path","refCycle","nextRefs","nextRef","alpha_eq_1","reduce_1","reduceTerm","enough","terminates","stepTerm","findStep","last","findSynonyms","expandStep","highlightFunctionVar","fun","hs","ha","beforeStr","replaceStep","afterStr","hx","ht","replacement","free_in_1","helpers_1","reduce","cb","reducer","reduceFunctions","reduced","reduceEta","reduceCallByName","resolveDefinition","reduceNormal","reduceCallByValue","reduceApplicative","subst","renameCb","renamedBody","renameForSubstitution","renamed","applied","applySubstitution","normal","applicative","cbn","cbv","newVarName","renameVar","renamedFun","oldName","base","newName","isValid","varRenameCollides","Def","logTimings","time","res","timeEnd","disableLogTimings","indent","min","re","RegExp","unindented","trim"],"sourceRoot":".","sources":["node_modules/browser-pack/_prelude.js","src/app.ts","src/dom.ts","src/examples.ts","src/lambda/alpha-eq.ts","src/lambda/format.ts","src/lambda/free-in.ts","src/lambda/grammar.js","src/lambda/helpers.ts","src/lambda/index.ts","src/lambda/parse.ts","src/lambda/reduce-program.ts","src/lambda/reduce.ts","src/lambda/substitute.ts","src/lambda/terms.ts","src/utils.ts"],"sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","// Script for index.html\nimport { $, delegate, nodeIndex } from './dom'\nimport examples from './examples'\nimport { Options, reduceProgram, Reduction } from './lambda'\nimport { dedent, enableLogTimings, timed } from './utils'\n\nenableLogTimings()\n\nconst input = $('.input', HTMLTextAreaElement)\nconst output = $('.output')\n\n// Run code on ctrl+enter.\ndocument.addEventListener('keyup', e => {\n  if (e.keyCode === 13 && e.ctrlKey) {\n    run()\n  }\n})\n\ninput.addEventListener('beforeinput', event => {\n  // Replace every \"\\\" with \"λ\" while typing.\n  if (event.data?.includes('\\\\')) {\n    event.preventDefault()\n    const replaced = event.data.replace(/\\\\/g, 'λ')\n    const start = input.selectionStart || 0\n    const end = input.selectionEnd || 0\n    const value = input.value\n\n    input.value = value.slice(0, start) + replaced + value.slice(end)\n\n    // Update selection\n    input.selectionStart = input.selectionEnd = start + 1\n  }\n})\n\n$('.run').addEventListener('click', _ => run())\n\nconst renderTerm = (term: string, className = '') =>\n  `<span class=\"term ${className}\">${term}</span>`\n\nconst renderArrow = (symbol: string, label: string) =>\n  `<span class=arrow>${symbol}<small>${label}</small></span>`\n\n// Only beta and eta steps count as reductions, so use an arrow symbol for them.\n// While alpha-renames are more of an equivalence, and thus their symbol.\nconst arrowSymbols = {\n  def: ['≡', ''],\n  alpha: ['≡', 'α'],\n  beta: ['→', 'β'],\n  eta: ['→', 'η']\n} as const\n\nconst renderSynonyms = (synonyms: string[]) =>\n  synonyms.length ? `<span class=synonyms>(${synonyms.join(', ')})</span>` : ''\n\nconst getOptions = (): Options => {\n  const maxReductionSteps = parseInt(\n    $('input[name=max-steps]', HTMLInputElement).value || '0',\n    10\n  )\n  const strategy = $('input[name=strategy]:checked', HTMLInputElement)\n    .value as Options['strategy']\n  const etaEnabled = $('[name=eta-reductions]', HTMLInputElement).checked\n  return { maxReductionSteps, strategy, etaEnabled }\n}\n\nlet reductions: Reduction[] = []\nconst run = () => {\n  const code = input.value\n  try {\n    reductions = reduceProgram(code, getOptions())\n    renderReductions()\n  } catch (err) {\n    output.textContent = err instanceof Error ? err.message : String(err)\n    output.classList.add('error')\n  }\n}\n\nconst renderReductions = timed('render html', () => {\n  output.innerHTML = reductions.map(renderCollapsedReduction).join('')\n  output.classList.remove('error')\n})\n\ndelegate('click', output, '.reduction', element => {\n  const reduction = reductions[nodeIndex(element)]\n  if (reduction.totalSteps === 0) {\n    return\n  }\n  const expanded = element.querySelector('.expanded')\n  const collapsed = element.querySelector('.collapsed')\n  if (expanded) {\n    expanded.classList.toggle('hidden')\n    collapsed?.classList.toggle('hidden')\n  } else {\n    collapsed?.classList.add('hidden')\n    element.innerHTML += renderExpandedReductionForm(reduction)\n  }\n})\n\ndelegate('mouseover', output, '.expanded .step', element => {\n  element.classList.add('highlight')\n  // Hide the previous step's after term.\n  const prev = element.previousElementSibling\n  if (prev) {\n    prev.querySelector('.after')?.classList.add('hidden')\n  }\n})\n\ndelegate('mouseout', output, '.expanded .step', element => {\n  element.classList.remove('highlight')\n  const prev = element.previousElementSibling\n  if (prev) {\n    prev.querySelector('.after')?.classList.remove('hidden')\n  }\n})\n\nconst renderCollapsedReduction = (reduction: Reduction) =>\n  `<div class=reduction>${renderCollapsedReductionForm(reduction)}</div>`\n\nconst renderCollapsedReductionForm = (reduction: Reduction) => {\n  let initial = ''\n  let arrow = ''\n  if (reduction.reductionSteps > 0) {\n    initial = renderTerm(reduction.initial)\n    arrow = renderArrow('→', `(${reduction.reductionSteps})`)\n  }\n  const final = renderTerm(reduction.final, 'final')\n  const synonyms = renderSynonyms(reduction.finalSynonyms)\n  return `<div class=collapsed>${initial} ${arrow} ${final} ${synonyms}</div>`\n}\n\nconst renderExpandedReductionForm = (reduction: Reduction) => {\n  const steps = []\n  for (let i = 0; i < reduction.totalSteps; i++) {\n    const isLast = i === reduction.totalSteps - 1\n    const step = reduction.renderStep(i, renderStepOptions)\n    const before = renderTerm(step.before, 'before')\n    const after = renderTerm(step.after, 'after' + (isLast ? ' final' : ''))\n    const [arrowSymbol, arrowLabel] = arrowSymbols[step.type]\n    const arrow = renderArrow(arrowSymbol, arrowLabel)\n    const synonyms = isLast ? renderSynonyms(reduction.finalSynonyms) : ''\n    steps.push(\n      `<span class=step>${before}<br>${arrow} ${after} ${synonyms}</span>`\n    )\n  }\n\n  return `<div class=expanded>${steps.join('')}</div>`\n}\n\nconst renderStepOptions = {\n  highlightStep: (s: string) => `<span class=match>${s}</span>`,\n  highlightFormerTerm: (s: string) => `<span class=former-term>${s}</span>`,\n  highlightSubstitutionTerm: (s: string) => `<span class=subst-term>${s}</span>`\n}\n\ninput.value = dedent(`\n  ; Write some λ-expressions here and hit Run. Use \"\\\\\" to enter \"λ\" ;)\n  (λx.λy.λz.z y x) a b c\n`)\ninput.focus()\n\nconst examplesMenu = $('.examples-menu')\nconst examplesHtml = examples.map((example, i) => {\n  const href = encodeURI(`#>${example.code}`)\n  return `<li><a href=\"${href}\">${i} - ${example.name}</a></li>`\n})\n\nexamplesMenu.innerHTML = examplesHtml.join('')\ndelegate('click', examplesMenu, 'li', (element, event) => {\n  event.preventDefault() // Don't change the location.hash\n  input.value = examples[nodeIndex(element)].code\n  input.scrollTop = 0\n})\n\nconst examplesDropdown = $('.examples-dropdown')\nexamplesDropdown.addEventListener('click', e => {\n  if (examplesDropdown.classList.contains('active')) {\n    return\n  }\n  e.stopPropagation()\n  examplesDropdown.classList.add('active')\n  document.addEventListener(\n    'click',\n    () => {\n      examplesDropdown.classList.remove('active')\n    },\n    { once: true }\n  )\n})\n\n$('button.link').addEventListener('click', () => {\n  const code = encodeURIComponent(input.value)\n  location.hash = `>${code}`\n})\n\nconst updateInputFromHash = () => {\n  const hash = decodeURIComponent(location.hash)\n  const codeStart = hash.indexOf('>')\n  if (codeStart >= 0) {\n    input.value = hash.slice(codeStart + 1)\n  }\n}\n\nwindow.addEventListener('hashchange', updateInputFromHash)\nupdateInputFromHash()\n","function $(selector: string): Element\nfunction $<T extends Element>(selector: string, elementCtor: { new (): T }): T\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nfunction $(selector: string, elementCtor = Element) {\n  const element = document.querySelector(selector)\n  if (!(element instanceof elementCtor)) {\n    throw TypeError(\n      `expected '${selector}' to find an ${elementCtor.name} but got ${element}`\n    )\n  }\n  return element\n}\nexport { $ }\n\n// Similar to jQuery.fn.on(type, selector, handler)\nexport const delegate = (\n  eventType: string,\n  element: Element,\n  selector: string,\n  handler: (el: Element, ev: Event) => void\n) => {\n  element.addEventListener(eventType, event => {\n    if (event.target instanceof Element) {\n      const closest = event.target.closest(selector)\n      if (closest && element.contains(closest)) {\n        handler(closest, event)\n      }\n    }\n  })\n}\n\nexport const nodeIndex = (element: Element): number => {\n  return Array.prototype.indexOf.call(element.parentNode?.childNodes, element)\n}\n","import { dedent } from './utils'\n\nconst examples = [\n  {\n    name: 'Basics',\n    code: dedent(`\n    ; This example is not intend to be a tutorial nor an introduction to λ Calculus.\n    ; You should check http://en.wikipedia.org/wiki/Lambda_calculus for that :)\n    ; As you can see, these are comments. You can run this example clicking the Run\n    ; button below or pressing Ctrl+Enter.\n    ; So, the three basic types of λ expressions are:\n    ; Variables:\n    x\n    ; Applications:\n    x y\n    ; And lambda abstractions (also known as functions):\n    λx.x\n    ; If the left-side of an application is an abstraction, then a reduction takes place:\n    (λx.x) y\n    ; That little abstraction at the left is the identity, a very simple function that\n    ; just reduces to whatever you apply to it. We can give it a name like so:\n    id = λx.x\n    ; And then just refer it by that name:\n    id a\n    ; You can apply any kind of λ expression to an abstraction, like another function:\n    id λb.c\n    ; Or an application:\n    id (x y)\n    ; Or even the identity function itself:\n    id id\n    ; That means you can apply identity to itself as many times as you want and it'll still\n    ; be identity:\n    id id id id id\n    ; Notice that applications are left-associative, so the line above is equivalent to:\n    ((((id id) id) id) id)\n\n    ; TODO: explain applicative and normal order...\n  `)\n  },\n  {\n    name: 'Booleans',\n    code: dedent(`\n    ; Church booleans\n\n    ; The booleans and their operations can be encoded as the following λ-terms:\n    true = λt.λf.t\n    false = λt.λf.f\n    not = λp.p false true\n    and = λp.λq.p q p\n    or = λp.λq.p p q\n    if = λp.p\n\n    ; Print truth tables for not, and and or:\n    not true\n    not false\n    and false false\n    and false true\n    and true false\n    and true true\n    or false false\n    or false true\n    or true false\n    or true true\n\n    ; Terms can be nested as much as we want:\n    if (not (not true)) (or false (if true true false)) false\n\n    ; There's nothing special about \"operators\", we can treat them as any other value:\n    (if false or and) true false\n  `)\n  },\n  {\n    name: 'Numbers',\n    code: dedent(`\n    ; Church numerals\n\n    ; The first few numbers are:\n    zero = λs.λz.z\n    one = λs.λz.s z\n    two = λs.λz.s (s z)\n    three = λs.λz.s (s (s z))\n    ; In general, any natural number n can be encoded as:\n    ; N = λs.λz.s (s (s ... (s (s z)) ... ))\n    ; with s applied n times.\n\n    ; When we get tired of writing numbers like that, we can define a successor function:\n    succ = λn.λs.λz.s (n s z)\n    succ three\n\n    ; We can think of Church numerals as functions that apply a given function s to a\n    ; given value z a number of times. Zero will apply it 0 times (i.e. it'll give\n    ; us z back untouched) and three will call it 3 times.\n    ; So, we can represent the addition of numbers m and n as first applying n times s to z,\n    ; and then applying m times s to that:\n    add = λm.λn.λs.λz.m s (n s z)\n    add two three\n    ; ...or, more succinctly, as applying n times the successor function on m (or vice versa):\n    add' = λm.λn.n succ m\n    add' two three\n    ; Conversely, we could define the successor function as adding one:\n    succ' = add one\n    succ' three\n\n    ; Multiplication of m by n is applying m times a function that applies s n times:\n    mult = λm.λn.λs.m (n s)\n    mult three three\n    ; ...or applying m times the addition of n to zero:\n    mult' = λm.λn.m (add n) zero\n    mult' three three\n\n    ; Exponentiation n^m has a simple encoding: applying the base m to the exponent n,\n    ; which can be understood as applying m successively n times:\n    exp = λm.λn.n m\n    exp two three\n    ; ...or, alternatively, applying m times the multiplication by n to one:\n    exp' = λm.λn.m (mult n) one\n    exp' two three\n\n    ; The encoding for the predecessor function is quite complex.\n    ; The Wikipedia article on Church encoding has a good explanation for this term ;-)\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    pred three\n\n    ; But given the predecessor function is then easy to define the subtraction:\n    sub = λm.λn.n pred m\n    sub three two\n\n    ; To build some predicate functions, we'll use some known boolean terms (see\n    ; Booleans example for more info):\n    true = λt.λf.t\n    false = λt.λf.f\n    and = λp.λq.p q p\n\n    ; To know if a number n is zero we can pass true as the base value and a function\n    ; that always returns false (note that the \"?\" is no special syntax; it's just\n    ; part of the name of the predicate):\n    zero? = λn.n (λx.false) true\n    zero? zero\n    zero? two\n\n    ; To know if a number is less or equal to another number, we can subtract them and\n    ; see if the result is zero:\n    leq = λm.λn.zero? (sub m n)\n\n    ; And given that predicate, numeric equality between m and n can be defined as:\n    eq = λm.λn.and (leq m n) (leq n m)\n\n    ; Throwing everything into the mix, we can prove that 2³ = 3² - 1:\n    eq (exp two three) (pred (exp three two))\n  `)\n  },\n  {\n    name: 'Factorial',\n    code: dedent(`\n    ; Factorial function and recursion\n\n    ; Note: for this example we'll use boolean and numeric terms from previous\n    ; examples (see below).\n    ; Also not that these factorial definitions won't work with applicative order ;)\n\n    ; We'd like to be able to define a factorial function as:\n    ; fact = λn.if (zero? n) one (mult n (fact (pred n)))\n    ; But we can't use a term in its own definition.\n    ; To achieve recursion, we can instead define a function that will receive itself\n    ; as a parameter r, and then recur by calling r with itself and n - 1:\n    fact-rec = λr.λn.if (zero? n) one (mult n (r r (pred n)))\n    ; The real factorial function would then be:\n    fact = fact-rec fact-rec\n    fact four\n\n    ; Another way to recur is to use a general purpose fixed-point combinator.\n    ; Behold, the almighty Y Combinator:\n    Y = λf.(λx.f (x x)) (λx.f (x x))\n    ; And then there's no need to define a separate function:\n    fact2 = Y λr.λn.if (zero? n) one (mult n (r (pred n)))\n    fact2 four\n\n    ; A different way of computing the factorial of n is to use the number n itself\n    ; as a function that will call a given function n times, starting with a given value.\n    ; The function given will take a pair [a, b] and return a new pair [a-1, a*b], and start with [n, 1].\n    ; After applying this given function n times, the resulting pair will be [0, factorial(n)],\n    ; of which we take the 2nd component.\n    ; This way of defining factorial requires much fewer reduction steps.\n    fact3 = λn.2nd (n (λp.pair (pred (1st p)) (mult (1st p) (2nd p))) (pair n one))\n    fact3 four\n\n    ; Yet another way of defining factorial is as the successive multiplication of the numbers n...1,\n    ; which results in this very elegant solution:\n    fact4 = λn.reduce mult (iota n) one\n    fact4 four\n\n    ; Pair-handling functions:\n    pair = λx.λy.λf.f x y\n    1st = λp.p (λx.λy.x)\n    2nd = λp.p (λx.λy.y)\n\n    ; List-handling functions. Lists can be considered functions handling a nil (empty) case\n    ; and a cons (head+tail) case:\n    nil = λn.λc.n\n    cons = λh.λt.λn.λc.c h t\n    reduce = Y λr.λf.λlist.λinitial.list initial (λh.λt.f h (r f t initial))\n    ; For a given number n, iota produces the list of numbers 1, 2, ..., n\n    iota = λn.n (λlist.list (cons n nil) (λh.λt.cons (pred h) list)) nil\n\n    ; Borrow some terms from previous examples:\n    true = λt.λf.t\n    false = λt.λf.f\n    if = λp.p\n    zero = λs.λz.z\n    one = λs.λz.s z\n    two = λs.λz.s (s z)\n    three = λs.λz.s (s (s z))\n    four = λs.λz.s (s (s (s z)))\n    succ = λn.λs.λz.s (n s z)\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    mult = λm.λn.λs.m (n s)\n    zero? = λn.n (λx.false) true\n  `)\n  },\n  {\n    name: 'Extras',\n    code: dedent(`\n    ; Syntactic Trivia and Miscellaneous\n\n    ; Identifiers can contain basically any character (except the few ones reserved for\n    ; syntax: \"λ\", \".\", \"=\", \"(\" and \")\").\n    ; This means you can write some pretty code-looking lambda terms!\n    0 = λs.λz.z\n    1 = λs.λz.s z\n    2 = λs.λz.s (s z)\n    + = λm.λn.λs.λz.m s (n s z)\n    * = λm.λn.λs.m (n s)\n    (+ (* 2 1) 0)\n    ; Reinventing (a part of) Lisp is always fun...\n\n    ; You can even use emojis as identifiers! But make sure to use this power responsibly.\n    (λ🐴.❓) 🍎\n\n    ; Although line breaks usually act as separators between terms/definitions,\n    ; you can use parentheses to split a complex term into multiple lines:\n    fib = Y λf.λn.(\n      if (≤ n 1)\n         n\n         (+ (f (- n 1))\n            (f (- n 2))))\n    fib 0\n    fib 1\n    fib 2\n    fib 7\n\n    ; The rest of the definitions to make the above code work. Not much to see here...\n    Y = λf.(λx.f (x x)) (λx.f (x x))\n    - = λm.λn.n pred m\n    ≤ = λm.λn.zero? (- m n)\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    zero? = λn.n (λx.false) true\n    true = λt.λf.t\n    false = λt.λf.f\n    if = λp.p\n    7 = λs.λz.s (s (s (s (s (s (s z))))))\n    13 = λs.λz.s (s (s (s (s (s (s (s (s (s (s (s (s z))))))))))))\n    ❓ = λ💩.💩 💩 💩\n  `)\n  }\n]\n\nexport default examples\n","import { substitute } from './substitute'\nimport { Term, Var } from './terms'\n\n// Whether two terms are alpha-equivalent.\nconst alphaEq = (t1: Term, t2: Term): boolean => {\n  if (t1.type === 'def') {\n    return alphaEq(t1.term, t2)\n  }\n  if (t2.type === 'def') {\n    return alphaEq(t1, t2.term)\n  }\n  if (t1.type === 'var' && t2.type === 'var') {\n    return t1.name === t2.name\n  }\n  if (t1.type === 'app' && t2.type === 'app') {\n    return alphaEq(t1.left, t2.left) && alphaEq(t1.right, t2.right)\n  }\n  if (t1.type === 'fun' && t2.type === 'fun') {\n    if (t1.param === t2.param) {\n      return alphaEq(t1.body, t2.body)\n    } else {\n      return alphaEq(t1.body, substitute(t2.body, t2.param, Var(t1.param)))\n    }\n  }\n  return false\n}\n\nexport default alphaEq\n","import { identity } from '../utils'\nimport { Term } from './terms'\n\n// Returns the string representation for a given term t.\nconst format = (t: Term, appParens = false, funParens = false): string => {\n  // TODO: Remove highlighting hack of storing data on terms.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const { highlight: h = identity, highlightVar } = t as any\n  switch (t.type) {\n    case 'var':\n    case 'def':\n      return h(t.name)\n    case 'fun':\n      let lambda = `λ${t.param}`\n      if (highlightVar) {\n        lambda = highlightVar(lambda)\n      }\n      const funStr = `${lambda}.${format(t.body)}`\n      return h(funParens ? `(${funStr})` : funStr)\n    case 'app':\n      const lStr = format(t.left, false, true)\n      const rStr = format(t.right, true, funParens)\n      const appStr = `${lStr} ${rStr}`\n      return h(appParens ? `(${appStr})` : appStr)\n  }\n}\n\nexport default format\n","import { Term } from './terms'\n\n// Whether the variable x appears free in the term t.\nconst freeIn = (x: string, t: Term): boolean => {\n  switch (t.type) {\n    case 'var':\n      return t.name === x\n    case 'fun':\n      return t.param !== x && freeIn(x, t.body)\n    case 'app':\n      return freeIn(x, t.left) || freeIn(x, t.right)\n    case 'def':\n      // Definitions don't have free variables.\n      return false\n  }\n}\n\nexport default freeIn\n","/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar grammar = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[5,7],$V1=[1,6],$V2=[1,7],$V3=[1,8],$V4=[2,10],$V5=[5,7,11,13,14,15];\nvar parser = {trace: function trace () { },\nyy: {},\nsymbols_: {\"error\":2,\"root\":3,\"program\":4,\"EOF\":5,\"line\":6,\"SEPARATOR\":7,\"term\":8,\"ident\":9,\"=\":10,\"LAMBDA\":11,\".\":12,\"(\":13,\")\":14,\"IDENT\":15,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",7:\"SEPARATOR\",10:\"=\",11:\"LAMBDA\",12:\".\",13:\"(\",14:\")\",15:\"IDENT\"},\nproductions_: [0,[3,2],[4,0],[4,1],[4,2],[4,3],[6,1],[6,3],[8,4],[8,2],[8,1],[8,3],[9,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\n /* do nothing; terms and definitions already collected */ \nbreak;\ncase 6:\n this.$ = yy.parseTopLevelTerm($$[$0]); \nbreak;\ncase 7:\n this.$ = yy.parseDefinition($$[$0-2], $$[$0]); \nbreak;\ncase 8:\n this.$ = yy.parseFunction($$[$0-2], $$[$0]); \nbreak;\ncase 9:\n this.$ = yy.parseApplication($$[$0-1], $$[$0]); \nbreak;\ncase 10:\n this.$ = yy.parseIdentifier($$[$0]); \nbreak;\ncase 11:\n this.$ = $$[$0-1]; \nbreak;\ncase 12:\n this.$ = yytext; \nbreak;\n}\n},\ntable: [o($V0,[2,2],{3:1,4:2,6:3,8:4,9:5,11:$V1,13:$V2,15:$V3}),{1:[3]},{5:[1,9],7:[1,10]},o($V0,[2,3]),o($V0,[2,6],{8:11,9:12,11:$V1,13:$V2,15:$V3}),o([5,7,11,13,15],$V4,{10:[1,13]}),{9:14,15:$V3},{8:15,9:12,11:$V1,13:$V2,15:$V3},o([5,7,10,11,12,13,14,15],[2,12]),{1:[2,1]},o($V0,[2,4],{8:4,9:5,6:16,11:$V1,13:$V2,15:$V3}),o($V5,[2,9],{8:11,9:12}),o($V5,$V4),{8:17,9:12,11:$V1,13:$V2,15:$V3},{12:[1,18]},{8:11,9:12,11:$V1,13:$V2,14:[1,19],15:$V3},o($V0,[2,5]),o($V0,[2,7],{8:11,9:12,11:$V1,13:$V2,15:$V3}),{8:20,9:12,11:$V1,13:$V2,15:$V3},o($V5,[2,11]),o([5,7,14],[2,8],{8:11,9:12,11:$V1,13:$V2,15:$V3})],\ndefaultActions: {9:[2,1]},\nparseError: function parseError (str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function(match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex () {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin (condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState () {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules () {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState (n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState (condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0: yy.openParens++; return 13; \nbreak;\ncase 1: yy.openParens--; return 14; \nbreak;\ncase 2: return 11; \nbreak;\ncase 3: return 12; \nbreak;\ncase 4: return 10; \nbreak;\ncase 5: /* ignore separators inside parens */\n                   if (yy.openParens <= 0) return 7\n                 \nbreak;\ncase 6: /* ignore whitespace */ \nbreak;\ncase 7: /* ignore line comments */ \nbreak;\ncase 8: return 15; \nbreak;\ncase 9: return 5; \nbreak;\n}\n},\nrules: [/^(?:\\()/,/^(?:\\))/,/^(?:\\\\|λ)/,/^(?:\\.)/,/^(?:=)/,/^(?:\\n)/,/^(?:[^\\S\\n]+)/,/^(?:;.*)/,/^(?:[^\\s\\(\\)\\\\λ\\.=]+)/,/^(?:$)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = grammar;\nexports.Parser = grammar.Parser;\nexports.parse = function () { return grammar.parse.apply(grammar, arguments); };\nexports.main = function commonjsMain (args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}","import { App, Def, Fun, Term } from './terms'\n\nexport type Callback = (t: Term) => void\n\n// Compose a callback function with a term constructor.\nexport const composeFun = (fn: Callback, x: string) => (b: Term) =>\n  fn(Fun(x, b))\nexport const composeAppL = (fn: Callback, l: Term) => (r: Term) => fn(App(l, r))\nexport const composeAppR = (fn: Callback, r: Term) => (l: Term) => fn(App(l, r))\n\nexport type Definitions = Record<string, Term>\n\n// Represents a reduction \"step\" as displayed on the application.\nexport type Step =\n  | { type: 'alpha'; before: Fun; after: Fun }\n  | { type: 'beta'; before: App; after: Term }\n  | { type: 'eta'; before: Fun; after: Term }\n  | { type: 'def'; before: Def; after: Term }\n\nexport type AnnotatedTerm = Term & { step: Step }\n\n// Mark a reduction step on the `after` term.\nexport const markStep = (step: Step): AnnotatedTerm => ({ ...step.after, step })\n","export * from './terms'\nexport { default as parse } from './parse'\nexport { default as format } from './format'\nexport { reduceProgram, Reduction, Options } from './reduce-program'\nexport { Definitions } from './helpers'\n","import { timed } from '../utils'\nimport { Parser } from './grammar'\nimport { Definitions } from './helpers'\nimport { App, Fun, Term } from './terms'\n\n// Parses an input program string and returns an object with the top-level terms\n// and definitions of the program.\nconst parse = timed('parse', (str: string) => {\n  // A custom Jison parser.\n  const parser = new Parser()\n\n  // A definition table with the definition term by their names.\n  const defs: Definitions = {}\n  // The terms of the program.\n  const terms: Term[] = []\n\n  // Set initial parser state and helper functions.\n  parser.yy = {\n    openParens: 0,\n    parseFunction: Fun,\n    parseApplication: App,\n    parseDefinition: (name: string, term: Term) => {\n      if (defs[name]) {\n        throw Error(`${name} already defined`)\n      }\n      defs[name] = term\n    },\n    parseTopLevelTerm: (term: Term) => {\n      terms.push(term)\n    },\n    parseIdentifier: (name: string) => ({ type: 'ref', name })\n  }\n\n  parser.parse(str)\n\n  terms.forEach(t => resolveTermRefs(t, defs))\n\n  const refNames = {}\n  Object.keys(defs).forEach(name => {\n    resolveDefRefs(name, defs[name], defs, refNames)\n  })\n\n  return { defs, terms }\n})\n\nexport default parse\n\n// Temporary term used only while parsing as a placeholder for wither a Var o a\n// Ref. On the first pass the parser cannot know if an identifier is a variable\n// or a definition (because definitions can be declared after their use), so it\n// stores a Ref instead and then on a second pass decides what it should be and\n// *mutates* the Ref in-place to become either a Var or a Ref.\n// TODO: Remove this hack.\ntype TermOrRef = Term | { type: 'ref'; name: string }\n\n// Changes all Refs inside term t to either Vars or Defs.\nconst resolveTermRefs = (\n  t: TermOrRef,\n  defs: Definitions,\n  boundNames: string[] = []\n) => {\n  switch (t.type) {\n    case 'ref':\n      const free = boundNames.indexOf(t.name) < 0\n      if (t.name in defs && free) {\n        Object.assign(t, { type: 'def', term: defs[t.name] })\n      } else {\n        Object.assign(t, { type: 'var' })\n      }\n      break\n    case 'app':\n      resolveTermRefs(t.left, defs, boundNames)\n      resolveTermRefs(t.right, defs, boundNames)\n      break\n    case 'fun':\n      resolveTermRefs(t.body, defs, boundNames.concat(t.param))\n      break\n  }\n}\n\n// Changes all Refs inside term t to either Vars or Defs.\nconst resolveDefRefs = (\n  defName: string,\n  t: TermOrRef,\n  defs: Definitions,\n  refNames: Record<string, string[]>,\n  boundNames: string[] = []\n) => {\n  switch (t.type) {\n    case 'ref':\n      const bound = boundNames.indexOf(t.name) >= 0\n      if (bound) {\n        Object.assign(t, { type: 'var' })\n      } else if (t.name in defs) {\n        refNames[defName] = [...(refNames[defName] || []), t.name]\n        checkForCircularRefs(defName, t.name, refNames)\n        Object.assign(t, { type: 'def', term: defs[t.name] })\n      } else {\n        throw Error(\n          `Illegal free variable \"${t.name}\" in \"${defName}\". Definitions cannot have free variables.`\n        )\n      }\n      break\n    case 'app':\n      resolveDefRefs(defName, t.left, defs, refNames, boundNames)\n      resolveDefRefs(defName, t.right, defs, refNames, boundNames)\n      break\n    case 'fun':\n      const boundOnBody = boundNames.concat(t.param)\n      resolveDefRefs(defName, t.body, defs, refNames, boundOnBody)\n      break\n  }\n}\n\nconst checkForCircularRefs = (\n  name: string,\n  refName: string,\n  refNames: Record<string, string[]>,\n  path: string[] = []\n) => {\n  if (name === refName) {\n    let message = `Illegal recursive reference in \"${name}\". Definitions cannot reference themselves, they are just simple find&replace mechanisms.\\n`\n    const refCycle = path.length ? [name, ...path, name].join(' → ') : null\n    message += refCycle\n      ? `In this case the definition does not reference itself directly, but through other definitions: ${refCycle}.`\n      : 'If you want to write a recursive function, search for \"Y combinator\" ;)'\n    throw Error(message)\n  }\n\n  const nextRefs = refNames[refName] || []\n  nextRefs.forEach(nextRef =>\n    checkForCircularRefs(name, nextRef, refNames, [...path, refName])\n  )\n}\n","import { identity, timed } from '../utils'\nimport alphaEq from './alpha-eq'\nimport format from './format'\nimport { AnnotatedTerm, Definitions, Step } from './helpers'\nimport parse from './parse'\nimport reduce, { Options as ReduceOptions } from './reduce'\nimport { substitute } from './substitute'\nimport { App, Fun, Term, Var } from './terms'\n\nexport type Options = Partial<ReduceOptions> & {\n  maxReductionSteps?: number\n}\n\nexport type Reduction = {\n  initial: string\n  final: string\n  finalSynonyms: string[]\n  terminates: boolean\n  reductionSteps: number\n  totalSteps: number\n  renderStep: (i: number, options?: RenderStepOptions) => RenderedStep\n}\n\ntype RenderStepOptions = {\n  highlightFormerTerm?: StrFun\n  highlightSubstitutionTerm?: StrFun\n  highlightStep?: StrFun\n}\n\ntype StrFun = (s: string) => string\n\ntype RenderedStep = {\n  type: 'alpha' | 'beta' | 'eta' | 'def'\n  before: string\n  after: string\n}\n\n// Reduce a program and return with the reduction for each term in the program.\nexport const reduceProgram = (program: string, options: Options = {}) => {\n  const { terms, defs } = parse(program)\n  return terms.map(term => reduceTerm(term, defs, options))\n}\n\n// Reduces a term up to its normal form.\nlet reduceTerm = (\n  term: Term,\n  defs: Definitions,\n  { maxReductionSteps = 100, strategy = 'normal', etaEnabled = false }: Options\n): Reduction => {\n  const enough = {}\n  const steps: Term[] = []\n  let reductionSteps = 0\n  let terminates = false\n  try {\n    reduce(term, { strategy, etaEnabled }, stepTerm => {\n      if (reductionSteps >= maxReductionSteps) {\n        throw enough\n      }\n      steps.push(stepTerm)\n\n      // TODO: it'd be nice if we didn't need to find the step type on the term\n      // on each step. Maybe the callback function could receive the step type\n      // as an argument.\n      const step = findStep(stepTerm)\n      if (!step) {\n        throw new Error('Unexpected: term should always have a step')\n      }\n      if (step.type === 'beta' || step.type === 'eta') {\n        reductionSteps += 1\n      }\n    })\n    terminates = true\n  } catch (e) {\n    if (e !== enough) {\n      throw e\n    }\n    terminates = false\n  }\n\n  const last = steps[steps.length - 1] || term\n  return {\n    initial: format(term),\n    final: format(last),\n    finalSynonyms: findSynonyms(last, defs),\n    terminates,\n    reductionSteps,\n    totalSteps: steps.length,\n    renderStep: (i, options) => expandStep(steps[i], options)\n  }\n}\nreduceTerm = timed('reduce', reduceTerm)\n\nconst expandStep = (t: Term, options: RenderStepOptions = {}) => {\n  const step = findStep(t)\n  if (!step) {\n    throw new Error('Unexpected: term should always have a step')\n  }\n\n  let before: Term = step.before\n  let after: Term = step.after\n\n  const {\n    highlightFormerTerm = identity,\n    highlightSubstitutionTerm = identity,\n    highlightStep = identity\n  } = options\n\n  switch (step.type) {\n    case 'alpha':\n      before = highlightFunctionVar(\n        step.before.body,\n        step.before.param,\n        highlightFormerTerm\n      )\n      after = highlightFunctionVar(\n        step.after.body,\n        step.after.param,\n        highlightSubstitutionTerm\n      )\n      break\n    case 'beta':\n      const fun = step.before.left as Fun\n      const hs = highlight(step.before.right, highlightSubstitutionTerm)\n      const ha = highlightFunctionVar(fun.body, fun.param, highlightFormerTerm)\n      before = App(ha, hs)\n      after = substitute(fun.body, fun.param, hs)\n      break\n    case 'eta':\n    case 'def':\n      before = highlight(step.before, highlightFormerTerm)\n      after = highlight(step.after, highlightSubstitutionTerm)\n      break\n  }\n\n  before = highlight(before, highlightStep)\n  after = highlight(after, highlightStep)\n\n  const beforeStr = format(replaceStep(t, before))\n  const afterStr = format(replaceStep(t, after))\n\n  return { type: step.type, before: beforeStr, after: afterStr }\n}\n\nconst highlight = (t: Term, fn: StrFun) => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const h: StrFun = (t as any).highlight\n  const highlight: StrFun = h ? s => fn(h(s)) : fn\n  return { ...t, highlight }\n}\n\nconst highlightFunctionVar = (t: Term, x: string, fn: StrFun) => {\n  const hx = highlight(Var(x), fn)\n  const ht = substitute(t, x, hx)\n  return { ...Fun(x, ht), highlightVar: fn }\n}\n\nconst findStep = (t: Term | AnnotatedTerm): Step | undefined => {\n  if ('step' in t) {\n    return t.step\n  }\n\n  switch (t.type) {\n    case 'fun':\n      return findStep(t.body)\n    case 'app':\n      return findStep(t.left) || findStep(t.right)\n  }\n}\n\nconst replaceStep = (t: Term | AnnotatedTerm, replacement: Term): Term => {\n  if ('step' in t && t.step) {\n    return replacement\n  }\n\n  switch (t.type) {\n    case 'var':\n    case 'def':\n      return t\n    case 'fun':\n      const body = replaceStep(t.body, replacement)\n      return t.body === body ? t : Fun(t.param, body)\n    case 'app':\n      const l = replaceStep(t.left, replacement)\n      if (t.left !== l) {\n        return App(l, t.right)\n      }\n      const r = replaceStep(t.right, replacement)\n      return t.right === r ? t : App(l, r)\n  }\n}\n\nconst findSynonyms = (term: Term, defs: Definitions) => {\n  const synonyms = []\n  for (const name in defs) {\n    if (alphaEq(term, defs[name])) {\n      synonyms.push(name)\n    }\n  }\n  return synonyms\n}\n","import freeIn from './free-in'\nimport {\n  Callback,\n  composeAppL,\n  composeAppR,\n  composeFun,\n  markStep\n} from './helpers'\nimport { applySubstitution, renameForSubstitution } from './substitute'\nimport { App, Def, Fun, Term } from './terms'\n\nexport type Options = {\n  strategy: keyof typeof reduceFunctions\n  etaEnabled: boolean\n}\n\nconst reduce = (t: Term, { strategy, etaEnabled }: Options, cb: Callback) => {\n  const reducer = reduceFunctions[strategy]\n  let reduced = reducer(t, cb)\n  if (etaEnabled) {\n    reduced = reduceEta(reduced, cb)\n  }\n  return reduced\n}\n\nexport default reduce\n\ntype Reducer = (t: Term, cb: Callback) => Term\n\n// Note: the implementation of these reduction strategies were based on the\n// paper \"Demonstrating Lambda Calculus Reduction\", by Peter Sestoft\n// See: http://itu.dk/people/sestoft/papers/sestoft-lamreduce.pdf, also included\n// in bib/ directory.\n\nconst reduceCallByName: Reducer = (t, cb) => {\n  switch (t.type) {\n    case 'var':\n    case 'fun':\n      return t\n    case 'app':\n      const l = reduceCallByName(t.left, composeAppR(cb, t.right))\n      return l.type === 'fun'\n        ? reduceCallByName(apply(l, t.right, cb), cb)\n        : App(l, t.right)\n    case 'def':\n      return reduceCallByName(resolveDefinition(t, cb), cb)\n  }\n}\n\nconst reduceNormal: Reducer = (t, cb) => {\n  switch (t.type) {\n    case 'var':\n      return t\n    case 'fun':\n      return Fun(t.param, reduceNormal(t.body, composeFun(cb, t.param)))\n    case 'app':\n      let l = reduceCallByName(t.left, composeAppR(cb, t.right))\n      if (l.type === 'fun') {\n        return reduceNormal(apply(l, t.right, cb), cb)\n      } else {\n        l = reduceNormal(l, composeAppR(cb, t.right)) // Finish reducing l.\n        const r = reduceNormal(t.right, composeAppL(cb, l))\n        return App(l, r)\n      }\n    case 'def':\n      return reduceNormal(resolveDefinition(t, cb), cb)\n  }\n}\n\nconst reduceCallByValue: Reducer = (t, cb) => {\n  switch (t.type) {\n    case 'var':\n    case 'fun':\n      return t\n    case 'app':\n      const l = reduceCallByValue(t.left, composeAppR(cb, t.right))\n      const r = reduceCallByValue(t.right, composeAppL(cb, l))\n      return l.type === 'fun'\n        ? reduceCallByValue(apply(l, r, cb), cb)\n        : App(l, r)\n    case 'def':\n      return reduceCallByValue(resolveDefinition(t, cb), cb)\n  }\n}\n\nconst reduceApplicative: Reducer = (t, cb) => {\n  switch (t.type) {\n    case 'var':\n      return t\n    case 'fun':\n      return Fun(t.param, reduceApplicative(t.body, composeFun(cb, t.param)))\n    case 'app':\n      let l = reduceCallByValue(t.left, composeAppR(cb, t.right))\n      if (l.type === 'fun') {\n        const r = reduceApplicative(t.right, composeAppL(cb, l))\n        return reduceApplicative(apply(l, r, cb), cb)\n      } else {\n        l = reduceApplicative(l, composeAppR(cb, t.right))\n        const r = reduceApplicative(t.right, composeAppL(cb, l))\n        return App(l, r)\n      }\n    case 'def':\n      return reduceApplicative(resolveDefinition(t, cb), cb)\n  }\n}\n\nconst apply = (fun: Fun, subst: Term, cb: Callback) => {\n  const renameCb = composeFun(composeAppR(cb, subst), fun.param)\n  const renamedBody = renameForSubstitution(\n    fun.body,\n    fun.param,\n    subst,\n    renameCb\n  )\n  const renamed = App(Fun(fun.param, renamedBody), subst)\n  const applied = applySubstitution(renamedBody, fun.param, subst)\n  cb(markStep({ type: 'beta', before: renamed, after: applied }))\n  return applied\n}\n\n// Performs any available η-reductions on a term.\nconst reduceEta: Reducer = (t, cb) => {\n  switch (t.type) {\n    case 'var':\n      return t\n    case 'fun':\n      // First reduce \"down\" in case the body is an application and its rhs can\n      // be eta-reduced down to a var.\n      const body = reduceEta(t.body, composeFun(cb, t.param))\n      const before = body === t.body ? t : Fun(t.param, body)\n      // λx.(F x) = F if x is free in F\n      if (\n        body.type === 'app' &&\n        body.right.type === 'var' &&\n        body.right.name === t.param &&\n        !freeIn(t.param, body.left)\n      ) {\n        cb(markStep({ type: 'eta', before, after: body.left }))\n        return body.left\n      } else {\n        return before\n      }\n    case 'app':\n      const l = reduceEta(t.left, composeAppR(cb, t.right))\n      const r = reduceEta(t.right, composeAppL(cb, l))\n      return App(l, r)\n    case 'def':\n      return t\n  }\n}\n\nconst reduceFunctions = {\n  normal: reduceNormal,\n  applicative: reduceApplicative,\n  cbn: reduceCallByName,\n  cbv: reduceCallByValue\n}\n\nconst resolveDefinition = (def: Def, cb: Callback) => {\n  let after = def.term\n  while (after.type === 'def') {\n    after = after.term\n  }\n  cb(markStep({ type: 'def', before: def, after }))\n  return after\n}\n","import freeIn from './free-in'\nimport {\n  Callback,\n  composeAppL,\n  composeAppR,\n  composeFun,\n  markStep\n} from './helpers'\nimport { App, Fun, Term, Var } from './terms'\n\n// Applies the substitution T[x := S]\n// I.e., substitutes the variable x for the term S in the term T.\nexport const substitute = (t: Term, x: string, s: Term): Term => {\n  switch (t.type) {\n    case 'var':\n      // x[x := S] = S\n      // y[x := S] = y\n      return t.name === x ? s : t\n    case 'fun':\n      // (λx.E)[x := S] = λx.E\n      // λx creates a new context for x so no further substitution is needed.\n      if (t.param === x) {\n        return t\n      }\n      // (λy.E)[x := S] with x != y\n      // If y is free in S and x is free in E, then must α-convert λy.E to avoid\n      // name conflicts.\n      if (freeIn(t.param, s) && freeIn(x, t.body)) {\n        // (λy.E)[x := S] = λy'.(E[y := y'][x := S])\n        const newVarName = renameVar(t.param, t.body, s)\n        const renamedBody = applySubstitution(t.body, t.param, Var(newVarName))\n        return Fun(newVarName, substitute(renamedBody, x, s))\n      } else {\n        // (λy.E)[x := S] = λy.(E[x := S])\n        return Fun(t.param, substitute(t.body, x, s))\n      }\n    case 'app':\n      // (U V)[x := S] = (U[x := S]) (V[x := S])\n      return App(substitute(t.left, x, s), substitute(t.right, x, s))\n    case 'def':\n      return t\n  }\n}\n\n// Note: renameForSubstitution() and applySubstitution() are the same as\n// substitute(), only split up into two different steps. We need them that way\n// to be able to do all alpha-renaming steps before each beta-reduction, but it\n// would be nice to have these three functions DRY up a bit.\n\n// Performs the α-conversions necessary for the substitution T[x := S], but does\n// not perform the substitution itself.\n// Records the α-conversions by calling cb.\nexport const renameForSubstitution = (\n  t: Term,\n  x: string,\n  s: Term,\n  cb: Callback\n): Term => {\n  switch (t.type) {\n    case 'var':\n    case 'def':\n      return t\n    case 'fun':\n      if (t.param === x) {\n        return t\n      }\n      if (freeIn(t.param, s) && freeIn(x, t.body)) {\n        const newVarName = renameVar(t.param, t.body, s)\n        const renamedBody = applySubstitution(t.body, t.param, Var(newVarName))\n        const renamedFun = Fun(newVarName, renamedBody)\n        cb(markStep({ type: 'alpha', before: t, after: renamedFun }))\n        t = renamedFun\n      }\n      const body = renameForSubstitution(t.body, x, s, composeFun(cb, t.param))\n      return Fun(t.param, body)\n    case 'app':\n      const l = renameForSubstitution(t.left, x, s, composeAppR(cb, t.right))\n      const r = renameForSubstitution(t.right, x, s, composeAppL(cb, l))\n      return App(l, r)\n  }\n}\n\n// Applies the substitution T[x := S] directly, without doing α-conversions.\nexport const applySubstitution = (t: Term, x: string, s: Term): Term => {\n  switch (t.type) {\n    case 'var':\n      return t.name === x ? s : t\n    case 'fun':\n      return t.param === x ? t : Fun(t.param, applySubstitution(t.body, x, s))\n    case 'app':\n      const l = applySubstitution(t.left, x, s)\n      const r = applySubstitution(t.right, x, s)\n      return App(l, r)\n    case 'def':\n      return t\n  }\n}\n\n// Renames a variable to avoid naming conflicts case doing: a substitution.\nconst renameVar = (oldName: string, t: Term, s: Term) => {\n  // Split the name into base and number part.\n  const base = oldName.replace(/\\d+$/, '')\n  const match = oldName.match(/\\d+$/)\n  let n = match ? parseInt(match[0], 10) : 0\n\n  while (true) {\n    n++\n    const newName = base + n\n    const isValid =\n      // Avoid name collisions with substitution term.\n      !freeIn(newName, s) &&\n      // Avoid name collisions with free variables in body.\n      !freeIn(newName, t) &&\n      // Avoid name collisions with inner functions.\n      !varRenameCollides(t, oldName, newName)\n\n    if (isValid) {\n      return newName\n    }\n  }\n}\n\n// Whether a variable rename collides in a given term. That is, if changing the\n// occurrences of oldName with newName in t would make it change t's meaning\n// (i.e. not be α-equivalent).\nconst varRenameCollides = (\n  t: Term,\n  oldName: string,\n  newName: string\n): boolean => {\n  switch (t.type) {\n    case 'var':\n    case 'def':\n      return false\n    case 'fun':\n      // A variable rename collides with this function if the old variable\n      // was free in the function and the new name for the variable is the\n      // same as the param of the function, thus changing old free variable\n      // binding.\n      return (\n        (t.param === newName && freeIn(oldName, t)) ||\n        // Or if the renaming collides in the body of the function.\n        varRenameCollides(t.body, oldName, newName)\n      )\n    case 'app':\n      return (\n        varRenameCollides(t.left, oldName, newName) ||\n        varRenameCollides(t.right, oldName, newName)\n      )\n  }\n}\n","type Var = { type: 'var'; name: string }\ntype Fun = { type: 'fun'; param: string; body: Term }\ntype App = { type: 'app'; left: Term; right: Term }\ntype Def = { type: 'def'; name: string; term: Term }\ntype Term = Var | Fun | App | Def\n\n// Term constructors.\nconst Var = (name: string): Var => ({ type: 'var', name })\nconst Fun = (param: string, body: Term): Fun => ({ type: 'fun', param, body })\nconst App = (left: Term, right: Term): App => ({ type: 'app', left, right })\nconst Def = (name: string, term: Term): Def => ({ type: 'def', name, term })\n\nexport { Term, Var, Fun, App, Def }\n","let logTimings = false\n\nexport const timed =\n  <Args extends unknown[], R>(name: string, fn: (...args: Args) => R) =>\n  (...args: Args) => {\n    if (logTimings) {\n      console.time(name)\n    }\n    const res = fn(...args)\n    if (logTimings) {\n      console.timeEnd(name)\n    }\n    return res\n  }\n\nexport const enableLogTimings = () => {\n  logTimings = true\n}\nexport const disableLogTimings = () => {\n  logTimings = false\n}\n\nexport const identity = <T>(x: T) => x\n\n// Note: it would be nice to replace this overly-clever function with\n// String.dedent() once it gets standardized. See https://github.com/tc39/proposal-string-dedent\nexport const dedent = (str: string) => {\n  const match = str.match(/^[ \\t]*(?=\\S)/gm)\n  if (!match) {\n    return str\n  }\n\n  const indent = Math.min(...match.map(x => x.length))\n  const re = new RegExp(`^[ \\\\t]{${indent}}`, 'gm')\n  const unindented = indent > 0 ? str.replace(re, '') : str\n\n  return unindented.trim()\n}\n"],"mappings":"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"}