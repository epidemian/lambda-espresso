{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/app.js","src/dom.js","src/examples.js","src/lambda/alpha-eq.js","src/lambda/format.js","src/lambda/free-in.js","src/lambda/grammar.js","src/lambda/helpers.js","src/lambda/index.js","src/lambda/parse.js","src/lambda/reduce-program.js","src/lambda/reduce.js","src/lambda/substitute.js","src/lambda/terms.js","src/utils.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","ref","reduceProgram","examples","ref$1","timed","enableLogTimings","dedent","ref$2","$","delegate","once","nodeIndex","input","output","document","addEventListener","keyCode","ctrlKey","run","value","replace","start","selectionStart","end","selectionEnd","_","renderTerm","term","className","renderArrow","symbol","label","renderArrowByType","type","arrowSymbols","alpha","beta","eta","renderSynonyms","synonyms","join","getOptions","maxSteps","parseInt","strategy","etaEnabled","checked","reductions","renderReductions","err","textContent","message","classList","add","innerHTML","map","renderCollapsedReduction","remove","element","reduction","totalSteps","expanded","querySelector","collapsed","toggle","renderExpandedReductionForm","prev","previousElementSibling","renderCollapsedReductionForm","initial","arrow","final","finalSynonyms","steps","step","renderStep","renderStepOptions","before","after","lastStep","push","highlightStep","str","highlightFormerTerm","highlightSubstitutionTerm","focus","examplesMenu","examplesHtml","example","href","encodeURI","event","preventDefault","scrollTop","examplesDropdown","contains","stopPropagation","location","hash","updateInputFromHash","decodeURI","codeStart","indexOf","slice","window","bind","eventType","selector","handler","target","currentTarget","matches","parentNode","onceListener","removeEventListener","Array","prototype","childNodes","name","Var","Fun","App","Def","substitute","alphaEq","t1","t2","param","body","left","right","identity","format","appParens","funParens","h","highlight","lambda","highlightVar","funStr","lStr","rStr","appStr","freeIn","x","grammar","k","v","$V0","$V1","$V2","$V3","$V4","$V5","parser","trace","yy","symbols_","error","root","program","EOF","line","SEPARATOR","ident","=","LAMBDA",".","(",")","IDENT","$accept","$end","terminals_","2","5","7","10","11","12","13","14","15","productions_","performAction","anonymous","yytext","yyleng","yylineno","yystate","$$","_$","$0","this","parseTopLevelTerm","parseDefinition","parseFunction","parseApplication","parseIdentifier","table","3","4","6","8","9","defaultActions","parseError","recoverable","_parseError","msg","parse","self","stack","tstack","vstack","lstack","recovering","TERROR","args","arguments","lexer","Object","create","sharedState","this$1","hasOwnProperty","setInput","yylloc","yyloc","ranges","options","getPrototypeOf","popStack","_token_stack","lex","token","preErrorSymbol","state","action","yyval","p","len","newState","expected","errStr","showPosition","text","match","loc","first_line","last_line","first_column","last_column","range","apply","concat","openParens","_input","_more","_backtrack","done","matched","conditionStack","offset","ch","lines","unput","split","substr","oldLines","more","reject","backtrack_lexer","less","pastInput","past","upcomingInput","next","pre","c","test_match","indexed_rule","backup","tempMatch","index","rules","_currentRules","flex","begin","condition","popState","pop","conditions","topState","Math","abs","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","YYSTATE","INITIAL","inclusive","Parser","main","commonjsMain","console","log","process","exit","source","readFileSync","normalize","argv","extend","composeFun","fn","b","composeAppL","composeAppR","markStep","collapseWhitespace","defs","terms","Ref","forEach","resolveTermRefs","refNames","resolveDefRefs","boundNames","free","defName","bound","checkForCircularRefs","boundOnBody","refName","path","circularNote","nextRefs","nextRef","compose","reduce","reduceTerm","enough","terminates","last","findSynonyms","expandStep","stepTerm","find","subT","highlightFormer","highlightSubst","highlightFunctionVar","fun","hs","ha","hx","ht","from","to","renameForSubstitution","applySubstitution","cb","reduceFunctions","reduced","reduceEta","reduceCallByName","reduceNormal","reduceCallByValue","reduceApplicative","r$1","subst","renameCb","renamedBody","renamed","applied","isEta","normal","applicative","cbn","cbv","newVarName","renameVar","oldName","base","newName","isValid","varRenameCollides","assign","obj","srcs","src","logTimings","time","res","timeEnd","disableLogTimings","g","indent","min","re","RegExp","unindented","trim"],"mappings":"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","sourceRoot":".","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// Script for index.html\nlet {reduceProgram} = require('./lambda')\nlet examples = require('./examples')\nlet {timed, enableLogTimings, dedent} = require('./utils')\nlet {$, delegate, once, nodeIndex} = require('./dom')\n\nenableLogTimings()\n\nlet input = $('.input')\nlet output = $('.output')\n\n// Run code on ctrl+enter.\ndocument.addEventListener('keyup', e => {\n  if (e.keyCode === 13 && e.ctrlKey) {\n    run()\n  }\n})\n\ninput.addEventListener('keyup', () => {\n  // Replace every \"\\\" with \"λ\" while typing.\n  let code = input.value\n  code = code.replace(/\\\\/g, 'λ')\n  // Preserve selection\n  let start = input.selectionStart\n  let end = input.selectionEnd\n  input.value = code\n  input.selectionStart = start\n  input.selectionEnd = end\n})\n\n$('.run').addEventListener('click', _ => run())\n\nlet renderTerm = (term, className = '') =>\n  `<span class=\"term ${className}\">${term}</span>`\n\nlet renderArrow = (symbol, label) =>\n  `<span class=arrow>${symbol}<small>${label}</small></span>`\n\nlet renderArrowByType = type => {\n  let symbol = type === 'def' ? '≡' : '→'\n  let label = arrowSymbols[type] || ''\n  return renderArrow(symbol, label)\n}\n\nlet arrowSymbols = {\n  alpha: 'α',\n  beta: 'β',\n  eta: 'η'\n}\n\nlet renderSynonyms = synonyms =>\n  synonyms.length\n    ? `<span class=synonyms>(${synonyms.join(', ')})</span>`\n    : ''\n\nlet getOptions = () => {\n  let maxSteps = parseInt($('input[name=max-steps]').value || 0)\n  let strategy = $('input[name=strategy]:checked').value\n  let etaEnabled = $('[name=eta-reductions]').checked\n  return {maxSteps, strategy, etaEnabled}\n}\n\nlet reductions = null\nlet run = () => {\n  let code = input.value\n  try {\n    reductions = reduceProgram(code, getOptions())\n    renderReductions()\n  } catch (err) {\n    output.textContent = err.message\n    output.classList.add('error')\n  }\n}\n\nlet renderReductions = timed('render html', () => {\n  output.innerHTML = reductions.map(renderCollapsedReduction).join('')\n  output.classList.remove('error')\n})\n\ndelegate('click', output, '.reduction', element => {\n  let reduction = reductions[nodeIndex(element)]\n  if (reduction.totalSteps === 0) return\n  let expanded = element.querySelector('.expanded')\n  let collapsed = element.querySelector('.collapsed')\n  if (expanded) {\n    expanded.classList.toggle('hidden')\n    collapsed.classList.toggle('hidden')\n  } else {\n    collapsed.classList.add('hidden')\n    element.innerHTML += renderExpandedReductionForm(reduction)\n  }\n})\n\ndelegate('mouseover', output, '.expanded .step', element => {\n  element.classList.add('highlight')\n  // Hide the previous step's after term.\n  let prev = element.previousElementSibling\n  prev && prev.querySelector('.after').classList.add('hidden')\n})\n\ndelegate('mouseout', output, '.expanded .step', element => {\n  element.classList.remove('highlight')\n  let prev = element.previousElementSibling\n  prev && prev.querySelector('.after').classList.remove('hidden')\n})\n\nlet renderCollapsedReduction = reduction =>\n  `<div class=reduction>${renderCollapsedReductionForm(reduction)}</div>`\n\nlet renderCollapsedReductionForm = reduction => {\n  let initial = renderTerm(reduction.initial)\n  let arrow = ''\n  let final = ''\n  if (reduction.totalSteps > 0) {\n    arrow = renderArrow('→', `(${reduction.totalSteps})`)\n    final = renderTerm(reduction.final)\n  }\n  let synonyms = renderSynonyms(reduction.finalSynonyms)\n  return `<div class=collapsed>${initial} ${arrow} ${final} ${synonyms}</div>`\n}\n\nlet renderExpandedReductionForm = reduction => {\n  let steps = []\n  for (let i = 0; i < reduction.totalSteps; i++) {\n    let step = reduction.renderStep(i, renderStepOptions)\n    let before = renderTerm(step.before, 'before')\n    let after = renderTerm(step.after, 'after')\n    let arrow = renderArrowByType(step.type)\n    let lastStep = i === reduction.totalSteps - 1\n    let synonyms = lastStep ? renderSynonyms(reduction.finalSynonyms) : ''\n    steps.push(\n      `<span class=step>${before}<br>${arrow} ${after} ${synonyms}</span>`\n    )\n  }\n\n  return `<div class=expanded>${steps.join('')}</div>`\n}\n\nlet renderStepOptions = {\n  highlightStep: str => `<span class=match>${str}</span>`,\n  highlightFormerTerm: str => `<span class=former-term>${str}</span>`,\n  highlightSubstitutionTerm: str => `<span class=subst-term>${str}</span>`\n}\n\ninput.value = dedent(`\n  ; Write some λ-expressions here and hit Run. Use \"\\\\\" to enter \"λ\" ;)\n  (λx.λy.λz.z y x) a b c\n`)\ninput.focus()\n\nlet examplesMenu = $('.examples-menu')\nlet examplesHtml = examples.map((example, i) => {\n  let href = encodeURI(`#>${example.code}`)\n  return `<li><a href=\"${href}\">${i} - ${example.name}</a></li>`\n})\n\nexamplesMenu.innerHTML = examplesHtml.join('')\ndelegate('click', examplesMenu, 'li', (element, event) => {\n  event.preventDefault() // Don't change the location.hash\n  input.value = examples[nodeIndex(element)].code\n  input.scrollTop = 0\n})\n\nlet examplesDropdown = $('.examples-dropdown')\nexamplesDropdown.addEventListener('click', e => {\n  if (examplesDropdown.classList.contains('active')) return\n  e.stopPropagation()\n  examplesDropdown.classList.add('active')\n  once('click', document, () => examplesDropdown.classList.remove('active'))\n})\n\n$('button.link').addEventListener('click', () => {\n  let code = input.value\n  location.hash = `>${code}`\n})\n\nlet updateInputFromHash = () => {\n  let hash = decodeURI(location.hash)\n  let codeStart = hash.indexOf('>')\n  if (codeStart >= 0) {\n    input.value = hash.slice(codeStart + 1)\n  }\n}\n\nwindow.addEventListener('hashchange', updateInputFromHash)\nupdateInputFromHash()\n","exports.$ = document.querySelector.bind(document)\n\n// Similar to jQuery.fn.on(type, selector, handler)\nexports.delegate = (eventType, element, selector, handler) => {\n  element.addEventListener(eventType, event => {\n    let element = event.target\n    // Try to find matching element bubbling up from event target.\n    while (element !== event.currentTarget) {\n      if (element.matches(selector)) {\n        handler(element, event)\n        break\n      }\n      element = element.parentNode\n    }\n  })\n}\n\n// Add an event listener that is only called once.\nexports.once = (eventType, element, handler) => {\n  let onceListener = event => {\n    handler(event)\n    element.removeEventListener(eventType, onceListener)\n  }\n  element.addEventListener(eventType, onceListener)\n}\n\nexports.nodeIndex = element => {\n  return Array.prototype.indexOf.call(element.parentNode.childNodes, element)\n}\n","let {dedent} = require('./utils')\n\n/* eslint-disable max-len */\nmodule.exports = [{\n  name: 'Basics',\n  code: dedent(`\n    ; This example is not intend to be a tutorial nor an introduction to λ Calculus.\n    ; You should check http://en.wikipedia.org/wiki/Lambda_calculus for that :)\n    ; As you can see, these are comments. You can run this example clicking the Run\n    ; button below or pressing Ctrl+Enter.\n    ; So, the three basic types of λ expressions are:\n    ; Variables:\n    x\n    ; Applications:\n    x y\n    ; And lambda abstractions (also known as functions):\n    λx.x\n    ; If the left-side of an application is an abstraction, then a reduction takes place:\n    (λx.x) y\n    ; That little abstraction at the left is the identity, a very simple function that\n    ; just reduces to whatever you apply to it. We can give it a name like so:\n    id = λx.x\n    ; And then just refer it by that name:\n    id a\n    ; You can apply any kind of λ expression to an abstraction, like another function:\n    id λb.c\n    ; Or an application:\n    id (x y)\n    ; Or even the identity function itself:\n    id id\n    ; That means you can apply identity to itself as many times as you want and it'll still\n    ; be identity:\n    id id id id id\n    ; Notice that applications are left-associative, so the line above is equivalent to:\n    ((((id id) id) id) id)\n\n    ; TODO: explain applicative and normal order...\n  `)\n}, {\n  name: 'Booleans',\n  code: dedent(`\n    ; Church booleans\n\n    ; The booleans and their operations can be encoded as the following λ-terms:\n    true = λt.λf.t\n    false = λt.λf.f\n    not = λp.p false true\n    and = λp.λq.p q p\n    or = λp.λq.p p q\n    if = λp.p\n\n    ; Print truth tables for not, and and or:\n    not true\n    not false\n    and false false\n    and false true\n    and true false\n    and true true\n    or false false\n    or false true\n    or true false\n    or true true\n\n    ; Terms can be nested as much as we want:\n    if (not (not true)) (or false (if true true false)) false\n\n    ; There's nothing special about \"operators\", we can treat them as any other value:\n    (if false or and) true false\n  `)\n}, {\n  name: 'Numbers',\n  code: dedent(`\n    ; Church numerals\n\n    ; The first few numbers are:\n    zero = λs.λz.z\n    one = λs.λz.s z\n    two = λs.λz.s (s z)\n    three = λs.λz.s (s (s z))\n    ; In general, any natural number n can be encoded as:\n    ; N = λs.λz.s (s (s ... (s (s z)) ... ))\n    ; with s applied n times.\n\n    ; When we get tired of writing numbers like that, we can define a successor function:\n    succ = λn.λs.λz.s (n s z)\n    succ three\n\n    ; We can think of Church numerals as functions that apply a given function s to a\n    ; given value z a number of times. Zero will apply it 0 times (i.e. it'll give\n    ; us z back untouched) and three will call it 3 times.\n    ; So, we can represent the addition of numbers m and n as first applying n times s to z,\n    ; and then applying m times s to that:\n    add = λm.λn.λs.λz.m s (n s z)\n    add two three\n    ; ...or, more succinctly, as applying n times the successor function on m (or vice versa):\n    add' = λm.λn.n succ m\n    add' two three\n    ; Conversely, we could define the successor function as adding one:\n    succ' = add one\n    succ' three\n\n    ; Multiplication of m by n is applying m times a function that applies s n times:\n    mult = λm.λn.λs.m (n s)\n    mult three three\n    ; ...or applying m times the addition of n to zero:\n    mult' = λm.λn.m (add n) zero\n    mult' three three\n\n    ; Exponentiation n^m has a simple encoding: applying the base m to the exponent n,\n    ; which can be understood as applying m successively n times:\n    exp = λm.λn.n m\n    exp two three\n    ; ...or, alternatively, applying m times the multiplication by n to one:\n    exp' = λm.λn.m (mult n) one\n    exp' two three\n\n    ; The encoding for the predecessor function is quite complex.\n    ; The Wikipedia article on Church encoding has a good explanation for this term ;-)\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    pred three\n\n    ; But given the predecessor function is then easy to define the subtraction:\n    sub = λm.λn.n pred m\n    sub three two\n\n    ; To build some predicate functions, we'll use some known boolean terms (see \n    ; Booleans example for more info):\n    true = λt.λf.t\n    false = λt.λf.f\n    and = λp.λq.p q p\n\n    ; To know if a number n is zero we can pass true as the base value and a function\n    ; that always returns false (note that the \"?\" is no special syntax; it's just \n    ; part of the name of the predicate):\n    zero? = λn.n (λx.false) true\n    zero? zero\n    zero? two\n\n    ; To know if a number is less or equal to another number, we can subtract them and\n    ; see if the result is zero:\n    leq = λm.λn.zero? (sub m n)\n\n    ; And given that predicate, numeric equality between m and n can be defined as:\n    eq = λm.λn.and (leq m n) (leq n m)\n\n    ; Throwing everything into the mix, we can prove that 2³ = 3² - 1:\n    eq (exp two three) (pred (exp three two))\n  `)\n}, {\n  name: 'Factorial',\n  code: dedent(`\n    ; Factorial function and recursion\n\n    ; Note: for this example we'll use boolean and numeric terms from previous \n    ; examples (see below). \n    ; Also not that these factorial definitions won't work with applicative order ;)\n\n    ; We'd like to be able to define a factorial function as:\n    ; fact = λn.if (zero? n) one (mult n (fact (pred n)))\n    ; But we can't use a term in its own definition.\n    ; To achieve recursion, we can instead define a function that will receive itself\n    ; as a parameter r, and then recur by calling r with itself and n - 1:\n    fact-rec = λr.λn.if (zero? n) one (mult n (r r (pred n)))\n    ; The real factorial function would then be:\n    fact = fact-rec fact-rec\n    fact four\n\n    ; Another way to recur is to use a general purpose fixed-point combinator.\n    ; The almighty Y Combinator:\n    Y = λf.(λx.f (x x)) (λx.f (x x))\n    ; And then there's no need to define a separate function:\n    fact' = Y λr.λn.if (zero? n) one (mult n (r (pred n)))\n    fact' four\n\n    ; Borrow some terms from previous examples:\n    true = λt.λf.t\n    false = λt.λf.f\n    if = λp.p\n    zero = λs.λz.z\n    one = λs.λz.s z\n    two = λs.λz.s (s z)\n    three = λs.λz.s (s (s z))\n    four = λs.λz.s (s (s (s z)))\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    mult = λm.λn.λs.m (n s)\n    zero? = λn.n (λx.false) true\n  `)\n}, {\n  name: 'Extras',\n  code: dedent(`\n    ; Syntactic Trivia and Miscellaneous\n  \n    ; Identifiers can contain basically any character (except the few ones reserved for \n    ; syntax: \"λ\", \".\", \"=\", \"(\" and \")\").\n    ; This means you can write some pretty code-looking lambda terms!\n    0 = λs.λz.z\n    1 = λs.λz.s z\n    2 = λs.λz.s (s z)\n    + = λm.λn.λs.λz.m s (n s z)\n    * = λm.λn.λs.m (n s)\n    (+ (* 2 1) 0)\n    ; Reinventing (a part of) Lisp is always fun...\n\n    ; You can even use emojis as identifiers! But make sure to use this power responsibly.\n    (λ🐴.❓) 🍎\n\n    ; Although line breaks usually act as separators between terms/definitions, \n    ; you can use parentheses to split a complex term into multiple lines:\n    fib = Y λf.λn.(\n      if (≤ n 1)\n         n\n         (+ (f (- n 1))\n            (f (- n 2))))\n    fib 0\n    fib 1\n    fib 2\n    fib 7\n\n    ; The rest of the definitions to make the above code work. Not much to see here...\n    Y = λf.(λx.f (x x)) (λx.f (x x))\n    - = λm.λn.n pred m\n    ≤ = λm.λn.zero? (- m n)\n    pred = λn.λs.λz.n (λf.λg.g (f s)) (λx.z) (λx.x)\n    zero? = λn.n (λx.false) true\n    true = λt.λf.t\n    false = λt.λf.f\n    if = λp.p\n    7 = λs.λz.s (s (s (s (s (s (s z))))))\n    13 = λs.λz.s (s (s (s (s (s (s (s (s (s (s (s (s z))))))))))))\n    ❓ = λ💩.💩 💩 💩\n  `)\n}]\n","let {Var, Fun, App, Def} = require('./terms')\nlet {substitute} = require('./substitute')\n\n// Whether two terms are alpha-equivalent.\nlet alphaEq = (t1, t2) => {\n  if (t1.type === Def) return alphaEq(t1.term, t2)\n  if (t2.type === Def) return alphaEq(t1, t2.term)\n  if (t1.type !== t2.type) return false\n  switch (t1.type) {\n  case Var:\n    return t1.name === t2.name\n  case Fun:\n    if (t1.param === t2.param) {\n      return alphaEq(t1.body, t2.body)\n    } else {\n      return alphaEq(t1.body, substitute(t2.body, t2.param, Var(t1.param)))\n    }\n  case App:\n    return alphaEq(t1.left, t2.left) && alphaEq(t1.right, t2.right)\n  }\n}\n\nmodule.exports = alphaEq\n","let {Var, Fun, App, Def} = require('./terms')\nlet {identity} = require('../utils')\n\n// Returns the string representation for a given term t.\nlet format = (t, appParens = false, funParens = false) => {\n  let h = t.highlight || identity\n  switch (t.type) {\n  case Var:\n  case Def:\n    return h(t.name)\n  case Fun:\n    let lambda = `λ${t.param}`\n    if (t.highlightVar) lambda = t.highlightVar(lambda)\n    let funStr = `${lambda}.${format(t.body)}`\n    return h(funParens ? `(${funStr})` : funStr)\n  case App:\n    let lStr = format(t.left, false, true)\n    let rStr = format(t.right, true, funParens)\n    let appStr = `${lStr} ${rStr}`\n    return h(appParens ? `(${appStr})` : appStr)\n  }\n}\n\nmodule.exports = format\n","let {Var, Fun, App, Def} = require('./terms')\n\n// Whether the variable x appears free in the term t.\nlet freeIn = (x, t) => {\n  switch (t.type) {\n  case Var:\n    return t.name === x\n  case Fun:\n    return t.param !== x && freeIn(x, t.body)\n  case App:\n    return freeIn(x, t.left) || freeIn(x, t.right)\n  case Def:\n    // Definitions don't have free variables.\n    return false\n  }\n}\n\nmodule.exports = freeIn\n","/* parser generated by jison 0.4.17 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar grammar = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[5,7],$V1=[1,6],$V2=[1,7],$V3=[1,8],$V4=[2,10],$V5=[5,7,11,13,14,15];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"root\":3,\"program\":4,\"EOF\":5,\"line\":6,\"SEPARATOR\":7,\"term\":8,\"ident\":9,\"=\":10,\"LAMBDA\":11,\".\":12,\"(\":13,\")\":14,\"IDENT\":15,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",7:\"SEPARATOR\",10:\"=\",11:\"LAMBDA\",12:\".\",13:\"(\",14:\")\",15:\"IDENT\"},\nproductions_: [0,[3,2],[4,0],[4,1],[4,2],[4,3],[6,1],[6,3],[8,4],[8,2],[8,1],[8,3],[9,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\n /* do nothing; terms and definitions already collected */ \nbreak;\ncase 6:\n this.$ = yy.parseTopLevelTerm($$[$0]); \nbreak;\ncase 7:\n this.$ = yy.parseDefinition($$[$0-2], $$[$0]); \nbreak;\ncase 8:\n this.$ = yy.parseFunction($$[$0-2], $$[$0]); \nbreak;\ncase 9:\n this.$ = yy.parseApplication($$[$0-1], $$[$0]); \nbreak;\ncase 10:\n this.$ = yy.parseIdentifier($$[$0]); \nbreak;\ncase 11:\n this.$ = $$[$0-1]; \nbreak;\ncase 12:\n this.$ = yytext; \nbreak;\n}\n},\ntable: [o($V0,[2,2],{3:1,4:2,6:3,8:4,9:5,11:$V1,13:$V2,15:$V3}),{1:[3]},{5:[1,9],7:[1,10]},o($V0,[2,3]),o($V0,[2,6],{8:11,9:12,11:$V1,13:$V2,15:$V3}),o([5,7,11,13,15],$V4,{10:[1,13]}),{9:14,15:$V3},{8:15,9:12,11:$V1,13:$V2,15:$V3},o([5,7,10,11,12,13,14,15],[2,12]),{1:[2,1]},o($V0,[2,4],{8:4,9:5,6:16,11:$V1,13:$V2,15:$V3}),o($V5,[2,9],{8:11,9:12}),o($V5,$V4),{8:17,9:12,11:$V1,13:$V2,15:$V3},{12:[1,18]},{8:11,9:12,11:$V1,13:$V2,14:[1,19],15:$V3},o($V0,[2,5]),o($V0,[2,7],{8:11,9:12,11:$V1,13:$V2,15:$V3}),{8:20,9:12,11:$V1,13:$V2,15:$V3},o($V5,[2,11]),o([5,7,14],[2,8],{8:11,9:12,11:$V1,13:$V2,15:$V3})],\ndefaultActions: {9:[2,1]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        function _parseError (msg, hash) {\n            this.message = msg;\n            this.hash = hash;\n        }\n        _parseError.prototype = Error;\n\n        throw new _parseError(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n var openParens = 0; /* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0: openParens++; return 13; \nbreak;\ncase 1: openParens--; return 14; \nbreak;\ncase 2: return 11; \nbreak;\ncase 3: return 12; \nbreak;\ncase 4: return 10; \nbreak;\ncase 5: /* ignore separators inside parens */\n                   if (openParens <= 0) return 7\n                 \nbreak;\ncase 6: /* ignore whitespace */ \nbreak;\ncase 7: /* ignore line comments */ \nbreak;\ncase 8: return 15; \nbreak;\ncase 9: return 5; \nbreak;\n}\n},\nrules: [/^(?:\\()/,/^(?:\\))/,/^(?:\\\\|λ)/,/^(?:\\.)/,/^(?:=)/,/^(?:\\n)/,/^(?:[^\\S\\n]+)/,/^(?:;.*)/,/^(?:[^\\s\\(\\)\\\\λ\\.=]+)/,/^(?:$)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = grammar;\nexports.Parser = grammar.Parser;\nexports.parse = function () { return grammar.parse.apply(grammar, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}","let {Fun, App} = require('./terms')\nlet {extend} = require('../utils')\n\n// Compose a function with a term constructor.\nexports.composeFun = (fn, x) => (b) => fn(Fun(x, b))\nexports.composeAppL = (fn, l) => (r) => fn(App(l, r))\nexports.composeAppR = (fn, r) => (l) => fn(App(l, r))\n\n// Mark a reduction step on the `after` term.\nexports.markStep = (type, before, after) =>\n  extend({}, after, {step: {type, before}})\n","let {Var, Fun, App, Def} = require('./terms')\nlet parse = require('./parse')\nlet format = require('./format')\nlet reduceProgram = require('./reduce-program')\n\nmodule.exports = { Var, Fun, App, Def, parse, format, reduceProgram }\n","let {Var, Fun, App, Def} = require('./terms')\nlet {timed, collapseWhitespace} = require('../utils')\nlet {Parser} = require('./grammar')\n\n// Parses an input program string and returns an object with the top-level terms\n// and definitions of the program.\nmodule.exports = timed('parse', str => {\n  // A custom Jison parser.\n  let parser = new Parser()\n\n  // A definition table with the definition term by their names.\n  let defs = {}\n  // The terms of the program.\n  let terms = []\n\n  // Add some handy functions so the parser can build the AST.\n  parser.yy = {\n    parseFunction: Fun,\n    parseApplication: App,\n    parseDefinition: (name, term) => {\n      if (defs[name]) throw Error(`${name} already defined`)\n      defs[name] = term\n    },\n    parseTopLevelTerm: (term) => {\n      terms.push(term)\n    },\n    parseIdentifier: Ref\n  }\n\n  parser.parse(str)\n\n  terms.forEach(t => resolveTermRefs(t, defs))\n\n  let refNames = {}\n  for (let name in defs) {\n    resolveDefRefs(name, defs[name], defs, refNames)\n  }\n\n  return {defs, terms}\n})\n\n// Temporary term used only while parsing as a placeholder for wither a Var o a\n// Ref. On the first pass the parser cannot know if an identifier is a variable\n// or a definition (because definitions can be declared after their use), so it\n// stores a Ref instead and then on a second pass decides what it should be and\n// *mutates* the Ref in-place to become either a Var or a Ref.\nlet Ref = name => ({type: Ref, name})\n\n// Changes all Refs inside term t to either Vars or Defs.\nlet resolveTermRefs = (t, defs, boundNames = []) => {\n  switch (t.type) {\n  case Ref:\n    let free = boundNames.indexOf(t.name) < 0\n    if (t.name in defs && free) {\n      t.type = Def\n      t.term = defs[t.name]\n    } else {\n      t.type = Var\n    }\n    break\n  case App:\n    resolveTermRefs(t.left, defs, boundNames)\n    resolveTermRefs(t.right, defs, boundNames)\n    break\n  case Fun:\n    resolveTermRefs(t.body, defs, boundNames.concat(t.param))\n    break\n  }\n}\n\n// Changes all Refs inside term t to either Vars or Defs.\nlet resolveDefRefs = (defName, t, defs, refNames, boundNames = []) => {\n  switch (t.type) {\n  case Ref:\n    let bound = boundNames.indexOf(t.name) >= 0\n    if (bound) {\n      t.type = Var\n    } else if (t.name in defs) {\n      refNames[defName] = [...refNames[defName] || [], t.name]\n      checkForCircularRefs(defName, t.name, refNames)\n      t.type = Def\n      t.term = defs[t.name]\n    } else {\n      throw Error(collapseWhitespace(\n        `Illegal free variable \"${t.name}\" in \"${defName}\". \n        Definitions cannot have free variables.`\n      ))\n    }\n    break\n  case App:\n    resolveDefRefs(defName, t.left, defs, refNames, boundNames)\n    resolveDefRefs(defName, t.right, defs, refNames, boundNames)\n    break\n  case Fun:\n    let boundOnBody = boundNames.concat(t.param)\n    resolveDefRefs(defName, t.body, defs, refNames, boundOnBody)\n    break\n  }\n}\n\nlet checkForCircularRefs = (name, refName, refNames, path = []) => {\n  if (name === refName) {\n    let circularNote = path.length\n      ? `In this case the definition does not reference itself directly, but \n        through other definitions: ${[name, ...path, name].join(' → ')}.`\n      : ''\n    throw Error(collapseWhitespace(\n      `Illegal recursive reference in \"${name}\". Definitions cannot\n      reference themselves; they are just simple find&replace mechanisms.\n      ${circularNote}\n      If you want to write a recursive function, look for \"Y combinator\" ;)`\n    ))\n  }\n\n  let nextRefs = refNames[refName] || []\n  nextRefs.forEach(nextRef =>\n    checkForCircularRefs(name, nextRef, refNames, [...path, refName])\n  )\n}\n","let {extend, timed, compose, identity} = require('../utils')\nlet {Var, Fun, App, Def} = require('./terms')\nlet parse = require('./parse')\nlet reduce = require('./reduce')\nlet {substitute} = require('./substitute')\nlet format = require('./format')\nlet alphaEq = require('./alpha-eq')\n\n// Reduce a program and return with the reduction for each term in the program.\nmodule.exports = (program, options = {}) => {\n  let {terms, defs} = parse(program)\n  return terms.map(term => reduceTerm(term, defs, options))\n}\n\n// Reduces a term up to its normal form.\nlet reduceTerm = timed('reduce', (term, defs,\n  {maxSteps = 100, strategy = 'normal', etaEnabled = false} = {}) => {\n  let enough = {}\n  let steps = []\n  let terminates = false\n  try {\n    reduce(term, {strategy, etaEnabled}, step => {\n      if (steps.length >= maxSteps) throw enough\n      steps.push(step)\n    })\n    terminates = true\n  } catch (e) {\n    if (e !== enough) throw e\n    terminates = false\n  }\n\n  let last = steps[steps.length - 1] || term\n  let finalSynonyms = findSynonyms(last, defs)\n  let initial = format(term)\n  let final = format(last)\n  let totalSteps = steps.length\n  let renderStep = (i, options) =>\n    expandStep(steps[i], options)\n  return {initial, final, finalSynonyms, terminates, totalSteps, renderStep}\n})\n\nlet expandStep = (t, options = {}) => {\n  let stepTerm = find(t, subT => subT.step)\n  let type = stepTerm.step.type\n  let before = stepTerm.step.before\n  let after = stepTerm\n\n  let highlightFormer = options.highlightFormerTerm || identity\n  let highlightSubst = options.highlightSubstitutionTerm || identity\n  let highlightStep = options.highlightStep || identity\n\n  switch (type) {\n  case 'alpha':\n    before = highlightFunctionVar(before.body, before.param, highlightFormer)\n    after = highlightFunctionVar(after.body, after.param, highlightSubst)\n    break\n  case 'beta':\n    let fun = before.left\n    let hs = highlight(before.right, highlightSubst)\n    let ha = highlightFunctionVar(fun.body, fun.param, highlightFormer)\n    before = App(ha, hs)\n    after = substitute(fun.body, fun.param, hs)\n    break\n  case 'eta':\n  case 'def':\n    before = highlight(before, highlightFormer)\n    after = highlight(after, highlightSubst)\n  }\n\n  before = highlight(before, highlightStep)\n  after = highlight(after, highlightStep)\n\n  before = format(replace(t, stepTerm, before))\n  after = format(replace(t, stepTerm, after))\n\n  return {type, before, after}\n}\n\nlet highlight = (t, fn) => {\n  if (t.highlight) fn = compose(fn, t.highlight)\n  return extend({}, t, {highlight: fn})\n}\n\nlet highlightFunctionVar = (t, x, fn) => {\n  let hx = highlight(Var(x), fn)\n  let ht = substitute(t, x, hx)\n  return extend(Fun(x, ht), {highlightVar: fn})\n}\n\nlet find = (t, fn) => {\n  if (fn(t)) return t\n\n  switch (t.type) {\n  case Var:\n  case Def:\n    return\n  case Fun:\n    return find(t.body, fn)\n  case App:\n    return find(t.left, fn) || find(t.right, fn)\n  }\n}\n\nlet replace = (t, from, to) => {\n  if (t === from) return to\n\n  switch (t.type) {\n  case Var:\n  case Def:\n    return t\n  case Fun:\n    let body = replace(t.body, from, to)\n    return t.body === body ? t : Fun(t.param, body)\n  case App:\n    let l = replace(t.left, from, to)\n    if (t.left !== l) return App(l, t.right)\n    let r = replace(t.right, from, to)\n    return t.right === r ? t : App(l, r)\n  }\n}\n\nlet findSynonyms = (term, defs) => {\n  let synonyms = []\n  for (let name in defs) {\n    if (alphaEq(term, defs[name])) {\n      synonyms.push(name)\n    }\n  }\n  return synonyms\n}\n\n","let {Var, Fun, App, Def} = require('./terms')\nlet {renameForSubstitution, applySubstitution} = require('./substitute')\nlet {markStep, composeFun, composeAppL, composeAppR} = require('./helpers')\nlet freeIn = require('./free-in')\n\nmodule.exports = (t, {strategy, etaEnabled}, cb) => {\n  let reduce = reduceFunctions[strategy]\n  let reduced = reduce(t, cb)\n  if (etaEnabled) {\n    reduced = reduceEta(reduced, cb)\n  }\n  return reduced\n}\n\nlet reduceCallByName = (t, cb) => {\n  switch (t.type) {\n  case Var:\n  case Fun:\n    return t\n  case App:\n    let l = reduceCallByName(t.left, composeAppR(cb, t.right))\n    return l.type === Fun\n      ? reduceCallByName(apply(l, t.right, cb), cb)\n      // TODO This is suspicious. If some reductions were made in previous\n      // l = reduceCallByName ... call, then we are losing the result of those\n      // reductions, but we have recorded them with cb.\n      : App(l, t.right)\n  case Def:\n    cb(markStep('def', t, t.term))\n    return reduceCallByName(t.term, cb)\n  }\n}\n\nlet reduceNormal = (t, cb) => {\n  switch (t.type) {\n  case Var:\n    return t\n  case Fun:\n    return Fun(t.param, reduceNormal(t.body, composeFun(cb, t.param)))\n  case App:\n    let l = reduceCallByName(t.left, composeAppR(cb, t.right))\n    if (l.type === Fun) {\n      return reduceNormal(apply(l, t.right, cb), cb)\n    } else {\n      l = reduceNormal(l, composeAppR(cb, t.right)) // Finish reducing l.\n      let r = reduceNormal(t.right, composeAppL(cb, l))\n      return App(l, r)\n    }\n  case Def:\n    cb(markStep('def', t, t.term))\n    return reduceNormal(t.term, cb)\n  }\n}\n\nlet reduceCallByValue = (t, cb) => {\n  switch (t.type) {\n  case Var:\n  case Fun:\n    return t\n  case App:\n    let l = reduceCallByValue(t.left, composeAppR(cb, t.right))\n    let r = reduceCallByValue(t.right, composeAppL(cb, l))\n    return l.type === Fun\n      ? reduceCallByValue(apply(l, r, cb), cb)\n      : App(l, r)\n  case Def:\n    cb(markStep('def', t, t.term))\n    return reduceCallByValue(t.term, cb)\n  }\n}\n\nlet reduceApplicative = (t, cb) => {\n  switch (t.type) {\n  case Var:\n    return t\n  case Fun:\n    return Fun(t.param, reduceApplicative(t.body, composeFun(cb, t.param)))\n  case App:\n    let l = reduceCallByValue(t.left, composeAppR(cb, t.right))\n    if (l.type === Fun) {\n      let r = reduceCallByValue(t.right, composeAppL(cb, l))\n      return reduceApplicative(apply(l, r, cb), cb)\n    } else {\n      l = reduceApplicative(l, composeAppR(cb, t.right))\n      let r = reduceApplicative(t.right, composeAppL(cb, l))\n      return App(l, r)\n    }\n  case Def:\n    cb(markStep('def', t, t.term))\n    return reduceApplicative(t.term, cb)\n  }\n}\n\nlet apply = (fun, subst, cb) => {\n  let renameCb = composeFun(composeAppR(cb, subst), fun.param)\n  let renamedBody = renameForSubstitution(fun.body, fun.param, subst, renameCb)\n  let renamed = App(Fun(fun.param, renamedBody), subst)\n  let applied = applySubstitution(renamedBody, fun.param, subst)\n  cb(markStep('beta', renamed, applied))\n  return applied\n}\n\n// Performs any available η-reductions on a term.\nlet reduceEta = (t, cb) => {\n  switch (t.type) {\n  case Var:\n    return t\n  case Fun:\n    // λx.(F x) = F if x is free in F\n    let isEta = t.body.type === App &&\n      t.body.right.type === Var &&\n      t.body.right.name === t.param &&\n      !freeIn(t.param, t.body.left)\n    if (isEta) {\n      cb(markStep('eta', t, t.body.left))\n      return t.body.left\n    } else {\n      return Fun(t.param, reduceEta(t.body, composeFun(cb, t.param)))\n    }\n  case App:\n    let l = reduceEta(t.left, composeAppR(cb, t.right))\n    let r = reduceEta(t.right, composeAppR(cb, l))\n    return App(l, r)\n  case Def:\n    return t\n  }\n}\n\nlet reduceFunctions = {\n  normal: reduceNormal,\n  applicative: reduceApplicative,\n  cbn: reduceCallByName,\n  cbv: reduceCallByValue\n}\n","let {Var, Fun, App, Def} = require('./terms')\nlet {markStep, composeFun, composeAppL, composeAppR} = require('./helpers')\nlet freeIn = require('./free-in')\n\n// Applies the substitution T[x := S]\n// I.e., substitutes the variable x for the term S in the term T.\nlet substitute = (t, x, s) => {\n  switch (t.type) {\n  case Var:\n    // x[x := S] = S\n    // y[x := S] = y\n    return t.name === x ? s : t\n  case Fun:\n    // (λx.E)[x := S] = λx.E\n    // λx creates a new context for x so no further substitution is needed.\n    if (t.param === x) return t\n    // (λy.E)[x := S] with x != y\n    // If y is free in S and x is free in E, then must α-convert λy.E to avoid\n    // name conflicts.\n    if (freeIn(t.param, s) && freeIn(x, t.body)) {\n      // (λy.E)[x := S] = λy'.(E[y := y'][x := S])\n      let newVarName = renameVar(t.param, t.body, s)\n      let renamedBody = applySubstitution(t.body, t.param, Var(newVarName))\n      return Fun(newVarName, substitute(renamedBody, x, s))\n    } else {\n      // (λy.E)[x := S] = λy.(E[x := S])\n      return Fun(t.param, substitute(t.body, x, s))\n    }\n  case App:\n    // (U V)[x := S] = (U[x := S]) (V[x := S])\n    return App(substitute(t.left, x, s), substitute(t.right, x, s))\n  case Def:\n    return t\n  }\n}\n\n// Note: renameForSubstitution() and applySubstitution() are the same as\n// substitute(), only split up into two different steps. We need them that way\n// to be able to do all alpha-renaming steps before each beta-reduction, but it\n// would be nice to have these three functions DRY up a bit.\n\n// Performs the α-conversions necessary for the substitution T[x := S], but does\n// not perform the substitution itself.\n// Records the α-conversions by calling cb.\nlet renameForSubstitution = (t, x, s, cb) => {\n  switch (t.type) {\n  case Var:\n  case Def:\n    return t\n  case Fun:\n    if (t.param === x) return t\n    if (freeIn(t.param, s) && freeIn(x, t.body)) {\n      let newVarName = renameVar(t.param, t.body, s)\n      let renamedBody = applySubstitution(t.body, t.param, Var(newVarName))\n      cb(markStep('alpha', t, t = Fun(newVarName, renamedBody)))\n    }\n    let body = renameForSubstitution(t.body, x, s, composeFun(cb, t.param))\n    return Fun(t.param, body)\n  case App:\n    let l = renameForSubstitution(t.left, x, s, composeAppR(cb, t.right))\n    let r = renameForSubstitution(t.right, x, s, composeAppL(cb, l))\n    return App(l, r)\n  }\n}\n\n// Applies the substitution T[x := S] directly, without doing α-conversions.\nlet applySubstitution = (t, x, s) => {\n  switch (t.type) {\n  case Var:\n    return t.name === x ? s : t\n  case Fun:\n    return t.param === x\n      ? t\n      : Fun(t.param, applySubstitution(t.body, x, s))\n  case App:\n    let l = applySubstitution(t.left, x, s)\n    let r = applySubstitution(t.right, x, s)\n    return App(l, r)\n  case Def:\n    return t\n  }\n}\n\n// Renames a variable to avoid naming conflicts case doing: a substitution.\nlet renameVar = (oldName, t, s) => {\n  // Split the name into base and number part.\n  let base = oldName.replace(/\\d+$/, '')\n  let match = oldName.match(/\\d+$/)\n  let n = match ? parseInt(match[0]) : 0\n\n  while (true) {\n    n++\n    let newName = base + n\n    let isValid =\n      // Avoid name collisions with substitution term.\n      !freeIn(newName, s) &&\n      // Avoid name collisions with free variables in body.\n      !freeIn(newName, t) &&\n      // Avoid name collisions with inner functions.\n      !varRenameCollides(t, oldName, newName)\n\n    if (isValid) return newName\n  }\n}\n\n// Whether a variable rename collides in a given term. That is, if changing the\n// occurrences of oldName with newName in t would make it change t's meaning\n// (i.e. not be α-equivalent).\nlet varRenameCollides = (t, oldName, newName) => {\n  switch (t.type) {\n  case Var:\n  case Def:\n    return false\n  case Fun:\n    // A variable rename collides with this function if the old variable\n    // was free in the function and the new name for the variable is the\n    // same as the param of the function, thus changing old free variable\n    // binding.\n    return t.param === newName && freeIn(oldName, t) ||\n      // Or if the renaming collides in the body of the function.\n      varRenameCollides(t.body, oldName, newName)\n  case App:\n    return varRenameCollides(t.left, oldName, newName) ||\n      varRenameCollides(t.right, oldName, newName)\n  }\n}\n\nmodule.exports = {substitute, renameForSubstitution, applySubstitution}\n","// Term types/constructors.\nlet Var = name => ({type: Var, name})\nlet Fun = (param, body) => ({type: Fun, param, body})\nlet App = (left, right) => ({type: App, left, right})\nlet Def = (name, term) => ({type: Def, name, term})\n\nmodule.exports = {Var, Fun, App, Def}\n","exports.extend = Object.assign || ((obj, ...srcs) => {\n  srcs.forEach(src => {\n    for (let k in src) {\n      obj[k] = src[k]\n    }\n  })\n  return obj\n})\n\nlet logTimings = false\nexports.timed = (name, fn) => (...args) => {\n  logTimings && console.time(name)\n  let res = fn(...args)\n  logTimings && console.timeEnd(name)\n  return res\n}\n\nexports.enableLogTimings = () => { logTimings = true }\nexports.disableLogTimings = () => { logTimings = false }\n\nexports.compose = (f, g) => (x) => f(g(x))\n\nexports.identity = x => x\n\nexports.dedent = str => {\n  let match = str.match(/^[ \\t]*(?=\\S)/gm)\n\n  if (!match) return str\n\n  let indent = Math.min(...match.map(x => x.length))\n  let re = new RegExp(`^[ \\\\t]{${indent}}`, 'gm')\n  let unindented = indent > 0 ? str.replace(re, '') : str\n\n  return unindented.trim()\n}\n\nexports.collapseWhitespace = str => str.replace(/\\s+/gm, ' ')\n"]}